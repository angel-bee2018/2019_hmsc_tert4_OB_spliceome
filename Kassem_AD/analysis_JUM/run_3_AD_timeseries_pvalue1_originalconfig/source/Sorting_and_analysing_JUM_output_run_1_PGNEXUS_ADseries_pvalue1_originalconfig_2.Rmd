---
title: "Sorting JUM output files and analysing them for the PGNEXUS AD series bulk RNA-Seq"
author: "Angel Liang"
date: "10/21/2019"
output: pdf_document
---

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(dplyr)
# .datatable.aware = TRUE
library(purrr)
# library(data.table)
library(gtools)
library(extrafont)
loadfonts(device="win")
windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(genefilter)

library(ggplot2)
library(kohonen)
library(genefilter)
library(gplots)
library(lattice)
library(svglite)
library(scales)
library(stringr)

library(biomaRt)
ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

library(systemPipeR)
library(GOstats)
library(PFAM.db)
library(bc3net)

library(ggdendro)
library(data.table)
library(Rfast)


results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_AD_fastqc/analysis_JUM/run_3_AD_timeseries_pvalue1_originalconfig/results/"

results_directory_figures <- paste(results_dir, "figures/", sep="")

if(! dir.exists(results_directory_figures) ) {
     dir.create(results_directory_figures, recursive = TRUE)}


```

## defining functions

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch != 0, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes != 0, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

# THIS TABLE WILL SPLIT THE IN-CELL CONCATENATED/DELIMITED OUTPUT FOR EACH SUMMARY TABLE FOR EACH SPLICEMODE

split_JUM_output_table <- function(summary_table_onesplicemode, name_of_extra_colname_to_split, name_of_splicemode) {
  
  # SPLITTING THE SEMICOLON DELIMITED VALUES INTO NEW ROWS

summary_table_onesplicemode <- summary_table_onesplicemode %>% na.omit

summary_table_onesplicemode_column_names <- colnames(summary_table_onesplicemode)

summary_table_onesplicemode_dPSI_column_numbers <- summary_table_onesplicemode_column_names %>% grep(., pattern = paste("deltaPSI(.*)|", name_of_extra_colname_to_split, sep = ""))

# A. SPLITTING EACH CELL OF DELTAPSI INTO SEPARATE ROWS
# THIS OUTPUTS A LIST WITH EACH ELEMENT CONTAINING THE VALUES OF EACH ROW
list_of_onesplicemode_dPSI_values_only_split <- summary_table_onesplicemode[, summary_table_onesplicemode_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){strsplit(x, split = ";")})

# WE MUST FIRST DEFINE THE FINAL TABLE THEN GO BACK TO FINISHING THE FINAL TABLE BECAUSE IT NEEDS TO SCAFFOLD BASED ON A PREDETERMINED NUMBER OF ROWS IN data.frame(matrix(...))

# B. USE SPLITTING LENGTH FOR EACH ROW TO DETERMINE THE AMOUNT OF TIMES ROWS ARE TO BE REPEATED.
# THIS OUTPUTS THE SAME DATA.FRAME EXCEPT THE RIGHT COLUMNS ARE REPEATED THE SAME NUMBER OF TIMES AS SEMICOLONS
summary_table_onesplicemode_non_dPSI_values_only_split <- summary_table_onesplicemode[, -summary_table_onesplicemode_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){rep(x, sapply(list_of_onesplicemode_dPSI_values_only_split[[1]], length))}) %>% data.frame

list_of_isoform_number <- list_of_onesplicemode_dPSI_values_only_split[[1]] %>% lapply(length) %>% purrr::map(.x = ., ~c(1:.x)) %>% unlist

# DONE STEP B.

# BACK TO A.
summary_table_onesplicemode_dPSI_values_only_split <- data.frame(matrix(unlist(list_of_onesplicemode_dPSI_values_only_split), nrow = nrow(summary_table_onesplicemode_non_dPSI_values_only_split), byrow = FALSE), stringsAsFactors = FALSE)

colnames(summary_table_onesplicemode_dPSI_values_only_split) <- names(list_of_onesplicemode_dPSI_values_only_split)

# DONE STEP A.

# APPEND THE TWO TABLES TO RE-CREATE THE WIDE MASTER TABLE EXCEPT THE VALUES ARE ACTUALLY REOBABLE BY R NOW.
summary_table_onesplicemode_split <- dplyr::bind_cols(summary_table_onesplicemode_non_dPSI_values_only_split, summary_table_onesplicemode_dPSI_values_only_split)

# rearrange the columns to preserve consistency with the rest of the wide_tables

summary_table_onesplicemode_split <- summary_table_onesplicemode_split[, summary_table_onesplicemode_column_names]

# append the list of isoform numbers

summary_table_onesplicemode_split <- cbind(summary_table_onesplicemode_split, isoform_number = list_of_isoform_number)

# append the list of isoform IDs

summary_table_onesplicemode_split <- cbind(summary_table_onesplicemode_split, isoform_ID = paste(name_of_splicemode, summary_table_onesplicemode_split$AS_event_ID, summary_table_onesplicemode_split$isoform_number, sep = "_"))

# remove non-integer values

summary_table_onesplicemode_split <- type_convert(summary_table_onesplicemode_split, na = c("Inf", "-Inf"), trim_ws = TRUE)

summary_table_onesplicemode_split_with_na <- summary_table_onesplicemode_split

# summary_table_onesplicemode_split <- summary_table_onesplicemode_split %>% na.omit

row.names(summary_table_onesplicemode_split) <- NULL

# re-interpret numbers as numeric

# summary_table_onesplicemode_split[, !(colnames(summary_table_onesplicemode_split) == c("Gene", "AS_event_ID", "splicemode", name_of_extra_colname_to_split))] <- summary_table_onesplicemode_split[, !(colnames(summary_table_onesplicemode_split) == c("Gene", "AS_event_ID", "splicemode", name_of_extra_colname_to_split))] %>% mutate_each(., funs = as.character) %>% mutate_each(., funs = as.numeric)

summary_table_onesplicemode_split <- summary_table_onesplicemode_split %>% type_convert
  
return(summary_table_onesplicemode_split)


}


# END split_JUM_output_table

# function to convert the isoform_ID from JUM and splicemode of isoforms of interest into chr, strand, start and end co-ordinates that ensembldb can read.
# input tibble structure: MUST CONTAIN: gene "Gene", JUM isoform ID "AS_event_ID" and "splicemode"

JUM_ASeventID_and_splicemode_to_chr_strand_start_end <- function(tibble_of_isoforms_to_be_consequence_assessed) {
  
  # subset A3SS_events, filter out the isoform of interest from the master A3SS_events table and then return all 4 co-ordinates
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A3SS_events",] %>% nrow != 0) {
    
  A3SS_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A3SS_events", c("Gene", "AS_event_ID")]
  A3SS_subset <- dplyr::inner_join(A3SS_summary_table, A3SS_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "common_5_SS_coor", "A3SS_coordinates")]
  A3SS_subset <- cbind(A3SS_subset, chr = gsub(x = A3SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = A3SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% cbind(., start = gsub(x = A3SS_subset$A3SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\1")) %>% cbind(., end = gsub(x = A3SS_subset$A3SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\3"))
  A3SS_subset <- A3SS_subset[, c("Gene", "AS_event_ID", "chr", "strand", "start", "end")] %>% as_tibble
  A3SS_subset[, "splicemode"] <- "A3SS_events"
  
  }

  # subset A5SS_events
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A5SS_events",] %>% nrow != 0) {
    
  A5SS_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A5SS_events", c("Gene", "AS_event_ID")]
  A5SS_subset <- dplyr::inner_join(A5SS_summary_table, A5SS_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "common_3_SS_coor", "A5SS_coordinates")]
  A5SS_subset <- cbind(A5SS_subset, chr = gsub(x = A5SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = A5SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% cbind(., start = gsub(x = A5SS_subset$A5SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\1")) %>% cbind(., end = gsub(x = A5SS_subset$A5SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\3"))
  A5SS_subset <- A5SS_subset[, c("Gene", "AS_event_ID", "chr", "strand", "start", "end")] %>% as_tibble
  A5SS_subset[, "splicemode"] <- "A5SS_events"
  
  }

  # subset cassette
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "cassette_exon_events",] %>% nrow != 0) {
    
  cassette_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "cassette_exon_events", c("Gene", "AS_event_ID")]
  cassette_subset <- dplyr::inner_join(cassette_exon_summary_table, cassette_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "upstream_exon_end_coor", "cassette_exon_start_coor", "cassette_exon_end_coor", "downstream_exon_start_coor")]
  cassette_subset <- cbind(cassette_subset, chr = gsub(x = cassette_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = cassette_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2"))
  cassette_subset <- cassette_subset[, c("Gene", "AS_event_ID", "chr", "strand", "cassette_exon_start_coor", "cassette_exon_end_coor")] %>% as_tibble
  names(cassette_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  cassette_subset[, "splicemode"] <- "cassette_exon_events"
  
  
  }

  # subset MXE events
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "MXE_events",] %>% nrow != 0) {
    
    MXE_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "MXE_events", c("Gene", "isoform_ID")]
  MXE_subset <- dplyr::inner_join(MXE_events_summary_table_split, MXE_subset, by = c("Gene", "isoform_ID")) %>% .[, c( "Gene", "AS_event_ID", "isoform_ID", "upstream_exon_end_coor", "MXE_exon_coordinates", "downstream_exon_start_coor")]
  MXE_subset <- cbind(MXE_subset, chr = gsub(x = MXE_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = MXE_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% cbind(., start = gsub(x = MXE_subset$MXE_exon_coordinates, pattern = "(.*)-(.*)", replacement = "\\1")) %>% cbind(., end = gsub(x = MXE_subset$MXE_exon_coordinates, pattern = "(.*)-(.*)", replacement = "\\2"))
  MXE_subset <- MXE_subset[, c("Gene", "isoform_ID", "chr", "strand", "start", "end")] %>% as_tibble
  names(MXE_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  MXE_subset[, "splicemode"] <- "MXE_events"
    
  }
  
  # subset IR events
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "intron_retention",] %>% nrow != 0) {
    
  IR_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "intron_retention", c("Gene", "AS_event_ID")]
  IR_subset <- dplyr::inner_join(IR_events_summary_table, IR_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "retained_intron_start", "retained_intron_end")]
  IR_subset <- cbind(IR_subset, chr = gsub(x = IR_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = IR_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2"))
  IR_subset <- IR_subset[, c("Gene", "AS_event_ID", "chr", "strand", "retained_intron_start", "retained_intron_end")] %>% as_tibble
  colnames(IR_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  IR_subset[, "splicemode"] <- "intron_retention"
  
  }
  
  # subset composite events
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "composite_events",] %>% nrow != 0) {
    
  composite_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "composite_events", c("Gene", "AS_event_ID")]
  composite_subset <- dplyr::inner_join(composite_events_summary_table, composite_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID")]
  composite_subset <- cbind(composite_subset, chr = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% 
    cbind(., strand = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% 
    cbind(., start = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10})", replacement = "\\3")) %>% 
    cbind(., end = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10})", replacement = "\\5"))
  
  # generating intervals using the composite coordinate vertices provided
  
  # (deprecated) ##
  # list_of_composite_subset_coordinates <- gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\3") %>% strsplit(split = "_")
  # list_of_composite_subset_coordinates <- purrr::map(.x = list_of_composite_subset_coordinates, .f = ~.x[1:(length(.x)-1)] %>% cbind(., end = .x[2:(length(.x))]) %>% as_tibble)
  # list_of_composite_subset_coordinates <- purrr::map(.x = list_of_composite_subset_coordinates, ~rename(.x, start = 1, end = 2))
  # 
  # composite_subset <- apply(X = composite_subset, MARGIN = 2, FUN = function(x){rep(x, times = purrr::map(list_of_composite_subset_coordinates, nrow) %>% unlist)}) %>% cbind(., start = purrr::map(list_of_composite_subset_coordinates, ~.x$start) %>% unlist) %>% cbind(., end = purrr::map(list_of_composite_subset_coordinates, ~.x$end) %>% unlist)
  
  composite_subset <- composite_subset[, c("Gene", "AS_event_ID", "chr", "strand", "start", "end")] %>% as_tibble
  
  colnames(composite_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  composite_subset[, "splicemode"] <- "composite_events"
  
  }
  
  ### CONCATENATE ALL THE SUBSET LISTS BACK INTO A SINGLE TABLE
  
  tibble_of_chr_strand_start_end <- bind_rows(if (exists("A3SS_subset") == TRUE) {A3SS_subset}, 
                                              if (exists("A5SS_subset") == TRUE) {A5SS_subset}, 
                                              if (exists("cassette_subset") == TRUE) {cassette_subset}, 
                                              if (exists("MXE_subset") == TRUE) {MXE_subset}, 
                                              if (exists("IR_subset") == TRUE) {IR_subset}, 
                                              if (exists("composite_subset") == TRUE) {composite_subset}) %>% type_convert %>% mutate_if(is.factor, as.character) %>% as_tibble %>% bind_cols(., "width" = .$end - .$start)
  
  return(tibble_of_chr_strand_start_end)
  
}

# END JUM_ASeventID_and_splicemode_to_chr_strand_start_end

# this will take the result of genomic-to-protein mapping (i.e. ENSP ids) and feed it through biomart. The result is a list of protein domain accessions/ids that overlap (AT THE MOMENT FULL OVERLAP ONLY) with the query interval
# NOTE: THIS FUNCTION ONLY ACTS ON A SINGLE TIBBLE. MUST BE USED AS PART OF PURRR::MAP FUNCTION TO PROCESS THE WHOLE LIST OF PROTEIN POSITION MAPPING RESULTS
# NOTE2: COLUMNS EXPECTED: $1 (ENSP) "names", $2 "start", $3 "width", $4 "end"

tibble_of_mapped_protein_positions_to_list_of_domains_PTMs <- function(tibble_of_mapped_proteinID, ensemblmart) {
  
input_ranges <- purrr::map2(.x = tibble_of_mapped_proteinID$start, .y = tibble_of_mapped_proteinID$end, .f = ~.x:.y %>% unlist) %>% unlist %>% unique

# interpro
interpro_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"), mart = ensemblmart) %>% array_tree

if (any(interpro_list %>% unlist %>% is.na) == FALSE) {
  
  interpro_list <- purrr::map(.x = interpro_list, .f = ~append(.x, values = list(range = .x$interpro_start:.x$interpro_end)))

} else {
  
   interpro_list <- "" 
  
  }

# coiled coils
ncoils_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"), mart = ensemblmart) %>% array_tree

if (any(ncoils_list %>% unlist %>% is.na) == FALSE) {
  
  ncoils_list <- purrr::map(.x = ncoils_list, .f = ~append(.x, values = list(range = .x$ncoils_start:.x$ncoils_end, ncoils = "ncoils")))
  
} else {
  
   ncoils_list <- "" 
  
  }

# low complexity
seg_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "seg_start", "seg_end"), mart = ensemblmart) %>% array_tree

if (any(seg_list %>% unlist %>% is.na) == FALSE) {
  
  seg_list <- purrr::map(.x = seg_list, .f = ~append(.x, values = list(range = .x$seg_start:.x$seg_end, seg = "seg")))
  
} else {
  
   seg_list <- "" 
  
  }

# signal peptide cleavage site
signalp_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "signalp_start", "signalp_end"), mart = ensemblmart) %>% array_tree

if (any(signalp_list %>% unlist %>% is.na) == FALSE) {
  
  signalp_list <- purrr::map(.x = signalp_list, .f = ~append(.x, values = list(range = .x$signalp_start:.x$signalp_end, signalp = "signalp")))
  
} else {
  
   signalp_list <- "" 
  
  }

# transmembrane helices
tmhmm_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"), mart = ensemblmart) %>% array_tree 

if (any(tmhmm_list %>% unlist %>% is.na) == FALSE) {
  
  tmhmm_list <- purrr::map(.x = tmhmm_list, .f = ~append(.x, values = list(range = .x$tmhmm_start:.x$tmhmm_end, tmhmm = "tmhmm")))
  
} else {
  
   tmhmm_list <- "" 
  
  }

#PDB-ENSP mappings
sifts_import_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"), mart = ensemblmart) %>% array_tree 

if (any(sifts_import_list %>% unlist %>% is.na) == FALSE) {
  
  sifts_import_list <-  purrr::map(.x = sifts_import_list, .f = ~append(.x, values = list(range = .x$sifts_import_start:.x$sifts_import_end)))
  
} else {
  
   sifts_import_list <- "" 
  
  }

# mobidblite (prediction of long intrinsically disordered regions) mappings
mobidblite_list <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"), mart = ensemblmart) %>% array_tree 

if (any(mobidblite_list %>% unlist %>% is.na) == FALSE) {
  
  mobidblite_list <-  purrr::map(.x = mobidblite_list, .f = ~append(.x, values = list(range = .x$mobidblite_start:.x$mobidblite_end)))
  
} else {
  
   mobidblite_list <- "" 
  
  }

all_domains_from_protein_tibble <- list(interpro = interpro_list, 
                                        ncoils = ncoils_list, 
                                        seg = seg_list, 
                                        signalp = signalp_list, 
                                        tmhmm = tmhmm_list, 
                                        sifts = sifts_import_list, 
                                        mobidblite = mobidblite_list) %>% purrr::discard(.x = ., ~any(.x == ""))

# ALL DOMAIN ANNOTATIONS FROM BIOMART ARE FINISHED HERE

all_domains_PTMs_from_protein_tibble_filtered <- keep(all_domains_from_protein_tibble %>% flatten, ~(intersect(.x$range, input_ranges) %>% length) != 0) %>% list(domains = .)

# COINCIDING PTMS
if (tibble_of_mapped_proteinID$names %>% length != 0) {
  
  column_uniprotkb_entry_IDs <- getBM(filters = "ensembl_peptide_id", values = tibble_of_mapped_proteinID$names, attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% na.omit %>% setNames(c("protein_stable_ID", "uniprotkb_entry"))
  
  if (column_uniprotkb_entry_IDs %>% nrow != 0) {
    
    table_all_PTMs_for_query_peptide <- dplyr::semi_join(dbPTM_allhuman_annotations, column_uniprotkb_entry_IDs, by = "uniprotkb_entry")
    
    table_coinciding_PTMs <- table_all_PTMs_for_query_peptide[table_all_PTMs_for_query_peptide$modified_residue_position == intersect(table_all_PTMs_for_query_peptide$modified_residue_position %>% as.numeric, input_ranges %>% as.numeric), ]
    
    if (table_coinciding_PTMs %>% nrow != 0) {
      
      all_domains_PTMs_from_protein_tibble_filtered <- append(all_domains_PTMs_from_protein_tibble_filtered, list(PTMs = table_coinciding_PTMs))
      
    }
    
  }
  
}

return(all_domains_PTMs_from_protein_tibble_filtered)

}

# END tibble_of_mapped_protein_positions_to_list_of_domains_PTMs()

# this will help us deal with ranges with partial overlap. I classify into 3 cases: 1. query start and end positions both lie in the CDS region 2. start is missing 3. end is missing 4. both missing.
# in the case of missing start/end, it's simple. we use the fact that always start > end.
# we will use the closest number between start and end which actually lies in the CDS region as a proxy for the missing value.
match_query_startend_with_vectors_of_CDSpositions <- function(vector_of_sorted_CDSpositions, ENSP_id, input_query_start, input_query_end) {
  # 
  # # case if none missing
  # if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 1 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 1) {
  # 
  #   proxy_query_start <- input_query_start
  #   proxy_query_end <- input_query_end
  #   
  # # case if input start missing
  # } else if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 0 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 1) {
  # 
  #   proxy_query_start <- min(vector_of_sorted_CDSpositions[which(input_query_start < vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions < input_query_end)])
  #   proxy_query_end <- input_query_end
  #   
  # # case if input end missing
  # } else if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 1 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 0) {

    proxy_query_start <- min(vector_of_sorted_CDSpositions[which(input_query_start <= vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions <= input_query_end)])
    proxy_query_end <- max(vector_of_sorted_CDSpositions[which(input_query_start <= vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions <= input_query_end)])

  # }

  # NOTICE: I DELIBERATELY EXPANDED THE END RANGE BY 1 TO ACCOUNT FOR N-TERMINAL METHIONINE EXCISION. THIS IS, AFTER ALL, A CATCH-ALL.

  protein_coordinate_start <-((which(vector_of_sorted_CDSpositions == proxy_query_start) - 1) %/% 3) + 1
  protein_coordinate_end <- ((which(vector_of_sorted_CDSpositions == proxy_query_end) - 1) %/% 3) + 1 + 1
  protein_coordinate_width <- protein_coordinate_end - protein_coordinate_start + 1

  tibble_of_mapped_protein_coordinates <- tribble(~names, ~start, ~width, ~end,
                                                    ENSP_id,
                                                    protein_coordinate_start,
                                                    protein_coordinate_width,
                                                    protein_coordinate_end)

  return(tibble_of_mapped_protein_coordinates)
  
  # debug
  # return(list(vector_of_sorted_CDSpositions, ENSP_id, input_query_start, input_query_end, proxy_query_start, proxy_query_end))
  
}

# END match_query_startend_with_vectors_of_CDSpositions

# FILTER THE GTF TABLE BY ANNOTATIONS OVERLAPPING WITH THE QUERY INTERVAL(S)

# possible modes that this function can operate in: 1. "AS region" and 2. "BED_file" 
# AS region mode is for finding all the overlapping gtf annotations of a given AS event
# BED file mode is for annotating a BED file (especially from CLIP-SEQ/RIP-seq/parclip) 
# target level is the filter for the "type" in gtf table. one of: "gene", "transcript", "exon", "CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr", "Selenocysteine"

map_genome_coordinate_to_transcriptandprotein <- function(chr_strand_start_end_tibble, mode, targetlevel) {
  
  if (mode == "AS region") {
  
  list_of_query_AS_event_ID <- chr_strand_start_end_tibble$AS_event_ID %>% as.list

list_of_all_overlapping_annotations <- purrr::map(.x = list_of_query_AS_event_ID, .f = ~gtf_table[
  (gtf_table$chr == chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "chr"] %>% lapply(as.character)) &
    (gtf_table$strand == chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "strand"] %>% lapply(as.character)), ] %>% 
    .[(.$start < chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "end"] %>% as.numeric) & 
        (.$end > chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "start"] %>% as.numeric), ])

names(list_of_all_overlapping_annotations) <- chr_strand_start_end_tibble$Gene


  } else if (mode == "BED_file") {
  
    bed_chr_strand_start_end <- chr_strand_start_end_tibble
    
    colnames(bed_chr_strand_start_end) <- c("feature_chr", "feature_strand", "feature_start", "feature_end", "ClusterID", "ClusterSequence", "ReadCount", "ModeLocation", "ModeScore", "ConversionLocationCount", "ConversionEventCount", "NonConversionEventCount")

gtf_table_targetlevel <- gtf_table[gtf_table$type == targetlevel, ]

colnames(gtf_table_targetlevel) <- c("annotation_chr", "annotation_start", "annotation_end", "annotation_width", "annotation_strand", "annotation_type", "annotation_annotation_phase", "annotation_gene_id", "annotation_gene_name", "annotation_gene_biotype", "annotation_transcript_id", "annotation_transcript_name", "annotation_transcript_biotype", "annotation_exon_number", "annotation_exon_id", "annotation_protein_id")

gtf_entries_overlapping_with_bed <- purrr::pmap(.l = list(bed_chr_strand_start_end[["feature_chr"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_strand"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_start"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_end"]]) %>% as.list, 
                                                   .f = ~gtf_table_targetlevel %>%
                                                     .[.$annotation_chr == ..1 %>% lapply(as.character) %>% paste, ] %>% 
                                                       .[.$annotation_strand == ..2 %>% lapply(as.character) %>% paste, ] %>% 
                                                     .[(.$annotation_start < ..4 %>% as.numeric %>% paste) & 
                                                         (.$annotation_end > ..3 %>% as.numeric %>% paste), ]) %>% compact

unannotated_bed_file_arraytree <- bed_chr_strand_start_end %>% array_tree %>% purrr::map(~as_tibble(.x))

peaks_with_annotation <- which(purrr::map(gtf_entries_overlapping_with_bed, ~nrow(.x)) %>% unlist != 0)

annotated_bed_file <- purrr::map2(.x = unannotated_bed_file_arraytree[peaks_with_annotation], 
                                  .y = gtf_entries_overlapping_with_bed[peaks_with_annotation], 
                                  .f = ~cbind(.x, .y))

# not actually a list. actually a wide table.

list_of_all_overlapping_annotations <- annotated_bed_file %>% purrr::reduce(bind_rows)

}

return(list_of_all_overlapping_annotations)
  
}

# END map_genome_coordinate_to_transcriptandprotein

# sort lists of protein CDS positions by descending/ascending order depending if ORF is on + or - strand
##  function to look at a tibble containing the CDS positions and see whether you need to sort by increasing or decreasing order

sort_tibble_according_to_strand <- function(tibble_to_be_sorted) {
  
  if (data.class(tibble_to_be_sorted) != "tbl_df") {
    
    CDS_list_out <- tibble_to_be_sorted
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "+") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = FALSE)
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "-") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = TRUE)
    
  }
  
  return(CDS_list_out)
  
}

# END sort_according_to_strand

# THE MAIN FUNCTION TO CONVERT THE TIDIED CHR STRAND START END TIBBLE TO LISTS OF OVERLAPPING ANNOTATION AND PROTEIN DOMAINS
# inputs: 1. table containing regions to be queried. columns must be: Gene, AS event ID, chr, strand, start, end; 2. GTF table, preferably from rtracklayer::import, 3. ensembl mart of choice

tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain <- function(tibble_queryisoforms_chr_strand_start_end, gtf_table, ensemblmart) {
  
list_queryisoforms_overlapping_annotations_tibbles <- tibble_queryisoforms_chr_strand_start_end %>% map_genome_coordinate_to_transcriptandprotein(., mode = "AS region", targetlevel = "") %>% purrr::modify_depth(., 4, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 3, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 2, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 1, ~purrr::compact(.x), .ragged = TRUE)

list_overlapping_protein_CDS_exons_tibbles <- purrr::map(.x = list_queryisoforms_overlapping_annotations_tibbles, .f = ~.x$protein_id %>% na.omit %>% unique %>% as.list %>% purrr::map(.x = ., .f = ~gtf_table[gtf_table$protein_id == .x & gtf_table$type == "CDS", ] %>% .[apply(X = ., MARGIN = 1, FUN = function(X) {all(is.na(X)) == FALSE}), ]))

list_overlapping_protein_CDS_positions_tibbles <- purrr::map_depth(.x = list_overlapping_protein_CDS_exons_tibbles, .depth = 2, .f = ~sort_tibble_according_to_strand(.x))

# list_overlapping_protein_CDS_positions_tibbles <- purrr::modify_if(.x = list_overlapping_protein_CDS_exons_tibbles, .p = ~length(.x) != 0, .f = ~purrr::modify_if(.x = .x, .p = ~.x$strand %>% lapply(as.character) %>% unique %>% paste == "+", .f = ~purrr::map2(.x = .$start, .y = .$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = FALSE)))
# list_overlapping_protein_CDS_positions_tibbles <- purrr::modify_if(.x = list_overlapping_protein_CDS_positions_tibbles, .p = ~length(.x) != 0, .f = ~purrr::modify_if(.x = .x, .p = ~.x$strand %>% lapply(as.character) %>% unique %>% paste == "-", .f = ~purrr::map2(.x = .$start, .y = .$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = TRUE)))

# we now generate a table of mapped protein relative coordinates for each genomic start and end nested inside each gene enrichment query.
# provided functions: 
# 1. list_overlapping_protein_CDS_positions_tibbles: list of genes corresponding to isoform enriched > list of vectors of genomic positions of CDS for each ENSP, 
# 2. 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% as.list: level 1 indices, 
# 3. list_overlapping_protein_CDS_exons_tibbles: list of genes corresponding to isoform enriched > list of subsets of GTF table for each unique ENSP caught by query range. used for ENSP id mapping 
# NOTE: width < 0 if the ORF is on the - strand
mapped_aminoacid_positions <- purrr::pmap(.l = list(list_overlapping_protein_CDS_positions_tibbles, 
                                             1:length(list_overlapping_protein_CDS_positions_tibbles) %>% as.list,
                                             list_overlapping_protein_CDS_exons_tibbles), .f = ~purrr::pmap(
  .l = list(..1, rep(..2, times = length(..1)) %>% as.list, ..3), 
  .f = ~match_query_startend_with_vectors_of_CDSpositions(..1, paste(..3$protein_id %>% unique), paste(tibble_queryisoforms_chr_strand_start_end[..2, "start"]) %>% as.numeric, paste(tibble_queryisoforms_chr_strand_start_end[..2, "end"]) %>% as.numeric)
      ))

# FINALLY! PROTEIN DOMAIN MATCHING!

# get rid of empty genes with no match
mapped_aminoacid_positions <- purrr::discard(.x = mapped_aminoacid_positions, .p = ~length(.x) == 0)

conciding_domains_PTMs <- map_depth(.x = mapped_aminoacid_positions, .depth = 2, .f = ~tibble_of_mapped_protein_positions_to_list_of_domains_PTMs(.x, ensemblmart)) %>% purrr::modify_depth(., 4, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 3, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 2, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 1, ~purrr::compact(.x), .ragged = TRUE)

return(list(overlapping_annotated_regions = list_queryisoforms_overlapping_annotations_tibbles, conciding_domains_and_PTMs = conciding_domains_PTMs) %>% purrr::modify_depth(., 4, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 3, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 2, ~purrr::compact(.x), .ragged = TRUE) %>% purrr::modify_depth(., 1, ~purrr::compact(.x), .ragged = TRUE))

}

# END tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain

# function to un-nest the results table and remove all the duplicates so you can see everything at a glance

simplify_consequence_table <- function(consequence_table, ensemblmart) {
  
  transcript_feature_tibble <- purrr::map(consequence_table$overlapping_annotated_regions, ~paste(.x$type, .x$exon_number %>% str_replace_na(., replacement = "")) %>% unique %>% mixedsort) %>% plyr::ldply(., rbind) %>% t
  
  colnames(transcript_feature_tibble) <- transcript_feature_tibble[1 , ] 
  transcript_feature_tibble <- transcript_feature_tibble[-1, ] %>% as_tibble
  
  domain_PTM_list_flattened <- consequence_table$conciding_domains_and_PTMs %>% purrr::flatten(.) %>% purrr::flatten(.)
  
  domain_info_positions <- which(names(domain_PTM_list_flattened) == "domains")
  
  PTM_info_positions <- which(names(domain_PTM_list_flattened) == "PTMs")
  
  if (domain_info_positions %>% length != 0) {
    
    domain_PTM_list_flattened_2 <- purrr::modify_at(.x = domain_PTM_list_flattened, .at = domain_info_positions, .f = ~purrr::map(.x, .f = ~.x[names(.x) != "range"]) %>% purrr::reduce(., bind_rows))
  
  domains_tibble <- purrr::reduce(domain_PTM_list_flattened_2[domain_info_positions], bind_rows)
  
  domains_tibble_2 <- dplyr::left_join(domains_tibble, getBM(filters = "ensembl_peptide_id", values = domains_tibble$ensembl_peptide_id, attributes = c("ensembl_peptide_id", "external_gene_name"), mart = ensemblmart), by = "ensembl_peptide_id")
    
  } else {
    
    domains_tibble_2 <- NULL
    
  }

  if (PTM_info_positions %>% length != 0) {
    
    PTMs_tibble <- purrr::reduce(domain_PTM_list_flattened_2[PTM_info_positions], bind_rows)
  } else {
    
    PTMs_tibble <- NULL
    
  }
  
  return(list("transcript features" = transcript_feature_tibble, "protein domains" = domains_tibble_2, "PTMs" = PTMs_tibble))
  
}

# END simplify_consequence_table

```

# read all the final tables into environment

```{r}

list_of_timepoint_comparisons_final <- read.delim(paste(results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL)

print(head(list_of_timepoint_comparisons_final))

for (comparison in list_of_timepoint_comparisons_final[, 1])
{
  
  for (AS_event in c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events"))
  {
    
    assign(x = paste(comparison, "_", AS_event, "_simplified", sep = ""), value = read.delim(file = paste(results_dir, "final_JUM_output_", comparison, "/", list.files(path = paste(results_dir, "final_JUM_output_", comparison, "/", sep = ""), pattern = paste("(.)", AS_event, "(.*)simplified.txt", sep = "")), sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf"), colClasses = "character"))
  
  }
  
}

# this must be equal to the total number of comparisons

length(ls(pattern = "(.*)simplified")) / 6

```

# chopping files into a net summary table

note: the final simplified intron retention table outputted by JUM has two header rows. Remove those.

## A3SS_events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_A3SS_simplified_output_table_names <- ls(pattern = "(.*)(_)(A3SS_events)(_simplified$)")
print(paste("There are", length(list_of_A3SS_simplified_output_table_names), "output tables loaded for A3SS_events events:", sep = " "))  
## convert from column of names to column of dfs
list_of_A3SS_simplified_output_tables <- purrr::map(list_of_A3SS_simplified_output_table_names, get)
names(list_of_A3SS_simplified_output_tables) <- list_of_A3SS_simplified_output_table_names
## subset
list_of_A3SS_simplified_output_tables_simplified <- purrr::map(list_of_A3SS_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9))
## annotating the column names to be comparison name specific

A3SS_pvalue_column_names <- gsub(x = list_of_A3SS_simplified_output_table_names, pattern = "(.*)_A3SS_events_simplified", replacement = "pvalue_\\1") %>% as.list
A3SS_qvalue_column_names <- gsub(x = list_of_A3SS_simplified_output_table_names, pattern = "(.*)_A3SS_events_simplified", replacement = "qvalue_\\1") %>% as.list

list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_simplified, .y = A3SS_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_shuffled, .y = A3SS_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))


# list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_simplified, .y = A3SS_pvalue_column_names, ~rename(.x, !!.y := 5))
# list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_shuffled, .y = A3SS_qvalue_column_names, ~rename(.x, !!.y := 6))

print(paste("Shuffled", length(list_of_A3SS_simplified_output_tables_shuffled), "output tables for A3SS_events events:", sep = " "))  

# conduct full join of all the shuffled tables

A3SS_summary_table <- list_of_A3SS_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("common_5_SS_coor", "Gene", "AS_event_ID", "A3SS_coordinates"))

# NOTEEEEEE: further column exclusion later on.

# A3SS_trimmed_table <- A3SS_summary_table[, c(1, 2, 5, 6, 7... to the end)]

```

## A5SS_events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_A5SS_simplified_output_table_names <- ls(pattern = "(.*)(_)(A5SS_events)(_simplified$)")
print(paste("There are", length(list_of_A5SS_simplified_output_table_names), "output tables loaded for A5SS_events events:", sep = " "))  
## convert from column of names to column of dfs
list_of_A5SS_simplified_output_tables <- purrr::map(list_of_A5SS_simplified_output_table_names, get)
names(list_of_A5SS_simplified_output_tables) <- list_of_A5SS_simplified_output_table_names

## subset
list_of_A5SS_simplified_output_tables_simplified <- purrr::map(list_of_A5SS_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9))
## annotating the column names to be comparison name specific

A5SS_pvalue_column_names <- gsub(x = list_of_A5SS_simplified_output_table_names, pattern = "(.*)_A5SS_events_simplified", replacement = "pvalue_\\1")
A5SS_qvalue_column_names <- gsub(x = list_of_A5SS_simplified_output_table_names, pattern = "(.*)_A5SS_events_simplified", replacement = "qvalue_\\1")

list_of_A5SS_simplified_output_tables_shuffled <- purrr::map2(list_of_A5SS_simplified_output_tables_simplified, A5SS_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_A5SS_simplified_output_tables_shuffled <- purrr::map2(list_of_A5SS_simplified_output_tables_shuffled, A5SS_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_A5SS_simplified_output_tables_shuffled), "output tables for A5SS_events events:", sep = " "))  

# conduct full join of all the shuffled tables

A5SS_summary_table <- list_of_A5SS_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("common_3_SS_coor", "Gene", "AS_event_ID", "A5SS_coordinates"))


```

## cassette exon

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_cassette_exon_simplified_output_table_names <- ls(pattern = "(.*)(_)(cassette_exon_events)(_simplified$)")
print(paste("There are", length(list_of_cassette_exon_simplified_output_table_names), "output tables loaded for cassette exon events:", sep = " "))  
## convert from column of names to column of dfs
list_of_cassette_exon_simplified_output_tables <- purrr::map(list_of_cassette_exon_simplified_output_table_names, get)
names(list_of_cassette_exon_simplified_output_tables) <- list_of_cassette_exon_simplified_output_table_names

## subset
list_of_cassette_exon_simplified_output_tables_simplified <- purrr::map(list_of_cassette_exon_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9, 10, 11))
## annotating the column names to be comparison name specific

cassette_exon_pvalue_column_names <- gsub(x = list_of_cassette_exon_simplified_output_table_names, pattern = "(.*)_cassette_exon_events_simplified", replacement = "pvalue_\\1")
cassette_exon_qvalue_column_names <- gsub(x = list_of_cassette_exon_simplified_output_table_names, pattern = "(.*)_cassette_exon_events_simplified", replacement = "qvalue_\\1")


list_of_cassette_exon_simplified_output_tables_shuffled <- purrr::map2(list_of_cassette_exon_simplified_output_tables_simplified, cassette_exon_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_cassette_exon_simplified_output_tables_shuffled <- purrr::map2(list_of_cassette_exon_simplified_output_tables_shuffled, cassette_exon_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_cassette_exon_simplified_output_tables_shuffled), "output tables for cassette exon events:", sep = " "))  

# conduct full join of all the shuffled tables

cassette_exon_summary_table <- list_of_cassette_exon_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("upstream_exon_end_coor", "downstream_exon_start_coor", "Gene", "AS_event_ID", "cassette_exon_start_coor", "cassette_exon_end_coor"))


```

## MXE events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_MXE_events_simplified_output_table_names <- ls(pattern = "(.*)(_)(MXE_events)(_simplified$)")
print(paste("There are", length(list_of_MXE_events_simplified_output_table_names), "output tables loaded for MXE events:", sep = " "))  
## convert from column of names to column of dfs
list_of_MXE_events_simplified_output_tables <- purrr::map(list_of_MXE_events_simplified_output_table_names, get)
names(list_of_MXE_events_simplified_output_tables) <- list_of_MXE_events_simplified_output_table_names

## subset
list_of_MXE_events_simplified_output_tables_simplified <- purrr::map(list_of_MXE_events_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9, 10))
## annotating the column names to be comparison name specific

MXE_events_pvalue_column_names <- gsub(x = list_of_MXE_events_simplified_output_table_names, pattern = "(.*)_MXE_events_simplified", replacement = "pvalue_\\1")
MXE_events_qvalue_column_names <- gsub(x = list_of_MXE_events_simplified_output_table_names, pattern = "(.*)_MXE_events_simplified", replacement = "qvalue_\\1")


list_of_MXE_events_simplified_output_tables_shuffled <- purrr::map2(list_of_MXE_events_simplified_output_tables_simplified, MXE_events_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_MXE_events_simplified_output_tables_shuffled <- purrr::map2(list_of_MXE_events_simplified_output_tables_shuffled, MXE_events_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_MXE_events_simplified_output_tables_shuffled), "output tables for MXE exon events:", sep = " "))  

# conduct full join of all the shuffled tables

MXE_events_summary_table <- list_of_MXE_events_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("upstream_exon_end_coor", "downstream_exon_start_coor", "Gene", "AS_event_ID", "MXE_exon_coordinates"))

MXE_events_summary_table_split <- split_JUM_output_table(MXE_events_summary_table, "MXE_exon_coordinates", "MXE_events")

```

## composite events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_composite_events_simplified_output_table_names <- ls(pattern = "(.*)(_)(composite_events)(_simplified$)")
print(paste("There are", length(list_of_composite_events_simplified_output_table_names), "output tables loaded for composite events:", sep = " "))  
## convert from column of names to column of dfs
list_of_composite_events_simplified_output_tables <- purrr::map(list_of_composite_events_simplified_output_table_names, get)
## subset
list_of_composite_events_simplified_output_tables_simplified <- purrr::map(list_of_composite_events_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8))
## annotating the column names to be comparison name specific

composite_events_pvalue_column_names <- gsub(x = list_of_composite_events_simplified_output_table_names, pattern = "(.*)_composite_events_simplified", replacement = "pvalue_\\1")
composite_events_qvalue_column_names <- gsub(x = list_of_composite_events_simplified_output_table_names, pattern = "(.*)_composite_events_simplified", replacement = "qvalue_\\1")


list_of_composite_events_simplified_output_tables_shuffled <- purrr::map2(list_of_composite_events_simplified_output_tables_simplified, composite_events_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_composite_events_simplified_output_tables_shuffled <- purrr::map2(list_of_composite_events_simplified_output_tables_shuffled, composite_events_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_composite_events_simplified_output_tables_shuffled), "output tables for composite events:", sep = " "))  

# conduct full join of all the shuffled tables

composite_events_summary_table <- list_of_composite_events_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("Composite_coordinates", "Gene", "AS_event_ID"))

# composite_events_summary_table_split <- split_JUM_output_table(composite_events_summary_table, "Composite_coordinates", "composite_events")

```

## IR events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_IR_events_simplified_output_table_names <- ls(pattern = "(.*)(_)(intron_retention)(_simplified$)")
print(paste("There are", length(list_of_IR_events_simplified_output_table_names), "output tables loaded for IR events:", sep = " "))  
## convert from column of names to column of dfs
list_of_IR_events_simplified_output_tables <- purrr::map(list_of_IR_events_simplified_output_table_names, get)
names(list_of_IR_events_simplified_output_tables) <- list_of_IR_events_simplified_output_table_names

## subset
list_of_IR_events_simplified_output_tables_simplified <- list_of_IR_events_simplified_output_tables %>% purrr::map(~dplyr::filter(.x, chromosome != "chromosome", Gene != "", pvalue != ""))

list_of_IR_events_simplified_output_tables_simplified <- purrr::map(list_of_IR_events_simplified_output_tables_simplified, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9))
## annotating the column names to be comparison name specific

IR_events_pvalue_column_names <- gsub(x = list_of_IR_events_simplified_output_table_names, pattern = "(.*)_intron_retention_simplified", replacement = "pvalue_\\1")
IR_events_qvalue_column_names <- gsub(x = list_of_IR_events_simplified_output_table_names, pattern = "(.*)_intron_retention_simplified", replacement = "qvalue_\\1")


list_of_IR_events_simplified_output_tables_shuffled <- purrr::map2(list_of_IR_events_simplified_output_tables_simplified, IR_events_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_IR_events_simplified_output_tables_shuffled <- purrr::map2(list_of_IR_events_simplified_output_tables_shuffled, IR_events_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_IR_events_simplified_output_tables_shuffled), "output tables for IR events:", sep = " "))  

# conduct full join of all the shuffled tables

IR_events_summary_table <- list_of_IR_events_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("retained_intron_start", "retained_intron_end", "Gene", "AS_event_ID"))

```

## discard the superfluous columns for each table containing each splice mode

```{r}

# generating the list of tables
list_of_summary_tables <- list(A3SS_summary_table, A5SS_summary_table, cassette_exon_summary_table, composite_events_summary_table, IR_events_summary_table, MXE_events_summary_table)

# naming the list of tables
list_of_summary_table_names <- c("A3SS_summary_table", "A5SS_summary_table", "cassette_exon_summary_table", "composite_events_summary_table", "IR_events_summary_table", "MXE_events_summary_table")
names(list_of_summary_tables) <- list_of_summary_table_names

# remove columns we don't want

list_of_summary_tables_reduced <- list_of_summary_tables

list_of_summary_tables_reduced[[1]] <- list_of_summary_tables_reduced[[1]] %>% dplyr::select(., -3, -4)
list_of_summary_tables_reduced[[2]] <- list_of_summary_tables_reduced[[2]] %>% dplyr::select(., -3, -4)
list_of_summary_tables_reduced[[3]] <- list_of_summary_tables_reduced[[3]] %>% dplyr::select(., -(3:6))
list_of_summary_tables_reduced[[4]] <- list_of_summary_tables_reduced[[4]] %>% dplyr::select(., -3)
list_of_summary_tables_reduced[[5]] <- list_of_summary_tables_reduced[[5]] %>% dplyr::select(., -3, -4)
list_of_summary_tables_reduced[[6]] <- list_of_summary_tables_reduced[[6]] %>% dplyr::select(., -(3:5))

```

## append the name of the splice mode to each data frame 

```{r}

splicemode_colname <- rep("splicemode", 6)

column_of_splicemode_names <- gsub(x = list_of_summary_table_names, pattern = "(.*)_summary_table", replacement = "\\1")

list_of_summary_tables_reduced_appendedwithsplicemode <- purrr::map2(.x = list_of_summary_tables_reduced, .y = column_of_splicemode_names, ~cbind(.x, splicemode=.y))

```

## combining the summary tables for each splice mode into a large table

NOTE: wide_table_all_splicemodes_split IS THE MAIN TABULAR OUTPUT THAT CONTAINS VALUES THAT EXIST IN *ALL* COMPARISONS. IT WILL BE USED FOR SOMS ANALYSIS AND OTHER ANALYSES THAT REQUIRE DATA FROM ALL COMPARISONS. 

NOTE2: wide_table_of_all_splicemodes(_with_na)/wide_table_all_splicemodes_split_with_na IS/ARE THE MAIN TABULAR OUTPUT(S) THAT CONTAIN(S) *EVERYTHING*, EVEN NA VALUES. USED FOR GENE ONTOLOGY

NOTE3: I NEED TO WRITE A FUNCTION FOR THIS STEP

```{r}

wide_table_of_all_splicemodes_with_na <-  purrr::reduce(.x = list_of_summary_tables_reduced_appendedwithsplicemode, .f = bind_rows) 

wide_table_of_all_splicemodes <- wide_table_of_all_splicemodes_with_na %>% na.omit

wide_table_of_all_splicemodes <- type_convert(wide_table_of_all_splicemodes)

rownames(wide_table_of_all_splicemodes) <- NULL

# SPLITTING THE SEMICOLON DELIMITED VALUES INTO NEW ROWS

wide_table_of_all_splicemodes_column_names <- colnames(wide_table_of_all_splicemodes)


wide_table_of_all_splicemodes_dPSI_column_numbers <- wide_table_of_all_splicemodes_column_names %>% grep(., pattern = "deltaPSI(.*)")

# A. SPLITTING EACH CELL OF DELTAPSI INTO SEPARATE ROWS
# THIS OUTPUTS A LIST WITH EACH ELEMENT CONTAINING THE VALUES OF EACH ROW
list_of_all_splicemodes_dPSI_values_only_split <- wide_table_of_all_splicemodes[, wide_table_of_all_splicemodes_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){strsplit(x, split = ";")})

# WE MUST FIRST DEFINE THE FINAL TABLE THEN GO BACK TO FINISHING THE FINAL TABLE BECAUSE IT NEEDS TO SCAFFOLD BASED ON A PREDETERMINED NUMBER OF ROWS IN data.frame(matrix(...))

# B. USE SPLITTING LENGTH FOR EACH ROW TO DETERMINE THE AMOUNT OF TIMES ROWS ARE TO BE REPEATED.
# THIS OUTPUTS THE SAME DATA.FRAME EXCEPT THE RIGHT COLUMNS ARE REPEATED THE SAME NUMBER OF TIMES AS SEMICOLONS
wide_table_of_all_splicemodes_non_dPSI_values_only_split <- wide_table_of_all_splicemodes[, -wide_table_of_all_splicemodes_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){rep(x, sapply(list_of_all_splicemodes_dPSI_values_only_split[[1]], length))}) %>% data.frame

list_of_isoform_number <- list_of_all_splicemodes_dPSI_values_only_split[[1]] %>% lapply(length) %>% purrr::map(.x = ., ~c(1:.x)) %>% unlist

# DONE STEP B.

# BACK TO A.
wide_table_all_splicemodes_dPSI_values_only_split <- data.frame(matrix(unlist(list_of_all_splicemodes_dPSI_values_only_split), nrow = nrow(wide_table_of_all_splicemodes_non_dPSI_values_only_split), byrow = FALSE), stringsAsFactors = FALSE)

colnames(wide_table_all_splicemodes_dPSI_values_only_split) <- names(list_of_all_splicemodes_dPSI_values_only_split)

# DONE STEP A.

# APPEND THE TWO TABLES TO RE-CREATE THE WIDE MASTER TABLE EXCEPT THE VALUES ARE ACTUALLY READABLE BY R NOW.
wide_table_all_splicemodes_split <- dplyr::bind_cols(wide_table_of_all_splicemodes_non_dPSI_values_only_split, wide_table_all_splicemodes_dPSI_values_only_split)

# rearrange the columns to preserve consistency with the rest of the wide_table s

wide_table_all_splicemodes_split <- wide_table_all_splicemodes_split[, wide_table_of_all_splicemodes_column_names]

# append the list of isoform numbers

wide_table_all_splicemodes_split <- cbind(wide_table_all_splicemodes_split, isoform_number = list_of_isoform_number)

# remove non-integer values

wide_table_all_splicemodes_split <- type_convert(wide_table_all_splicemodes_split, na = c("Inf", "-Inf"), trim_ws = TRUE)

#####

wide_table_all_splicemodes_split_with_na <- wide_table_all_splicemodes_split

wide_table_all_splicemodes_split_with_na[, "isoform_ID"] <- paste(wide_table_all_splicemodes_split_with_na[, "splicemode"], wide_table_all_splicemodes_split_with_na[, "AS_event_ID"], wide_table_all_splicemodes_split_with_na[, "isoform_number"], sep = "_")

#####

wide_table_all_splicemodes_split <- wide_table_all_splicemodes_split %>% na.omit

row.names(wide_table_all_splicemodes_split) <- NULL

# re-interpret numbers as numeric

wide_table_all_splicemodes_split[, !(colnames(wide_table_all_splicemodes_split) == c("Gene", "AS_event_ID", "splicemode"))] <- wide_table_all_splicemodes_split[, !(colnames(wide_table_all_splicemodes_split) == c("Gene", "AS_event_ID", "splicemode"))] %>% mutate_each(., funs = as.character) %>% mutate_each(., funs = as.numeric)

```

# DRAWING SOMS TO ANALYSE TIME SERIES DATA

## preparing the wide tables which are chopped and ready for next SOMs analyses

NOTE: P/QVALUE AND DPSI FILTERING OCCURS HERE

At this point, wide_table_all_splicemodes_split includes EVERYTHING. AD and AD, qvalue, pvalue and deltaPSI.

At the present time, we shall just cluster the AD time series separate to the AD time series.

Our trick is to use only the "deltaPSI_BM_MSC_to_AD_[something]d-BM_MSC_to_ud" column and use it as a proxy for the absolute inclusion levels. Setting the PSI at timepoint 0 (MSC) is inconsequential for our method of running SOMs, as it normalises the centroid of all PSI values of each isoforms' time series anyways.

**SETUP**

```{r}

dPSI_cutoff <- 0.2

# choose either pvalue or qvalue
p_or_q_value <- "qvalue"

qpvalue_cutoff <- 0.01

```

```{r}

# reducing the table to only contain AD-specific comparisons
PSI_levels_timeseries_AD_wide <- wide_table_all_splicemodes_split

# [, -grep(x = colnames(wide_table_all_splicemodes_split), pattern = "AD")]

# reducing the table to only contain AD-specific comparisons
# PSI_levels_timeseries_AD_wide <- wide_table_all_splicemodes_split[, -grep(x = colnames(wide_table_all_splicemodes_split), pattern = "AD")]

# filtering for dPSI cutoff
PSI_levels_timeseries_AD_wide <- PSI_levels_timeseries_AD_wide[apply(PSI_levels_timeseries_AD_wide[, grep(colnames(PSI_levels_timeseries_AD_wide), pattern = "deltaPSI")], 1, function(x){any(abs(x %>% as.numeric) > dPSI_cutoff)}) == TRUE, ]

# PSI_levels_timeseries_AD_wide <- PSI_levels_timeseries_AD_wide[apply(PSI_levels_timeseries_AD_wide[, grep(colnames(PSI_levels_timeseries_AD_wide), pattern = "deltaPSI")], 1, function(x){any(abs(x) > dPSI_cutoff)}) == TRUE, ]

# filtering for FDR/pvalue
PSI_levels_timeseries_AD_wide <- PSI_levels_timeseries_AD_wide[apply(PSI_levels_timeseries_AD_wide[, grep(colnames(PSI_levels_timeseries_AD_wide), pattern = p_or_q_value)], 1, function(x){any(x %>% as.numeric < qpvalue_cutoff)}) == TRUE, ]

# PSI_levels_timeseries_AD_wide <- PSI_levels_timeseries_AD_wide[apply(PSI_levels_timeseries_AD_wide[, grep(colnames(PSI_levels_timeseries_AD_wide), pattern = p_or_q_value)], 1, function(x){any(x<0.05)}) == TRUE, ]

# further subsetting into ud-only comparisons

##  AD #####

PSI_levels_timeseries_AD_wide <- PSI_levels_timeseries_AD_wide[, c("Gene", "AS_event_ID", "splicemode", "isoform_number", colnames(PSI_levels_timeseries_AD_wide)[grep(x = colnames(PSI_levels_timeseries_AD_wide), pattern = "(deltaPSI_BM_MSC_to_)(AD)(_[0-9]{1,2}d|_[0-9]{1,2}h|)(.)(BM_MSC_to_AD_ud)")])]

PSI_levels_timeseries_AD_wide <- cbind(PSI_levels_timeseries_AD_wide, MSC = 0)

colnames(PSI_levels_timeseries_AD_wide) <- gsub(x = colnames(PSI_levels_timeseries_AD_wide), pattern = "(deltaPSI_BM_MSC_to_)(AD_)([0-9]{1,2}d|[0-9]{1,2}h)(.BM_MSC_to_AD_ud)", replacement = "\\3")

##  AD #####
# 
# PSI_levels_timeseries_AD_wide <- PSI_levels_timeseries_AD_wide[, c("Gene", "AS_event_ID", "splicemode", "isoform_number", colnames(PSI_levels_timeseries_AD_wide)[grep(x = colnames(PSI_levels_timeseries_AD_wide), pattern = "(deltaPSI_BM_MSC_to_)(AD)(_[0-9]{1,2}d|_[0-9]{1,2}h|)(.)(BM_MSC_to_ud)")])]
# 
# PSI_levels_timeseries_AD_wide <- cbind(PSI_levels_timeseries_AD_wide, MSC = 0)
# 
# colnames(PSI_levels_timeseries_AD_wide) <- gsub(x = colnames(PSI_levels_timeseries_AD_wide), pattern = "(deltaPSI_BM_MSC_to_)(AD_)([0-9]{1,2}d|[0-9]{1,2}h)(.BM_MSC_to_ud)", replacement = "\\3")


## ADDITIONAL PROCESSING REQUIRED SIGH

### AD series #####

PSI_levels_timeseries_AD_wide_processed <- PSI_levels_timeseries_AD_wide

rownames(PSI_levels_timeseries_AD_wide_processed) <- NULL

# necessary to make this column to avoid ambiguous values when doing GGPLOT
PSI_levels_timeseries_AD_wide_processed[, "isoform_ID"] <- paste(PSI_levels_timeseries_AD_wide_processed[, "splicemode"], PSI_levels_timeseries_AD_wide_processed[, "AS_event_ID"], PSI_levels_timeseries_AD_wide_processed[, "isoform_number"], sep = "_")

PSI_levels_timeseries_AD_wide_processed <- PSI_levels_timeseries_AD_wide_processed[, c("Gene", "AS_event_ID", "splicemode","isoform_ID", "MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")]

print(paste("There are", nrow(PSI_levels_timeseries_AD_wide_processed), "isoforms with", p_or_q_value, "<", qpvalue_cutoff, " and dPSI cutoff of", dPSI_cutoff, "for AD series"))

### AD series #####

# PSI_levels_timeseries_AD_wide_processed <- PSI_levels_timeseries_AD_wide
# 
# rownames(PSI_levels_timeseries_AD_wide_processed) <- NULL
# 
# PSI_levels_timeseries_AD_wide_processed[, "isoform_ID"] <- paste(PSI_levels_timeseries_AD_wide_processed[, "splicemode"], PSI_levels_timeseries_AD_wide_processed[, "AS_event_ID"], PSI_levels_timeseries_AD_wide_processed[, "isoform_number"], sep = "_")
# 
# PSI_levels_timeseries_AD_wide_processed <- PSI_levels_timeseries_AD_wide_processed[, c("Gene", "isoform_ID", "MSC", "4h", "1d", "3d", "7d", "14d")]
# 
# print(paste("There are", nrow(PSI_levels_timeseries_AD_wide_processed), "isoforms with specified significance and dPSI cutoff of", dPSI_cutoff, "for AD series"))


```

## construction of a 5x5 SOM

```{r}

som_seed_number <- 7

AD_xdim <- 5
AD_ydim <- 5

number_of_som_clusters <- AD_xdim * AD_ydim

# AD series #####

som_5_by_5_ADseries_table  <- PSI_levels_timeseries_AD_wide_processed[, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")]

som_5_by_5_ADseries_table <- som_5_by_5_ADseries_table %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_ADseries <- som(som_5_by_5_ADseries_table, grid = somgrid(xdim = AD_xdim, ydim = AD_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_ADseries <- cbind(PSI_levels_timeseries_AD_wide_processed[, c("Gene", "AS_event_ID", "splicemode", "isoform_ID")], som_5_by_5_ADseries_table, cluster = somdata_5_by_5_ADseries[["unit.classif"]])

```

### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# AD series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_ADseries <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_ADseries, id.vars = c("Gene", "AS_event_ID", "splicemode", "isoform_ID", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_ADseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_ADseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_ADseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_ADseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_ADseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_ADseries$cluster_minus_1 %/% 5


```

### THE GGPLOT

all the genes

```{r}

# AD series

ggplot(long_table_of_final_SOM_summary_5_by_5_ADseries, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(AD_xdim, "x", AD_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "isoforms' PSI values during AD diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_ADseries, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# GENE ONTOLOGY

## anysig

use gene ontology to analyse all the genes which had at least one differential splicing event over all timepoint comparisons

### p value and FDR (q value) cutoff filtering

In this step: we will use the wide_table_of_all_splicemodes_with_na and filter it for isoforms with least one qvalue < 0.01 and dPSI > 0.2

```{r}

# AD SERIES

## filtering the table to include only AD values

wide_table_of_all_splicemodes_with_na_ADseries <- wide_table_all_splicemodes_split_with_na 

# [, -grep(colnames(wide_table_of_all_splicemodes_with_na), pattern = "AD")]

## filtering the table for FDR
wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05 <- wide_table_of_all_splicemodes_with_na_ADseries[apply(wide_table_of_all_splicemodes_with_na_ADseries[, grep(colnames(wide_table_of_all_splicemodes_with_na_ADseries), pattern = p_or_q_value)], 1, function(x){any(x %>% as.numeric < qpvalue_cutoff)}) == TRUE, ]

## filtering the table for dpsi
wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05 <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05[apply(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05[, grep(colnames(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05), pattern = "deltaPSI")], 1, function(x){any(abs(x %>% as.numeric) > dPSI_cutoff)}) == TRUE, ]

wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05 <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05[apply(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05[, grep(colnames(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05), pattern = "deltaPSI")], 1, function(x){all(is.na(x))}) == FALSE, ]

rownames(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05) <- NULL

ADseries_qvalue_0.05_GO_genelist <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05$Gene %>% unique

numberofgenes_anysig_ADseries <- ADseries_qvalue_0.05_GO_genelist %>% length

numberofgenes_anysig_ADseries %>% paste(., "unique genes differentially spliced between any two time points during the time course of osteogenic differentiation with FDR <", qpvalue_cutoff) %>% print

```

### running hyperGO in GOstats

#### preparation of GO catalog for the gene background

This gene background shall contain all ensembl protein coding, long noncoding and transcribed TFcomplexs.

```{r}

ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

# # GOTERM
polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "go_id", "namespace_1003"), mart = ensembl_mart) %>% .[.$namespace_1003 != "",]

polyA_RNAseq_GO_background[, "namespace_1003"] <- as.character(polyA_RNAseq_GO_background[, "namespace_1003"])

write.table(x = polyA_RNAseq_GO_background, file = paste(results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

## Create catDB instance (takes a while but needs to be done only once)
# note: you had to save the GO annotation file to disk in the previous steps above
catdb <- makeCATdb(myfile = paste(results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), lib = NULL, org = "", colno = c(2, 1, 3), idconv = NULL)

```

#### hypergeometric test for GO terms

```{r}


# AD series

AD_anysig_GOtest_MF <- GOHyperGAll(catdb = catdb, gocat = "MF", sample = ADseries_qvalue_0.05_GO_genelist, Nannot = 2) %>% GOHyperGAll_benjamini_correction

AD_anysig_GOtest_BP <- GOHyperGAll(catdb = catdb, gocat = "BP", sample = ADseries_qvalue_0.05_GO_genelist, Nannot = 2) %>% GOHyperGAll_benjamini_correction

AD_anysig_GOtest_CC <- GOHyperGAll(catdb = catdb, gocat = "CC", sample = ADseries_qvalue_0.05_GO_genelist, Nannot = 2) %>% GOHyperGAll_benjamini_correction

AD_anysig_GOtest_MF %>% head(n = 15L) %>% print
AD_anysig_GOtest_BP %>% head(n = 15L) %>% print
AD_anysig_GOtest_CC %>% head(n = 15L) %>% print

# filter out the top ten most significant GO terms for each node

AD_anysig_GOtest_MF_topten <- AD_anysig_GOtest_MF[order(AD_anysig_GOtest_MF$Padj, decreasing = FALSE), ] %>% head(n = 30)
AD_anysig_GOtest_BP_topten <- AD_anysig_GOtest_BP[order(AD_anysig_GOtest_BP$Padj, decreasing = FALSE), ] %>% head(n = 30)
AD_anysig_GOtest_CC_topten <- AD_anysig_GOtest_CC[order(AD_anysig_GOtest_CC$Padj, decreasing = FALSE), ] %>% head(n = 30)

# table with only the top ten most significant GO terms

AD_anysig_GOtest_all_topten <- bind_rows(AD_anysig_GOtest_MF_topten, AD_anysig_GOtest_BP_topten, AD_anysig_GOtest_CC_topten)

AD_anysig_GOtest_all_topten <- type_convert(AD_anysig_GOtest_all_topten)

```

#### bar graph of GO terms

```{r}

# AD series

ggplot(AD_anysig_GOtest_all_topten, aes(x = reorder(Term, Padj), y = SampleMatch)) +
  geom_col(aes(fill = log(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(Ont ~ ., scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented GO terms for AD series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_ADseries, "genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries, "_genes_anysig.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries, "_genes_anysig.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 


write.table(x = AD_anysig_GOtest_all_topten, file = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries, "_genes_anysig.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  

```

## Gene ontology of each SOM cluster

### preparation of separate data frames containing genes belonging to each cluster

at the end of this, we will get list_of_AD/ADseries_gene_tables_by_SOM_cluster which are lists containing 25 nested data frames

```{r}

# AD series #####

##  separating the wide SOMs table into a list by cluster

list_of_ADseries_gene_tables_by_SOM_cluster <- list()

for (clusternumber in 1:number_of_som_clusters)
  
{
  
  list_of_ADseries_gene_tables_by_SOM_cluster[[clusternumber]] <- wide_table_of_final_SOM_summary_5_by_5_ADseries %>% dplyr::filter(cluster == clusternumber) %>% dplyr::select(Gene) %>% unique %>% lapply(as.character)
  
}


```

### GO enrichment

1. make a list of 25 nested data frames which are the results of GO term enrichment every cluster

2. sort by increasing adjusted P value

3. filter out the top 10 GO terms each cluster

4. append the cluster number to each data frame

5. Unlist(i.e. bind rows)

6. calculate the facet coordinates for GGPLOT

The result: One 5 x 5 GGPLOT of each GOTERM node(3) for AD and ADseries(2) = 6 plots altogether

```{r}

list_of_ADseries_gene_tables_by_SOM_cluster_flattened <- list_of_ADseries_gene_tables_by_SOM_cluster %>% flatten

names(list_of_ADseries_gene_tables_by_SOM_cluster_flattened) <- 1:number_of_som_clusters

# let's try to do all enrichment at once using purrr

list_of_combinations_of_som_genes_and_GOterms <- cross2(.x = list_of_ADseries_gene_tables_by_SOM_cluster_flattened, .y = list("MF", "BP", "CC"))

# note: each element will be [[1]]: gene set, [[2]]: GO term to query

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables <- purrr::map(.x = list_of_combinations_of_som_genes_and_GOterms, .f = ~GOHyperGAll(catdb = catdb, gocat = .x[[2]], Nannot = 2, sample = .x[[1]]) %>% GOHyperGAll_benjamini_correction)

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map2(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten, .y = 1:number_of_som_clusters %>% rep(., times = 3) %>% as.list, .f = ~cbind(.x, "cluster" = .y) %>% as_tibble)

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2 <- list(
  "MF" = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten[1:number_of_som_clusters] %>% purrr::reduce(bind_rows), 
  "BP" = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten[(number_of_som_clusters + 1):(number_of_som_clusters*2)] %>% purrr::reduce(bind_rows),
  "CC" = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten[((2*number_of_som_clusters) + 1):(number_of_som_clusters*3)] %>% purrr::reduce(bind_rows)) %>% purrr::map(~type_convert(.x))

# cheeky ggplot

purrr::map2(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented", .y, "GO terms for each cluster in AD series")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~write.table(x = .x, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Gene Ontology for the isoforms/genes with highest PSIs at every time point

Plan: 

1. for each AD/AD series, for each time point, filter separately for the isoforms with the top ... 10%? (depends on total no. of isoforms) PSI
2. Generate all 3 GO nodes for each timepoint
3. Append timepoint to their respective GO output tables
4. Bind rows for a total of three massive tables (one for each GO node)
5. GGPLOT

#### creation of lists of NORMALISED(SCALED) PSI values of isoforms per time point

```{r}

# AD series ###

ADseries_timepoints <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")

list_of_scaled_PSI_ADseries <- wide_table_of_final_SOM_summary_5_by_5_ADseries[, ADseries_timepoints] %>% as.list

list_of_scaled_PSI_ADseries <- purrr::map(.x = list_of_scaled_PSI_ADseries, .f = ~cbind(.x, Gene = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries[, "Gene"])) %>% cbind(., AS_event_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries[, "AS_event_ID"])) %>% cbind(., isoform_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries[, "isoform_ID"])) %>% cbind(splicemode = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries[, "splicemode"])))

# AD series ###

# ADseries_timepoints <- c("MSC", "4h", "1d", "3d", "7d", "14d")
# 
# list_of_scaled_PSI_ADseries <- wide_table_of_final_SOM_summary_5_by_5_ADseries[, ADseries_timepoints] %>% as.list
# 
# list_of_scaled_PSI_ADseries <- purrr::map(.x = list_of_scaled_PSI_ADseries, .f = ~cbind(.x, Gene = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries[, "Gene"])))


```

#### filtering for top 10% of isoforms with highest inclusion level

```{r}

high_scaledPSIcutoff <- 0.1

list_of_highest_PSI_isoforms_per_timepoint_ADseries <- purrr::map(.x = list_of_scaled_PSI_ADseries, .f = ~.x[order(.x[, 1], decreasing = TRUE), ])
list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries, .f = ~head(.x, n = floor(nrow(.x) * high_scaledPSIcutoff)))
list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID, .f = ~unique(.x[, "Gene"]))


# list_of_highest_PSI_isoforms_per_timepoint_ADseries <- purrr::map(.x = list_of_scaled_PSI_ADseries, .f = ~.x[order(.x[, 1], decreasing = TRUE), ])
# list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries, .f = ~head(.x, n = floor(nrow(.x) * high_scaledPSIcutoff)))
# list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~unique(.x[, "Gene"]))

```

#### filtering for top 10% of isoforms with LOWEST inclusion level

```{r}

low_scaledPSIcutoff <- 0.1

list_of_lowest_PSI_isoforms_per_timepoint_ADseries <- purrr::map(.x = list_of_scaled_PSI_ADseries, .f = ~.x[order(.x[, 1], decreasing = FALSE), ])
list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries, .f = ~head(.x, n = floor(nrow(.x) * low_scaledPSIcutoff)))
list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID, .f = ~unique(.x[, "Gene"]))


# list_of_lowest_PSI_isoforms_per_timepoint_ADseries <- purrr::map(.x = list_of_scaled_PSI_ADseries, .f = ~.x[order(.x[, 1], decreasing = FALSE), ])
# list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries, .f = ~head(.x, n = floor(nrow(.x) * low_scaledPSIcutoff)))
# list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~unique(.x[, "Gene"]))

```

#### GENE ONTOLOGY

```{r}

# AD series #####

# MF highestPSI

list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_MF_ADseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_MF_ADseries <- type_convert(wide_table_of_timepointwise_highestPSI_results_MF_ADseries)

# BP highestPSI

list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_BP_ADseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_BP_ADseries <- type_convert(wide_table_of_timepointwise_highestPSI_results_BP_ADseries)

# CC highestPSI

list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_CC_ADseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_CC_ADseries <- type_convert(wide_table_of_timepointwise_highestPSI_results_CC_ADseries)

# MF lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_MF_ADseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_MF_ADseries <- type_convert(wide_table_of_timepointwise_lowestPSI_results_MF_ADseries)

# BP lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_BP_ADseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_BP_ADseries <- type_convert(wide_table_of_timepointwise_lowestPSI_results_BP_ADseries)

# CC lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_CC_ADseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_CC_ADseries <- type_convert(wide_table_of_timepointwise_lowestPSI_results_CC_ADseries)


#  highestPSI

wide_tables_of_timepointwise_highestPSI_results <- c("wide_table_of_timepointwise_highestPSI_results_MF_ADseries", "wide_table_of_timepointwise_highestPSI_results_BP_ADseries", "wide_table_of_timepointwise_highestPSI_results_CC_ADseries")

# , "wide_table_of_timepointwise_highestPSI_results_MF_ADseries", "wide_table_of_timepointwise_highestPSI_results_BP_ADseries", "wide_table_of_timepointwise_highestPSI_results_CC_ADseries"

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_highestPSI_results[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_highestPSI_results[i], "_processed", sep = ""), value = temp)
  
}

# lowestPSI

wide_tables_of_timepointwise_lowestPSI_results <- c("wide_table_of_timepointwise_lowestPSI_results_MF_ADseries", "wide_table_of_timepointwise_lowestPSI_results_BP_ADseries", "wide_table_of_timepointwise_lowestPSI_results_CC_ADseries")

# , "wide_table_of_timepointwise_highestPSI_results_MF_ADseries", "wide_table_of_timepointwise_highestPSI_results_BP_ADseries", "wide_table_of_timepointwise_highestPSI_results_CC_ADseries"

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_lowestPSI_results[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_lowestPSI_results[i], "_processed", sep = ""), value = temp)
  
}

```

#### GGPLOT

```{r}

# AD series ######

# MF highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_MF_ADseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_MF_ADseries_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_BP_ADseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_BP_ADseries_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_CC_ADseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_CC_ADseries_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# MF lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# protein family enrichment (EXPERIMENTAL)

goal: to conduct hypergeometric tests of overrepresentation for gene subsets in protein families

## generating the gene background for PFAM protein families

```{r}

ensembl_mart = useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# PROTEINFAMILY
polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_TFcomplex", "transcribed_unitary_TFcomplex", "transcribed_unprocessed_TFcomplex", "translated_processed_TFcomplex"), attributes = c("external_gene_name", "pfam"), mart = ensembl_mart) %>% .[.$pfam != "",]

# obtain description(definition, DE) for each PFAM ID

PFAM_all_descriptions <- as.data.frame(PFAMDE[mappedkeys(PFAMDE)]) %>% setNames(., c("pfam", "family_description"))

polyA_RNAseq_GO_background <- dplyr::left_join(polyA_RNAseq_GO_background, PFAM_all_descriptions, by = "pfam")

polyA_RNAseq_GO_background[, "family_description"] <- as.character(polyA_RNAseq_GO_background[, "family_description"])

write.table(x = polyA_RNAseq_GO_background, file = paste(results_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

# create list of gene UNIVERSE

reference_geneset <- polyA_RNAseq_GO_background$external_gene_name

# create list containing collections of genes under their according family descriptions

polyA_RNAseq_GO_background_2 <- polyA_RNAseq_GO_background

polyA_RNAseq_GO_background_2 <- polyA_RNAseq_GO_background_2[, names(polyA_RNAseq_GO_background_2) != "pfam"]

list_of_pfam_descriptions <- polyA_RNAseq_GO_background_2$family_description %>% unique %>% as.list

list_of_pfam_gene_family_categories <- purrr::map(.x = list_of_pfam_descriptions, .f = ~as.list(polyA_RNAseq_GO_background[polyA_RNAseq_GO_background$family_description == .x, "external_gene_name"]))

names(list_of_pfam_gene_family_categories) <- list_of_pfam_descriptions

list_of_pfam_gene_family_categories <- list_of_pfam_gene_family_categories %>% purrr::map(~unlist(.x))

```

## ENRICHMENT TEST

### anysig

hypergeometric test, filtering for top 30 overrepresented families
```{r}

# AD

# AD_anysig_family_enrichment <- enrichment(genes = ADseries_qvalue_0.05_GO_genelist, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction; rownames(AD_anysig_family_enrichment) <- NULL
# 
# AD_anysig_family_enrichment %>% head(n = 15L) %>% print

# table with only the top ten most significant enrichments

# AD_anysig_family_enrichment_topten <- AD_anysig_family_enrichment[order(AD_anysig_family_enrichment$padj, decreasing = FALSE), ] %>% head(n = 10)
# 
# AD_anysig_family_enrichment_topten <- type_convert(AD_anysig_family_enrichment_topten)

# AD

AD_anysig_family_enrichment <- enrichment(genes = ADseries_qvalue_0.05_GO_genelist, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], ADseries_qvalue_0.05_GO_genelist) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert; rownames(AD_anysig_family_enrichment) <- NULL

# AD_anysig_family_enrichment %>% head(n = 30L) %>% print

# table with only the top ten most significant enrichments

AD_anysig_family_enrichment_topten <- AD_anysig_family_enrichment[order(AD_anysig_family_enrichment$padj, decreasing = FALSE), ] %>% head(n = 30)

AD_anysig_family_enrichment_topten <- type_convert(AD_anysig_family_enrichment_topten)

```

bar graph of GO terms
```{r}

# AD series

# ggplot(AD_anysig_family_enrichment_topten, aes(x = reorder(TermID, padj), y = genes)) +
#   geom_col(aes(fill = log(padj))) +
#   scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
#   # facet_grid(~ Ont, scales = "free") +
#   ggtitle(paste("Top 10 significantly over-represented families for AD series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value,"encompassing", numberofgenes_anysig_ADseries, "genes")) +
#   xlab("Family description (PFAM)") +
#   ylab("Number of genes captured in family") +
#   # coord_cartesian(ylim = c(0, 20)) +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
#  ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, "_", numberofgenes_anysig_ADseries, "_genes_anysig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
#  ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, "_", numberofgenes_anysig_ADseries, "_genes_anysig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# AD series

ggplot(AD_anysig_family_enrichment_topten, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  # facet_grid(~ Ont, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for AD series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_ADseries, "genes")) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries, "_genes_anysig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries, "_genes_anysig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = AD_anysig_family_enrichment_topten, file = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries, "_genes_anysig.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

### anytimepoint

#### anysig, highest PSI

hypergeometric test, filtering for top 10 overrepresented families
```{r}

# AD ###

list_of_highest_PSI_per_timepoint_familyenrichment_ADseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_familyenrichment_ADseries, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_families_ADseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_topten, .f = bind_rows)

wide_table_of_timepointwise_highestPSI_families_ADseries <- type_convert(wide_table_of_timepointwise_highestPSI_families_ADseries)

wide_table_of_timepointwise_highestPSI_families_ADseries <- arrange(transform(wide_table_of_timepointwise_highestPSI_families_ADseries, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_families_ADseries$timepoint))), timepoint)

# AD ###

# list_of_highest_PSI_per_timepoint_familyenrichment_ADseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)
# 
# list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_familyenrichment_ADseries, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))
                       
# un-nest by binding rows
# wide_table_of_timepointwise_highestPSI_families_ADseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_topten, .f = bind_rows)
# 
# wide_table_of_timepointwise_highestPSI_families_ADseries <- type_convert(wide_table_of_timepointwise_highestPSI_families_ADseries)
# 
# wide_table_of_timepointwise_highestPSI_families_ADseries <- arrange(transform(wide_table_of_timepointwise_highestPSI_families_ADseries, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_families_ADseries$timepoint))), timepoint)

```

#### anysig, lowest PSI

hypergeometric test, filtering for top 10 overrepresented families
```{r}

# AD ###

list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_families_ADseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_topten, .f = bind_rows)

wide_table_of_timepointwise_lowestPSI_families_ADseries <- type_convert(wide_table_of_timepointwise_lowestPSI_families_ADseries)

wide_table_of_timepointwise_lowestPSI_families_ADseries <- arrange(transform(wide_table_of_timepointwise_lowestPSI_families_ADseries, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_families_ADseries$timepoint))), timepoint)

# AD ###

# list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)
# 
# list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))     

# un-nest by binding rows
# wide_table_of_timepointwise_lowestPSI_families_ADseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_topten, .f = bind_rows)
# 
# wide_table_of_timepointwise_lowestPSI_families_ADseries <- type_convert(wide_table_of_timepointwise_lowestPSI_families_ADseries)
# 
# wide_table_of_timepointwise_lowestPSI_families_ADseries <- arrange(transform(wide_table_of_timepointwise_lowestPSI_families_ADseries, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_families_ADseries$timepoint))), timepoint)

```

bar graph of GO terms

```{r}

# AD series ######

# highest PSI

ggplot(wide_table_of_timepointwise_highestPSI_families_ADseries, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_families_ADseries, file = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# lowest PSI

ggplot(wide_table_of_timepointwise_lowestPSI_families_ADseries, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_families_ADseries, file = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### family enrichment of each cluster

```{r}

# AD ###

list_of_familyenrichment_by_SOM_cluster_ADseries <- purrr::map(.x = list_of_ADseries_gene_tables_by_SOM_cluster_flattened, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_familyenrichment_by_SOM_cluster_ADseries) <- 1:number_of_som_clusters

list_of_familyenrichment_by_SOM_cluster_ADseries_topten <- purrr::map2(.x = list_of_familyenrichment_by_SOM_cluster_ADseries, .y = 1:number_of_som_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_familyenrichment_by_SOM_cluster_ADseries_topten <- purrr::reduce(.x = list_of_familyenrichment_by_SOM_cluster_ADseries_topten, .f = bind_rows) %>% type_convert %>% cbind(., cluster_minus_1 = .$cluster - 1) %>% cbind(., remainder_facet.x = .$cluster_minus_1 %% 5) %>% cbind(., quotient_facet.y = .$cluster_minus_1 %/% 5)


```

GGPLOT

```{r}

ggplot(wide_table_of_familyenrichment_by_SOM_cluster_ADseries_topten, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle("Top 10 significantly over-represented PFAM families for each cluster in AD series") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("PFAM family") +
  ylab("Number of genes enriched in PFAM family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = wide_table_of_familyenrichment_by_SOM_cluster_ADseries_topten, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# MAPPING/ANNOTATING DIFFERENTIALLY INCLUDED TRANSCRIPT REGIONS WITH PROTEIN DOMAIN/MOTIF/STRUCTURE INFORMATION

## import GTF and process it into a nice table containing only character and numeric types

```{r}

# IMPORT GTF ANNOTATION OF TRANSCRIPT/EXON/PROTEIN CODING REGIONS ETC...

library(rtracklayer)

gtf_table <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

gtf_table <- dplyr::select(gtf_table, -source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(gtf_table) <- c("chr", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

gtf_table <- gtf_table %>% mutate_if(is.factor, as.character) %>% as_tibble

dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# 
# testuniprotID <- getBM(filters = "ensembl_peptide_id", values = SNF2_enriched_isoforms_consequence$overlapping_annotated_regions$ATRX$protein_id %>% na.omit %>% unique, attributes = "uniprotsptrembl", mart = ensembl_mart) %>% setNames("uniprotkb_entry")
# 
# test2 <- semi_join(dbPTM_allhuman_annotations, testuniprotID, by = "uniprotkb_entry")

```

## transcript and domain analyses! :)

```{r}

# select mirror

ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

# sometimes, JUM seems to call novel splice junctions that are DIRECTLY adjacent to annotated regions but do not overlap. if we expand the genomic coordinates by 1 on each side, we can capture these regions too.

enable_greedy_genome_coordinates <- function(tibble_chr_strand_start_end) {
  
  tibble_chr_strand_start_end[, "start"] <- tibble_chr_strand_start_end$start - 1
  tibble_chr_strand_start_end[, "end"] <- tibble_chr_strand_start_end$end + 1
  
  return(tibble_chr_strand_start_end)
  
}

# list_of_highest_PSI_isoforms_per_timepoint_ADseries_lookuptable <- list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID %>% purrr::map(as_tibble)

# all kinases
kinase_isoforms <- dplyr::semi_join(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% as_tibble
  
kinase_isoforms_chr_strand_start_end <- kinase_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

kinase_isoforms_consequence <- tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain(kinase_isoforms_chr_strand_start_end, gtf_table, ensembl_mart)

kinase_isoforms_consequence_simplified <- kinase_isoforms_consequence %>% simplify_consequence_table(., ensembl_mart)

# all RBPs

RBP_isoforms <- tibble(Gene = c("SRSF2", "SRSF3", "MBNL2", "HNRNPDL", "SNRPA1", "SRRM2", "SRPK2", "RBM41")) %>% dplyr::semi_join(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, ., by = "Gene") %>% as_tibble %>% mutate_if(is.factor, as.character)

RBP_isoforms_chr_strand_start_end <- RBP_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

RBP_isoforms_consequence <- tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain(RBP_isoforms_chr_strand_start_end[3, ], gtf_table, ensembl_mart)

RBP_isoforms_consequence_simplified <- RBP_isoforms_consequence %>% simplify_consequence_table(., ensembl_mart)

# all major regulator isoforms

major_regulator_isoforms <- tibble(Gene = c("RUNX2", "MACF1", "POLB", "DDX5", "DROSHA", "FBXO5", "FBXL19", "FBXW2", "NFYA", "ATXN2L", "ZBTB7A", "ABI1", "ACTR5", "TARID")) %>% dplyr::semi_join(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, ., by = "Gene") %>% as_tibble %>% mutate_if(is.factor, as.character)

major_regulator_isoforms_chr_strand_start_end <- major_regulator_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

major_regulator_isoforms_consequence <- tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain(major_regulator_isoforms_chr_strand_start_end, gtf_table, ensembl_mart)

major_regulator_isoforms_consequence_simplified <- major_regulator_isoforms_consequence %>% simplify_consequence_table(., ensembl_mart)

# phenotype isoforms

phenotype_isoforms <- tibble(Gene = c("ATP2B4", "ATP2B1", "LIME1", "CACNA2D1", "VPS13D", "WNK1", "ILK", "GOLGA4", "GOLGB1", "ITGAE")) %>% dplyr::semi_join(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, ., by = "Gene") %>% as_tibble %>% mutate_if(is.factor, as.character)

phenotype_isoforms_chr_strand_start_end <- phenotype_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

phenotype_isoforms_consequence <- tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain(phenotype_isoforms_chr_strand_start_end, gtf_table, ensembl_mart)

phenotype_isoforms_consequence_simplified <- phenotype_isoforms_consequence %>% simplify_consequence_table(., ensembl_mart)


```

# REPEAT OF ANAYSES WITH PLAUSIBLE AS EVENTS ONLY

## filtering out all the implausible AS events

```{r}

# function to fetch maximum AA length of each protein coding gene. AS regions cant be longer than this. very difficult to filter. in my experience, most exons are at most 200 nt but ok
filtering_chr_strand_start_end_tibble_for_plausible_AS_events <- function(tibble_chr_strand_start_end) {
  
  a <- getBM(filters = "external_gene_name", values = tibble_chr_strand_start_end$Gene, attributes = c("external_gene_name", "cds_length"), mart = ensembl_mart)
b <- a %>% group_by(external_gene_name) %>% na.omit %>% filter(cds_length == max(cds_length))
colnames(b) <- c("Gene", "cds_length")
c <- dplyr::left_join(tibble_chr_strand_start_end, b, by = "Gene")
d <- c[-which(c$width >= c$cds_length), ]
# retained introns and entire composite structures can be long. the other 4 have no excuse. the longest exon in existence is 11555 bp long. but come on.
e <- d[-which(d$width > 10000 & (d$splicemode == "A3SS_events" | d$splicemode == "A5SS_events" | d$splicemode == "cassette_exon_events" | d$splicemode == "MXE_events")), ]
# e contains the final list of isoforms which have plausible AS length.
print(paste(nrow(e), "unique genes with plausible AS length after filtering"))

return(e)
  
}

## END filtering_chr_strand_start_end_tibble_for_plausible_AS_events

```

## repeat GO analysis with anysig with na

preprocessing 

```{r}

# filter for plausible anysig table

all_filtered_isoforms <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05 %>% as_tibble %>% mutate_if(is.factor, as.character)

all_filtered_isoforms_chr_strand_start_end <- all_filtered_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

all_filtered_isoforms_chr_strand_start_end_AS_plausible <- all_filtered_isoforms_chr_strand_start_end %>% filtering_chr_strand_start_end_tibble_for_plausible_AS_events

wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible <- dplyr::semi_join(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05, all_filtered_isoforms_chr_strand_start_end_AS_plausible, by = "Gene")

numberofgenes_anysig_ADseries_AS_plausible <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique %>% length

print(paste("There are", numberofgenes_anysig_ADseries_AS_plausible, "genes anysig with plausible AS length"))

# GO analysis, AD series

AD_anysig_GOtest_MF_AS_plausible <- GOHyperGAll(catdb = catdb, gocat = "MF", sample = wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, Nannot = 2) %>% GOHyperGAll_benjamini_correction

AD_anysig_GOtest_BP_AS_plausible <- GOHyperGAll(catdb = catdb, gocat = "BP", sample = wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, Nannot = 2) %>% GOHyperGAll_benjamini_correction

AD_anysig_GOtest_CC_AS_plausible <- GOHyperGAll(catdb = catdb, gocat = "CC", sample = wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, Nannot = 2) %>% GOHyperGAll_benjamini_correction

AD_anysig_GOtest_MF_AS_plausible %>% head(n = 15L) %>% print
AD_anysig_GOtest_BP_AS_plausible %>% head(n = 15L) %>% print
AD_anysig_GOtest_CC_AS_plausible %>% head(n = 15L) %>% print

# filter out the top ten most significant GO terms for each node

AD_anysig_GOtest_MF_topten_AS_plausible <- AD_anysig_GOtest_MF_AS_plausible[order(AD_anysig_GOtest_MF_AS_plausible$Padj, decreasing = FALSE), ] %>% head(n = 30)
AD_anysig_GOtest_BP_topten_AS_plausible <- AD_anysig_GOtest_BP_AS_plausible[order(AD_anysig_GOtest_BP_AS_plausible$Padj, decreasing = FALSE), ] %>% head(n = 30)
AD_anysig_GOtest_CC_topten_AS_plausible <- AD_anysig_GOtest_CC_AS_plausible[order(AD_anysig_GOtest_CC_AS_plausible$Padj, decreasing = FALSE), ] %>% head(n = 30)

# table with only the top ten most significant GO terms

AD_anysig_GOtest_all_topten_AS_plausible <- bind_rows(AD_anysig_GOtest_MF_topten_AS_plausible, AD_anysig_GOtest_BP_topten_AS_plausible, AD_anysig_GOtest_CC_topten_AS_plausible)

AD_anysig_GOtest_all_topten_AS_plausible <- type_convert(AD_anysig_GOtest_all_topten_AS_plausible)

```

GGPLOT

```{r}

# AD series

ggplot(AD_anysig_GOtest_all_topten_AS_plausible, aes(x = reorder(Term, Padj), y = SampleMatch)) +
  geom_col(aes(fill = log(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(Ont ~ ., scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented GO terms for AD series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_ADseries_AS_plausible, " PLAUSIBLE genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries_AS_plausible, "_genes_anysig_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries_AS_plausible, "_genes_anysig_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 


write.table(x = AD_anysig_GOtest_all_topten_AS_plausible, file = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries_AS_plausible, "_genes_anysig_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## repeat family enrichment using anysig

preprocessing 

```{r}

AD_anysig_family_enrichment_AS_plausible <- enrichment(genes = wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert

rownames(AD_anysig_family_enrichment_AS_plausible) <- NULL

# table with only the top ten most significant enrichments

AD_anysig_family_enrichment_topten_AS_plausible <- AD_anysig_family_enrichment_AS_plausible[order(AD_anysig_family_enrichment_AS_plausible$padj, decreasing = FALSE), ] %>% head(n = 30)

AD_anysig_family_enrichment_topten_AS_plausible <- type_convert(AD_anysig_family_enrichment_topten_AS_plausible)

```

bar graph of GO terms

```{r}

# AD series

ggplot(AD_anysig_family_enrichment_topten_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  # facet_grid(~ Ont, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for AD series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_ADseries_AS_plausible, "PLAUSIBLE genes")) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries_AS_plausible, "_genes_anysig_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries_AS_plausible, "_genes_anysig_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = AD_anysig_family_enrichment_topten_AS_plausible, file = paste(results_directory_figures, "Top 10 significantly over-represented families for AD series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_ADseries_AS_plausible, "_genes_anysig_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

## re-cluster the SOM using plausible genes only

### plausible filtering

```{r}

# generate table of plausible SOM isoforms that feeds into kohonen

all_SOM_isoforms <- PSI_levels_timeseries_AD_wide_processed %>% as_tibble %>% mutate_if(is.factor, as.character)

all_SOM_isoforms_chr_strand_start_end <- all_SOM_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

all_SOM_isoforms_chr_strand_start_end_AS_plausible <- all_SOM_isoforms_chr_strand_start_end %>% filtering_chr_strand_start_end_tibble_for_plausible_AS_events

PSI_levels_timeseries_AD_wide_processed_AS_plausible <- dplyr::semi_join(PSI_levels_timeseries_AD_wide_processed, all_SOM_isoforms_chr_strand_start_end_AS_plausible, by = "Gene")

```

### re-execution of kohonen

```{r}

som_seed_number <- 7

AD_xdim <- 5
AD_ydim <- 5

number_of_som_clusters <- AD_xdim * AD_ydim

# AD_xdim <- 5
# AD_ydim <- 5

# AD series #####

som_5_by_5_ADseries_table_AS_plausible  <- PSI_levels_timeseries_AD_wide_processed_AS_plausible[, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")]

som_5_by_5_ADseries_table_AS_plausible <- som_5_by_5_ADseries_table_AS_plausible %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_ADseries_AS_plausible <- som(som_5_by_5_ADseries_table_AS_plausible, grid = somgrid(xdim = AD_xdim, ydim = AD_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible <- cbind(PSI_levels_timeseries_AD_wide_processed_AS_plausible[, c("Gene", "AS_event_ID", "splicemode", "isoform_ID")], som_5_by_5_ADseries_table_AS_plausible, cluster = somdata_5_by_5_ADseries_AS_plausible[["unit.classif"]])

```

### convert the som table to a long form interprable by ggplot

```{r}

# AD series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, id.vars = c("Gene", "AS_event_ID", "splicemode", "isoform_ID", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible$cluster - 1

long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible$cluster_minus_1 %/% 5

```

### ggplot of SOM

```{r}

ggplot(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(AD_xdim, "x", AD_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "PLAUSIBLE isoforms' PSI values during AD diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

kinases only


```{r}

vector_protein_kinases <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "protein kinase activity"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(AD_xdim, "x", AD_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID), "PLAUSIBLE KINASE isoforms' PSI values during AD diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_kinases.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_kinases.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_kinases.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```


speckles only

```{r}

vector_nuclear_speck_proteins <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "nuclear speck"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_nuclear_speck_proteins, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(AD_xdim, "x", AD_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "PLAUSIBLE nuclear speck isoforms' PSI values during AD diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_nuclear_speck_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_nuclear_speck_proteins.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_nuclear_speck_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_nuclear_speck_proteins.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_nuclear_speck_proteins.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

transcription factor complex/interactors only

```{r}

vector_transcription_factor_complex_proteins <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "transcription factor complex"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(AD_xdim, "x", AD_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "PLAUSIBLE transcription factor complex isoforms' PSI values during AD diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_transcription_factor_complex_proteins.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_transcription_factor_complex_proteins.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene"), file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_transcription_factor_complex_proteins.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

chromatin remodellers only

```{r}

vector_chromatin_remodeling_proteins <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "chromatin remodeling"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(AD_xdim, "x", AD_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "PLAUSIBLE chromatin remodellers isoforms' PSI values during AD diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_chromatin_remodeling_proteins.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_chromatin_remodeling_proteins.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_chromatin_remodeling_proteins.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## repeat cluster-wise enrichment

### GO term

preprocessing

```{r}

list_of_ADseries_gene_tables_by_SOM_cluster_AS_plausible <- list()

for (clusternumber in 1:number_of_som_clusters)
  
{
  
  list_of_ADseries_gene_tables_by_SOM_cluster_AS_plausible[[clusternumber]] <- wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible %>% dplyr::filter(cluster == clusternumber) %>% dplyr::select(Gene) %>% unique %>% lapply(as.character)
  
}

# AD series #####

list_of_ADseries_gene_tables_by_SOM_cluster_flattened_AS_plausible <- list_of_ADseries_gene_tables_by_SOM_cluster_AS_plausible %>% flatten

# let's try to do all enrichment at once using purrr

list_of_combinations_of_som_genes_and_GOterms_AS_plausible <- cross2(.x = list_of_ADseries_gene_tables_by_SOM_cluster_flattened_AS_plausible, .y = list("MF", "BP", "CC"))

# note: each element will be [[1]]: gene set, [[2]]: GO term to query

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible <- purrr::map(.x = list_of_combinations_of_som_genes_and_GOterms_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = .x[[2]], Nannot = 2, sample = .x[[1]]) %>% GOHyperGAll_benjamini_correction)

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten <- purrr::map(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten <- purrr::map2(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten, .y = 1:number_of_som_clusters %>% rep(., times = 3) %>% as.list, .f = ~cbind(.x, "cluster" = .y) %>% as_tibble)

list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2 <- list(
  "MF" = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten[1:number_of_som_clusters] %>% purrr::reduce(bind_rows), 
  "BP" = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten[(number_of_som_clusters + 1):(number_of_som_clusters*2)] %>% purrr::reduce(bind_rows),
  "CC" = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten[((2*number_of_som_clusters) + 1):(number_of_som_clusters*3)] %>% purrr::reduce(bind_rows)) %>% purrr::map(~type_convert(.x))

# cheeky ggplot

purrr::map2(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2, .y = names(list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2), .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented", .y, "GO terms for each cluster in AD series")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2, .y = names(list_of_ADseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2), .f = ~write.table(x = .x, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### family enrichment

preprocessing

```{r}

list_of_familyenrichment_by_SOM_cluster_ADseries_AS_plausible <- purrr::map(.x = list_of_ADseries_gene_tables_by_SOM_cluster_flattened_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_familyenrichment_by_SOM_cluster_ADseries_AS_plausible) <- 1:number_of_som_clusters

list_of_familyenrichment_by_SOM_cluster_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_familyenrichment_by_SOM_cluster_ADseries_AS_plausible, .y = 1:number_of_som_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_familyenrichment_by_SOM_cluster_ADseries_topten_AS_plausible <- purrr::reduce(.x = list_of_familyenrichment_by_SOM_cluster_ADseries_topten_AS_plausible, .f = bind_rows) %>% type_convert %>% cbind(., cluster_minus_1 = .$cluster - 1) %>% cbind(., remainder_facet.x = .$cluster_minus_1 %% 5) %>% cbind(., quotient_facet.y = .$cluster_minus_1 %/% 5)


```

GGPLOT

```{r}

ggplot(wide_table_of_familyenrichment_by_SOM_cluster_ADseries_topten_AS_plausible, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle("Top 10 significantly over-represented PFAM families for each PLAUSIBLE cluster in AD series") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("PFAM family") +
  ylab("Number of genes enriched in PFAM family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = wide_table_of_familyenrichment_by_SOM_cluster_ADseries_topten_AS_plausible, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## repeat timepoint-wise enrichment

generate list with each element as a single time point of the SOM table

```{r}
# AD series ###

list_of_scaled_PSI_ADseries_AS_plausible <- wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, ADseries_timepoints] %>% as.list

list_of_scaled_PSI_ADseries_AS_plausible <- purrr::map(.x = list_of_scaled_PSI_ADseries_AS_plausible, .f = ~cbind(.x, Gene = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "Gene"])) %>% cbind(., AS_event_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "AS_event_ID"])) %>% cbind(., isoform_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "isoform_ID"])) %>% cbind(splicemode = as.character(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible[, "splicemode"])))

```

filtering for top 10% of isoforms with highest inclusion level

```{r}

high_scaledPSIcutoff <- 0.1

list_of_highest_PSI_isoforms_per_timepoint_ADseries_AS_plausible <- purrr::map(.x = list_of_scaled_PSI_ADseries_AS_plausible, .f = ~.x[order(.x[, 1], decreasing = TRUE), ])
list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_AS_plausible, .f = ~head(.x, n = floor(nrow(.x) * high_scaledPSIcutoff)))
list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID_AS_plausible, .f = ~unique(.x[, "Gene"]))

```

filtering for top 10% of isoforms with LOWEST inclusion level

```{r}

low_scaledPSIcutoff <- 0.1

list_of_lowest_PSI_isoforms_per_timepoint_ADseries_AS_plausible <- purrr::map(.x = list_of_scaled_PSI_ADseries_AS_plausible, .f = ~.x[order(.x[, 1], decreasing = FALSE), ])
list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_AS_plausible, .f = ~head(.x, n = floor(nrow(.x) * low_scaledPSIcutoff)))
list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_with_isoformID_AS_plausible, .f = ~unique(.x[, "Gene"]))

```

### GENE ONTOLOGY and family enrichment

GO term processing

```{r}

# AD series #####

# MF highestPSI

list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_MF_ADseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_MF_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_results_MF_ADseries_AS_plausible)

# BP highestPSI

list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_BP_ADseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_BP_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_results_BP_ADseries_AS_plausible)

# CC highestPSI

list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_CC_ADseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_CC_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_results_CC_ADseries_AS_plausible)

# MF lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_ADseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_AS_plausible)

# BP lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_ADseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_AS_plausible)

# CC lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_ADseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_AS_plausible)

# reordering the "timepoint" factor to give correct facet order

#  highestPSI

wide_tables_of_timepointwise_highestPSI_results_AS_plausible <- c("wide_table_of_timepointwise_highestPSI_results_MF_ADseries_AS_plausible", "wide_table_of_timepointwise_highestPSI_results_BP_ADseries_AS_plausible", "wide_table_of_timepointwise_highestPSI_results_CC_ADseries_AS_plausible")

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_highestPSI_results_AS_plausible[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_highestPSI_results_AS_plausible[i], "_processed", sep = ""), value = temp)
  
}

# lowestPSI

wide_tables_of_timepointwise_lowestPSI_results_AS_plausible <- c("wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_AS_plausible", "wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_AS_plausible", "wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_AS_plausible")

# , "wide_table_of_timepointwise_highestPSI_results_MF_ADseries", "wide_table_of_timepointwise_highestPSI_results_BP_ADseries", "wide_table_of_timepointwise_highestPSI_results_CC_ADseries"

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_lowestPSI_results_AS_plausible[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_lowestPSI_results_AS_plausible[i], "_processed", sep = ""), value = temp)
  
}

```

family processing

```{r}

### highest PSI 

list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_AS_plausible, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_familyenrichment_ADseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible)

wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible$timepoint))), timepoint)

### lowest PSI

list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_AS_plausible, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_ADseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible)

wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible$timepoint))), timepoint)

```

### GGPLOT

```{r}

# GO enrichment ######

# MF highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_MF_ADseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_MF_ADseries_AS_plausible_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_BP_ADseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_BP_ADseries_AS_plausible_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_CC_ADseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_CC_ADseries_AS_plausible_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# MF lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_MF_ADseries_AS_plausible_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_BP_ADseries_AS_plausible_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_CC_ADseries_AS_plausible_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# family enrichment ######

# highest PSI

ggplot(wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_families_ADseries_AS_plausible, file = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# lowest PSI

ggplot(wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_families_ADseries_AS_plausible, file = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# ENRICHMENT OF SPLICING FACTORS - didnt work

## Generate table of all the mRNA sequences of all annotated transcripts

- mRNA sequences: UNSPLICED, for,
- Genes: ANYSIG

```{r eval=FALSE, include=FALSE}

anysig_all_mrna_seqs <- getBM(filters = "external_gene_name", values = wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene, attributes = c("external_gene_name", "ensembl_transcript_id", "transcript_exon_intron"), mart = ensembl_mart) %>% as_tibble

```

## generate lists of target genes containing motifs of splicing factors

use regex lmao

```{r eval=FALSE, include=FALSE}

RBM41_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "(A|T)TAC(A|T)TT")), "external_gene_name"] %>% unique

print(nrow(RBM41_binding_motif_containing_genes))

SRSF2_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "AGGAG(A|T)(G|A|T)")), "external_gene_name"] %>% unique

print(nrow(SRSF2_binding_motif_containing_genes))

wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible$Gene %>% unique %>% length %>% print

print("rip")

```

## import PAR-CLiP, RIP-Seq, CLiP-Seq data and match with GTF information

SRSF3

```{r}

clipseq_dir <- "Z:/isoform_usage_project/"

# PARalyzer user manual: https://ohlerlab.mdc-berlin.de/files/duke/PARalyzer/README.txt

# SRSF3_parclip_GSM1826788_rep1_import <- read.delim("Z:/isoform_usage_project/srsf3_parclip_bedfiles_GSE71096/GSM1826788_SRSF3-rep1P_kde_plus3_5deep.tab", header = TRUE, stringsAsFactors = FALSE) %>% as_tibble; SRSF3_parclip_GSM1826788_rep1_import[, "Chromosome"] <- gsub(SRSF3_parclip_GSM1826788_rep1_import$Chromosome, pattern = "chr", replacement = ""); colnames(SRSF3_parclip_GSM1826788_rep1_import) <- c("chr", "strand", "start", "end", "ClusterID", "ClusterSequence", "ReadCount", "ModeLocation", "ModeScore", "ConversionLocationCount", "ConversionEventCount", "NonConversionEventCount")

# SRSF3_parclip_GSM1826788_rep1_annotationbed <- map_genome_coordinate_to_transcriptandprotein(SRSF3_parclip_GSM1826788_rep1_import, mode = "BED_file", targetlevel = "transcript")
# write.table(SRSF3_parclip_GSM1826788_rep1_annotationbed, file = "Z:/isoform_usage_project/srsf3_parclip_bedfiles_GSE71096/SRSF3_parclip_GSM1826788_rep1.annotationbed", sep = "\t", row.names = FALSE, quote = FALSE)

SRSF3_parclip_GSM1826788_rep1_annotationbed <- read.delim(paste(clipseq_dir, "srsf3_parclip_bedfiles_GSE71096/SRSF3_parclip_GSM1826788_rep1.annotationbed", sep = ""), header = TRUE, sep = "\t")

plot(density(SRSF3_parclip_GSM1826788_rep1_annotationbed$ModeScore %>% as.numeric))

# filter PARalyzer's modescore (SNR) for >= 0.9

SRSF3_parclip_GSM1826788_rep1_annotationbed_filtered <- SRSF3_parclip_GSM1826788_rep1_annotationbed[SRSF3_parclip_GSM1826788_rep1_annotationbed$ModeScore %>% as.numeric >= 0.85, ]

SRSF3_parclip_GSM1826788_rep1_uniquegenes <- SRSF3_parclip_GSM1826788_rep1_annotationbed_filtered$annotation_gene_name %>% unique


# SRSF3_parclip_GSM1826788_rep2_import <- read.delim("Z:/isoform_usage_project/srsf3_parclip_bedfiles_GSE71096/GSM1826793_SRSF3-rep2P_kde_plus3_5deep.tab", header = TRUE, stringsAsFactors = FALSE) %>% as_tibble; SRSF3_parclip_GSM1826788_rep2_import[, "Chromosome"] <- gsub(SRSF3_parclip_GSM1826788_rep2_import$Chromosome, pattern = "chr", replacement = ""); colnames(SRSF3_parclip_GSM1826788_rep2_import) <- c("chr", "strand", "start", "end", "ClusterID", "ClusterSequence", "ReadCount", "ModeLocation", "ModeScore", "ConversionLocationCount", "ConversionEventCount", "NonConversionEventCount")

# SRSF3_parclip_GSM1826788_rep2_annotationbed <- map_genome_coordinate_to_transcriptandprotein(SRSF3_parclip_GSM1826788_rep2_import, mode = "BED_file", targetlevel = "transcript")
# write.table(SRSF3_parclip_GSM1826788_rep2_annotationbed, file = "Z:/isoform_usage_project/srsf3_parclip_bedfiles_GSE71096/SRSF3_parclip_GSM1826788_rep2.annotationbed", sep = "\t", row.names = FALSE, quote = FALSE)

SRSF3_parclip_GSM1826788_rep2_annotationbed <- read.delim(paste(clipseq_dir, "srsf3_parclip_bedfiles_GSE71096/SRSF3_parclip_GSM1826788_rep2.annotationbed", sep = ""), header = TRUE, sep = "\t")

plot(density(SRSF3_parclip_GSM1826788_rep2_annotationbed$ModeScore %>% as.numeric))

# filter PARalyzer's modescore (SNR) for >= 0.9

SRSF3_parclip_GSM1826788_rep2_annotationbed_filtered <- SRSF3_parclip_GSM1826788_rep2_annotationbed[SRSF3_parclip_GSM1826788_rep2_annotationbed$ModeScore %>% as.numeric >= 0.85, ]

SRSF3_parclip_GSM1826788_rep2_uniquegenes <- SRSF3_parclip_GSM1826788_rep2_annotationbed_filtered$annotation_gene_name %>% unique

# find intersection between the two replicates

SRSF3_parclip_GSM1826788_targets <- intersect(SRSF3_parclip_GSM1826788_rep1_uniquegenes, SRSF3_parclip_GSM1826788_rep2_uniquegenes)

```

## enrichment of upstream RBPs - clusterwise

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "SRSF3 parclip SRSF3_OE_HeLa GSM1826788 0.8modescorecutoff" = SRSF3_parclip_GSM1826788_targets %>% as.data.frame %>% mutate_if(is.factor, as.character) %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

# look it doesn't make biological sense to enrich for mutant SRSF2 with a P95H cre stuffed in the middle of the coding region
# "SRSF2 HiTS_CLiP HeLa_P95H GSE111900" = read.delim("//VBOXSVR/sharedfolder/isoform_usage_project/SRSF2_hits.clip_GSE111900/srsf2_clip_GSE111900_P95H.txt", header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
# FDR 0.05 just generates the same overlaps as FDR 0.01 so it just falsely dilutes our enrichment
# "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.05FDR" = read.delim("//VBOXSVR/sharedfolder/isoform_usage_project/SRSF2_hits.clip_GSE111900/srsf2_clip_GSE111900_WT_0.05FDR.txt", header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
# this can maaaybe substitute for the CLiP seq data, but i dont know. it works for now.
# "SRSF2 literaturesummary SRSFmutation_trait_loci GSE111900" = read.delim("//VBOXSVR/sharedfolder/isoform_usage_project/SRSF2_hits.clip_GSE111900/SRSF2_literaturesummary_SRSFmutation_trait_loci_GSE111900.txt", header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)


## gene enrichment in each cluster
 
list_of_RBP_target_enrichment_by_SOM_cluster_ADseries_AS_plausible <- purrr::map(.x = list_of_ADseries_gene_tables_by_SOM_cluster_flattened_AS_plausible, .f = ~enrichment(genes = ., reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_RBP_target_enrichment_by_SOM_cluster_ADseries_AS_plausible) <- 1:number_of_som_clusters

list_of_RBP_target_enrichment_by_SOM_cluster_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_RBP_target_enrichment_by_SOM_cluster_ADseries_AS_plausible, .y = 1:number_of_som_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_RBP_target_enrichment_by_SOM_cluster_ADseries_topten_AS_plausible <- purrr::reduce(.x = list_of_RBP_target_enrichment_by_SOM_cluster_ADseries_topten_AS_plausible, .f = bind_rows) %>% type_convert %>% cbind(., cluster_minus_1 = .$cluster - 1) %>% cbind(., remainder_facet.x = .$cluster_minus_1 %% 5) %>% cbind(., quotient_facet.y = .$cluster_minus_1 %/% 5)

## GGPLOT

ggplot(wide_table_of_RBP_target_enrichment_by_SOM_cluster_ADseries_topten_AS_plausible, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(pval))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle("Top 10 significantly over-represented UPSTREAM RBP CANDIDATES for each PLAUSIBLE cluster in AD series") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP with literature reference") +
  ylab("Number of genes enriched amongst RBP target genes") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 60)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_upstreamRBP_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_upstreamRBP_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = wide_table_of_RBP_target_enrichment_by_SOM_cluster_ADseries_topten_AS_plausible, file = paste(results_directory_figures, AD_xdim, "x", AD_ydim, "_SOM_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_PSI_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_upstreamRBP_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)


```

## enrichment of upstream RBPs - timepointwise

```{r}


### highest PSI 

list_of_highest_PSI_per_timepoint_RBPenrichment_ADseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_highest_PSI_per_timepoint_RBPenrichment_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_RBPenrichment_ADseries_AS_plausible, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_RBPenrichment_ADseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible)

wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible$timepoint))), timepoint)

### lowest PSI

list_of_lowest_PSI_per_timepoint_RBPenrichment_ADseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_lowest_PSI_per_timepoint_RBPenrichment_ADseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_RBPenrichment_ADseries_AS_plausible, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_ADseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_RBPenrichment_ADseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible)

wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible$timepoint))), timepoint)

## GGPLOT

# highest PSI

ggplot(wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP") +
  ylab("Number of gene targets in cluster") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_upstreamRBP_ADseries_AS_plausible, file = paste(results_directory_figures, "UpstreamRBPs_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# lowest PSI

ggplot(wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each AD timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP") +
  ylab("Number of gene targets in cluster") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_upstreamRBP_ADseries_AS_plausible, file = paste(results_directory_figures, "UpstreamRBPs_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_AD_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)


```


# QUALITY CHECK

## create quality check results directory

```{r}

qualitycheck_results_dir <-  paste(results_dir, "qualitycheck/", sep = "")

if(! dir.exists(qualitycheck_results_dir) ) {
     dir.create(qualitycheck_results_dir, recursive = TRUE)}

JUM_diff_dir <- "Y:/PGNEXUS_ADseries/analysis_JUM/run_1_PGNEXUS_ADseries_pvalue1/results/JUM_diff/"

```

## check for stringency of timepointwise top/bottom cutoff

```{r}

for (ADtimepoint in ADseries_timepoints) {
  
  ggplot(list_of_highest_PSI_isoforms_per_timepoint_ADseries[[ADtimepoint]] %>% as.data.frame %>% mutate_if(is.factor, as.character) %>% type_convert, aes(x = .x)) + 
  geom_density() +
  ggtitle(paste("density_distribution_of_scaled_PSI_for_", ADtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  xlab("scaled PSI") +
  ylab("proportion of isoforms") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "density_distribution_of_scaled_PSI_for_", ADtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "density_distribution_of_scaled_PSI_for_", ADtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 
 
  ggplot(list_of_highest_PSI_isoforms_per_timepoint_ADseries[[ADtimepoint]] %>% as.data.frame %>% mutate_if(is.factor, as.character) %>% type_convert, aes(x = .x)) + 
  stat_ecdf(geom = "smooth", colour = "black") +
  geom_hline(aes(yintercept = 0.1), color = "red", linetype = "dashed", size = 1) +
  ggtitle(paste("CDF_distribution_of_scaled_PSI_for_", ADtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  xlab("scaled PSI") +
  ylab("proportion of isoforms") +
  scale_y_continuous(breaks = c(0.0, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0)) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "CDF_distribution_of_scaled_PSI_for_", ADtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "CDF_distribution_of_scaled_PSI_for_", ADtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")
  
}

```

## check for whether there is any dependence of number of junctions detected vs. coverage

```{r}

number_of_junctions_detected_per_sample <- read.delim(paste(qualitycheck_results_dir, "number_of_junctions_detected_per_sample.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE) %>% as_tibble

coveragedata <- read.delim(paste(qualitycheck_results_dir, "coveragedata.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

num_junctions_vs_coverage <- dplyr::inner_join(number_of_junctions_detected_per_sample, coveragedata, by = "timepoint_name")

num_junctions_vs_coverage_pearson <- cor(num_junctions_vs_coverage[, 2], num_junctions_vs_coverage[, 3], method = "pearson") %>% signif(4)

num_junctions_vs_coverage_gradient <- lm(formula = junction_counts ~ read_count, num_junctions_vs_coverage) %>% .[[1]] %>% .[2] %>% signif(digits = 4)

num_junctions_vs_coverage_intercept <- lm(formula = junction_counts ~ read_count, num_junctions_vs_coverage) %>% .[[1]] %>% .[1] %>% signif(4)

ggplot(num_junctions_vs_coverage, aes(y = junction_counts, x = read_count)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y~x, colour = "red") +
  annotate(geom = "text", label = bquote("R"^2 ~ "=" ~ .(num_junctions_vs_coverage_pearson)), x = 3.75e7, y = 244000, color = "red") +
  annotate(geom = "text", label = bquote("y =" ~ .(num_junctions_vs_coverage_gradient) ~ "x +" ~ .(num_junctions_vs_coverage_intercept)), x = 3.75e7, y = 240000, color = "red") +
  ggtitle(paste("plot_of_number_of_junctions_per_sample_vs_coverage_ADseries", sep = "")) +
  xlab("number of splice junctions detected") +
  ylab("read count") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "plot_of_number_of_junctions_per_sample_vs_coverage_ADseries", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "plot_of_number_of_junctions_per_sample_vs_coverage_ADseries", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")


```

## k-sweep and consensus matrix validation of som

```{r}

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range <- 5
ydim_range <- 4:8

som_seed_number <- 7

# AD series #####

set.seed(som_seed_number)

wide_table_som_sweep_clusters <- purrr::map2(.x = xdim_range, .y = ydim_range, .f = ~som(som_5_by_5_ADseries_table_AS_plausible, grid = somgrid(xdim = .x, ydim = .y, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)) %>% purrr::reduce(bind_cols)

wide_table_som_sweep_clusters <- wide_table_som_sweep_clusters %>% as.data.frame

rownames(wide_table_som_sweep_clusters) <- paste(PSI_levels_timeseries_AD_wide_processed_AS_plausible$Gene, "_", PSI_levels_timeseries_AD_wide_processed_AS_plausible$isoform_ID, sep = "")

# wide_table_som_sweep_clusters <- bind_cols(wide_table_som_sweep_clusters, gene_isoform_ID = paste(PSI_levels_timeseries_AD_wide_processed_AS_plausible$Gene, "_", PSI_levels_timeseries_AD_wide_processed_AS_plausible$isoform_ID, sep = ""))

list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% purrr::map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}))

list_percentage_consensus_byisoform <- purrr::map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble)

tibble_consensus_matrix <- purrr::reduce(list_percentage_consensus_byisoform, bind_rows)

matrix_consensus_matrix <- tibble_consensus_matrix %>% as.matrix

rownames(matrix_consensus_matrix) <- names(list_percentage_consensus_byisoform)

# reorder rows of consensus matrix

dist_result <- matrix_consensus_matrix %>% dist(method = "euclidean")
hclust_result <- hclust(dist_result, method = "ward.D2")
consensus_dendrogram <- as.dendrogram(hclust_result)
# cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

consensus_dendrogram_reordered <- reorder(consensus_dendrogram, matrix_consensus_matrix_rowmeans)

ggdendrogram(consensus_dendrogram_reordered) +
  ggsave(filename = paste(qualitycheck_results_dir, "dendrogram_som_consensus_matrix_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_isoforms_sweep_from_", min(xdim_range), "x", min(ydim_range), "_to_", max(xdim_range), "x", max(ydim_range), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 400, width = 200, height = 150, units = "cm", limitsize = FALSE)

dendrogram_order <- consensus_dendrogram_reordered %>% unlist
 
matrix_consensus_matrix_reordered <- matrix_consensus_matrix[dendrogram_order, dendrogram_order] %>% as_tibble(rownames = "gene_isoform_ID")
 
tibble_consensus_matrix_long <- reshape2::melt(matrix_consensus_matrix_reordered, id = c("gene_isoform_ID"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_if(is.factor, as.character)

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("Consensus matrix for som of ", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "isoforms ADseries (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), sweep from ", min(xdim_range), "x", min(ydim_range), " to ", max(xdim_range), "x", max(ydim_range), sep = "")) +
  scale_x_discrete(breaks = matrix_consensus_matrix_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_reordered$gene_isoform_ID) +
  scale_y_discrete(breaks = matrix_consensus_matrix_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_reordered$gene_isoform_ID) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black"), values = c(0, 0.33, 0.67, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 5, lineheight = 0.75, colour = "black", margin = margin(r = 1200)), legend.title.align = 0.5, axis.text.y = element_text(size = 5, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "heatmap_som_consensus_matrix_", nrow(wide_table_of_final_SOM_summary_5_by_5_ADseries_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_isoforms_sweep_from_", min(xdim_range), "x", min(ydim_range), "_to_", max(xdim_range), "x", max(ydim_range), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 400, width = 200, height = 150, units = "cm", limitsize = FALSE)

```

## frequency distribution of no. junctions detected/gene

### total AS calls

```{r}

avg_junctions_per_gene_total <- nrow(wide_table_all_splicemodes_split)/(wide_table_all_splicemodes_split$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_total, "AS junctions called in total"))

junctions_per_gene_total_freq <- wide_table_all_splicemodes_split %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_total_freq_2 <- junctions_per_gene_total_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_total_freq_2) + 
geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
geom_text(data = junctions_per_gene_all_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 20, x = no_junctions)) +
ggtitle(paste("frequency distribution of all AS junction calls per gene for all genes 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("number of junctions/gene") +
ylab("number of genes") +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_total.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_total.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_total_freq_2[1, 2]/junctions_per_gene_total_freq_2[2, 2]))

```


### all differential junctions

```{r}

avg_junctions_per_gene_all <- (wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05$isoform_ID %>% length)/(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_all, "differentially spliced junctions detected without considering plausible AS length"))

junctions_per_gene_all_freq <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05 %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_all_freq_2 <- junctions_per_gene_all_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_all_freq_2) + 
geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
geom_text(data = junctions_per_gene_all_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 20, x = no_junctions)) +
ggtitle(paste("frequency distribution of differentially spliced junctions per gene for all genes 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("number of junctions/gene") +
ylab("number of genes") +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_allsig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_allsig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_all_freq_2[1, 2]/junctions_per_gene_all_freq_2[2, 2]))

```

### plausible junctions only

```{r}

avg_junctions_per_gene_AS_plausible <- (wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$isoform_ID %>% length)/(wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_AS_plausible, "differentially spliced junctions with a plausible AS length"))

junctions_per_gene_AS_plausible_freq <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_AS_plausible_freq_2 <- junctions_per_gene_AS_plausible_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_AS_plausible_freq_2) + 
geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
geom_text(data = junctions_per_gene_AS_plausible_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 10, x = no_junctions)) +
ggtitle(paste("frequency distribution of differentially spliced junctions per gene for plausible genes 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("number of junctions/gene") +
ylab("number of genes") +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_AS_plausible_freq_2[1, 2]/junctions_per_gene_AS_plausible_freq_2[2, 2]))

```

## plot the number of significant differential AS events detected vs. total number of AS events called per gene

prep

```{r}

junctions_per_gene_joined <- dplyr::full_join(junctions_per_gene_total_freq, junctions_per_gene_all_freq, by = "Gene") %>% dplyr::full_join(junctions_per_gene_AS_plausible_freq, by = "Gene") %>% setNames(c("Gene", "no_junctions_total", "no_junctions_allsig", "no_junctions_AS_plausible"))

```


### all significant AS junctions

```{r}

junctions_per_gene_joined_pearson <- cor(junctions_per_gene_joined[, c("no_junctions_allsig", "no_junctions_total")] %>% na.omit %>% .[, "no_junctions_allsig"], junctions_per_gene_joined[, c("no_junctions_allsig", "no_junctions_total")] %>% na.omit %>% .[, "no_junctions_total"], method = "pearson") %>% signif(4)
junctions_per_gene_joined_gradient <- lm(formula = no_junctions_allsig ~ no_junctions_total, junctions_per_gene_joined[, c("no_junctions_allsig", "no_junctions_total")] %>% na.omit) %>% .[[1]] %>% .[2] %>% signif(digits = 4)
junctions_per_gene_joined_intercept <- lm(formula = no_junctions_allsig ~ no_junctions_total, junctions_per_gene_joined[, c("no_junctions_allsig", "no_junctions_total")] %>% na.omit) %>% .[[1]] %>% .[1] %>% signif(4)

# ggplot

ggplot(junctions_per_gene_joined[, c("no_junctions_allsig", "no_junctions_total")] %>% na.omit) + 
geom_point(aes(y = no_junctions_allsig, x = no_junctions_total)) +
ggtitle(paste("plot of number of differential junctions detected against the number of AS junctions that actually exist for a gene, all sig", 
              p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("number of total AS junctions in a gene") +
ylab("number of differential AS calls in gene, allsig") +
annotate(geom = "text", label = bquote("R"^2 ~ "=" ~ .(junctions_per_gene_joined_pearson)), x = 30, y = 18, color = "red") +
annotate(geom = "text", label = bquote("y =" ~ .(junctions_per_gene_joined_gradient) ~ "x +" ~ .(junctions_per_gene_joined_intercept)), x = 30, y = 17, color = "red") +
geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_junctions_allsig, x = no_junctions_total)) +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_diffjunctions_vs_totalASjunctions", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_allsig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_diffjunctions_vs_totalASjunctions", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_allsig.pdf", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

```


### AS plausible junctions

```{r}

junctions_per_gene_joined_pearson <- cor(junctions_per_gene_joined[, c("no_junctions_AS_plausible", "no_junctions_total")] %>% na.omit %>% .[, "no_junctions_AS_plausible"], junctions_per_gene_joined[, c("no_junctions_AS_plausible", "no_junctions_total")] %>% na.omit %>% .[, "no_junctions_total"], method = "pearson") %>% signif(4)
junctions_per_gene_joined_gradient <- lm(formula = no_junctions_AS_plausible ~ no_junctions_total, junctions_per_gene_joined[, c("no_junctions_AS_plausible", "no_junctions_total")] %>% na.omit) %>% .[[1]] %>% .[2] %>% signif(4)
junctions_per_gene_joined_intercept <- lm(formula = no_junctions_AS_plausible ~ no_junctions_total, junctions_per_gene_joined[, c("no_junctions_AS_plausible", "no_junctions_total")] %>% na.omit) %>% .[[1]] %>% .[1] %>% signif(4)

# ggplot

ggplot(junctions_per_gene_joined[, c("no_junctions_AS_plausible", "no_junctions_total")] %>% na.omit) + 
geom_point(aes(y = no_junctions_AS_plausible, x = no_junctions_total)) +
ggtitle(paste("plot of number of differential junctions detected against the number of AS junctions that actually exist for a gene, plausible", 
              p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("number of total AS junctions in a gene") +
ylab("number of differential AS calls in gene, AS plausible") +
annotate(geom = "text", label = bquote("R"^2 ~ "=" ~ .(junctions_per_gene_joined_pearson)), x = 30, y = 18, color = "red") +
annotate(geom = "text", label = bquote("y =" ~ .(junctions_per_gene_joined_gradient) ~ "x +" ~ .(junctions_per_gene_joined_intercept)), x = 30, y = 17, color = "red") +
geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_junctions_AS_plausible, x = no_junctions_total)) +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_diffjunctions_vs_totalASjunctions", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_diffjunctions_vs_totalASjunctions", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 


```




## frequency distribution of no. events detected per category

```{r}

junctions_per_category_all_freq <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05 %>% group_by(splicemode) %>% summarise(no_junctions_all = n())

junctions_per_category_AS_plausible_freq <- wide_table_of_all_splicemodes_with_na_ADseries_filtered_qvalue_0.05_AS_plausible %>% group_by(splicemode) %>% summarise(no_junctions_AS_plausible = n())

junctions_per_category_summary <- dplyr::full_join(junctions_per_category_all_freq, junctions_per_category_AS_plausible_freq, by = "splicemode")

junctions_per_category_summary_2 <- add_column(junctions_per_category_summary, "percentage_change_after_AS_plausible_filtering" = paste(signif((junctions_per_category_summary$no_junctions_AS_plausible - junctions_per_category_summary$no_junctions_all) * 100 / junctions_per_category_summary$no_junctions_all, 2), "%"))

long_junctions_per_category_summary_2 <- reshape2::melt(junctions_per_category_summary_2, id.vars = "splicemode")

long_junctions_per_category_summary_3 <- add_column(long_junctions_per_category_summary_2, "value_numeric" = gsub(x = long_junctions_per_category_summary_2$value, pattern = " %", replacement = "") %>% as.numeric)


# ggplot

ggplot(long_junctions_per_category_summary_3) + 
geom_col(aes(y = value_numeric, x = splicemode)) +
facet_wrap(~variable, scales = "free") +
geom_label(data = long_junctions_per_category_summary_3, aes(label = value, y = value_numeric, x = splicemode)) +
ggtitle(paste("frequency distribution of differentially spliced junctions per category 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("AS category") +
ylab("Number of differential junctions") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_category_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_category_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

## checking the junction counts and LRT statistics

### import the detailed tables into the environment

```{r message=FALSE, warning=FALSE}

list_of_timepoint_comparisons_final <- read.delim(paste(results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree %>% flatten

list_of_AS_events <- c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events") %>% array_tree %>% flatten

# generate lists of AS events per comparison
# list_of_timepoint_comparisons_final2 <- purrr::map(.x = list_of_timepoint_comparisons_final, .f = ~list_of_AS_events) %>% set_names(list_of_timepoint_comparisons_final)

# read tables into environment

list_of_detailed_tables <- purrr::map(.x = list_of_timepoint_comparisons_final, .f = ~purrr::map2(.x = .x, .y = list_of_AS_events, .f = ~read_delim(file = paste(results_dir, "final_JUM_output_", .x, "/", list.files(path = paste(results_dir, "final_JUM_output_", .x, "/", sep = ""), pattern = paste("(.)", .y, "(.*)detailed.txt", sep = "")), sep = ""), delim = "\t") %>% add_column(., "splicemode" = .y)) %>% set_names(list_of_AS_events)) %>% set_names(list_of_timepoint_comparisons_final)

# bind rows for each comparison

list_of_detailed_tables_2 <- list_of_detailed_tables %>% purrr::map(.x = ., .f = ~rbindlist(.x))

# rename the colnames to be not comparison-specific - we will add a comparison column later on

list_of_detailed_tables_3 <- purrr::map2(.x = list_of_detailed_tables_2, .y = list_of_timepoint_comparisons_final, .f = ~setNames(., c("Gene", "AS_event_ID", "AS_structure_ID", "sub_junction_ID", "sub-junction_dispersion_estimate", "LRT_statistic-full_vs_reduced", "LRT_p_value-full_vs_reduced", "BH_adjusted_p-values", "logCPM_1", "logCPM_2", "fitting_parameter_log2fold_change_2_from_1", "sub_junction_chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand", "raw_count.1", "raw_count.2", "raw_count.3", "raw_count.4", "raw_count.5", "raw_count.6", "percentage_usage.1", "percentage_usage.2", "percentage_usage.3", "percentage_usage.4", "percentage_usage.5", "percentage_usage.6", "deltaPSI", "splicemode")) %>% add_column(., "comparison" = .y)) 

wide_table_of_all_detailed_tables <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble

wide_table_of_all_detailed_tables_maxCPM <- wide_table_of_all_detailed_tables %>% dplyr::group_by(Gene) %>% dplyr::summarise(., maxCPM = max(logCPM_1 %>% na.omit, logCPM_2 %>% na.omit))

wide_table_of_all_detailed_tables_maxtranscriptlength <- getBM(filters = "external_gene_name", values = wide_table_of_all_detailed_tables_maxCPM$Gene, attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart) %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length	)) %>% 
  setNames(c("Gene", "maxtranscriptlength"))

wide_table_of_all_detailed_tables_maxCPM_maxtranscriptlength <- dplyr::full_join(wide_table_of_all_detailed_tables_maxCPM, 
                                                                           wide_table_of_all_detailed_tables_maxtranscriptlength, 
                                                                           by = "Gene")

```

### graph the no. of junctions detected vs. max. junction counts logCPM OR maximum transcript length

```{r}

wide_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength <- dplyr::full_join(wide_table_of_all_detailed_tables_maxCPM_maxtranscriptlength, junctions_per_gene_total_freq, by = "Gene") %>% 
  dplyr::full_join(., junctions_per_gene_all_freq, by = "Gene") %>%
  dplyr::full_join(., junctions_per_gene_AS_plausible_freq, by = "Gene") %>% setNames(., c("Gene", "maxCPM", "maxtranscriptlength", "no_junctions_total", "no_junctions_allsig", "no_junctions_AS_plausible"))

long_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength <- reshape2::melt(wide_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength, 
                                                                                    id = c("Gene", "maxCPM", "maxtranscriptlength"), variable.name = "filteringstep",
                                                                                    value.name = "no_junctions") %>% as_tibble %>% type_convert

# no junctions vs. max junction counts in logCPM

ggplot(long_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength %>% na.omit %>% type_convert) + 
geom_point(aes(y = no_junctions, x = maxCPM)) +
geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_junctions, x = maxCPM)) +
facet_wrap(~filteringstep, scales = "free") +
ggtitle(paste("scatterplot of the number of junctions detected per gene against max. junction counts 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("maximum junction count for a gene (logCPM)") +
ylab("number of (differential) junctions detected") +
theme_bw() +
theme(axis.text.x = element_text(hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_junctioncounts_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_junctioncounts_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 


# no. junctions detected vs. maximum annotated transcript length

ggplot(long_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength) + 
geom_point(aes(y = no_junctions, x = maxtranscriptlength)) +
geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_junctions, x = maxtranscriptlength)) +
facet_wrap(~filteringstep, scales = "free") +
ggtitle(paste("scatterplot of the number of junctions detected per gene against max. annotated transcipt length 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("maximum annotated transcript length") +
ylab("number of (differential) junctions detected") +
theme_bw() +
theme(axis.text.x = element_text(hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_transcriptlength_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_transcriptlength_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```



## PCA analysis of junction counts per sample (replicate)

read the combined counts in the environment
```{r}

library(Amelia)

list_combined_count_filenames_ADseries <- list.files(path = paste(JUM_diff_dir, sep = "")) %>% .[grep(x = ., pattern = "(.*)__combined_count.txt")] %>% array_tree
vector_combined_count_filenames_ADseries <- list_combined_count_filenames_ADseries %>% unlist
list_of_timepoint_names_ADseries <- vector_combined_count_filenames_ADseries %>% gsub(x = ., pattern = "(.*)__combined_count.txt", replacement = "\\1") %>% array_tree
# list_of_assigned_table_names <- vector_combined_count_filenames %>% gsub(x = ., pattern = "(.*)__combined_count.txt", replacement = "\\1_combined_count_table") %>% array_tree


length(list_combined_count_filenames_ADseries)
length(list_of_timepoint_names_ADseries)

list_of_combined_count_files_ADseries <- purrr::map2(.x = list_combined_count_filenames_ADseries, .y = list_of_timepoint_names_ADseries, .f = ~read.delim(file = paste(JUM_diff_dir, .x, sep = ""), sep = "\t", header = FALSE, na.strings = c("NONE", "NA", "INF", "Inf")) %>% setNames(c("sub_junction_id", paste(.y, "_count", sep = ""))) %>% as_tibble %>% mutate_if(is.factor, as.character))

wide_table_of_all_combined_count_files_ADseries <- purrr::reduce(list_of_combined_count_files_ADseries, dplyr::full_join)

# CHECK FOR MISSING VALUES IN THE COMBINED COUNT TABLE. THERE SHOULD BE NONE.

missmap(wide_table_of_all_combined_count_files_ADseries, pdfstub = paste(qualitycheck_results_dir, "heatmap_missingness_combinedcount_tables.pdf", sep = ""))

# PCA analysis

PCA_combined_count <- prcomp(wide_table_of_all_combined_count_files_ADseries[, 2:ncol(wide_table_of_all_combined_count_files_ADseries)])

# plot standard deviations 

PCA_stdev <- tibble(PC = 1:(PCA_combined_count[["sdev"]] %>% length), stdev = PCA_combined_count[["sdev"]])
PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)

ggplot(PCA_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on JUM combined count", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings <- PCA_combined_count[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings <- add_column(PCA_loadings, timepoint = gsub(x = PCA_loadings$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_loadings <- add_column(PCA_loadings, replicatenumber = gsub(x = PCA_loadings$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count", sep = "")) +
  xlab(paste("PC1 (", PCA_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count", sep = "")) +
  xlab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# I wonder if filtering for low junction counts improves the clustering

### FILTERING FOR JUNCTIONS WITH AT LEAST 5 READS IN ALL 3 REPLICATES OF EACH TIMEPOINT

# generate column partitioning indices (subset every 3 columns for each timepoint made up of 3 replicates)
a <- seq(from = 2, to = wide_table_of_all_combined_count_files_ADseries %>% ncol, by = 3)
b <- seq(from = 4, to = wide_table_of_all_combined_count_files_ADseries %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- apply(wide_table_of_all_combined_count_files_ADseries, MARGIN = 1, FUN = function(X) {purrr::map(c, ~all(X[.x] %>% as.numeric >= 5))})

# logical table to show the junction coordinates which have at least one timepoint which has a sufficient number of mapped read counts.
e <- purrr::map(d, ~any(.x == TRUE))

# filter for juunctions backed by sufficient read counts only
wide_table_of_all_combined_count_files_more_than_5_read_in_at_least_3_samples <- wide_table_of_all_combined_count_files_ADseries[which(e == TRUE), ]

# repeat the PCA plots
# PCA analysis

PCA_combined_count_filtered <- prcomp(wide_table_of_all_combined_count_files_more_than_5_read_in_at_least_3_samples[, 2:ncol(wide_table_of_all_combined_count_files_more_than_5_read_in_at_least_3_samples)])

# plot standard deviations 

PCA_stdev_filtered <- tibble(PC = 1:(PCA_combined_count_filtered[["sdev"]] %>% length), stdev = PCA_combined_count_filtered[["sdev"]])
PCA_variance_filtered <- tibble(PC = PCA_stdev_filtered$PC, variance = PCA_stdev_filtered$stdev ^ 2)
PCA_variance_filtered <- add_column(PCA_variance_filtered, variance_explained = PCA_variance_filtered$variance/sum(PCA_variance_filtered$variance) * 100)

ggplot(PCA_variance_filtered) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count_filtered[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on JUM combined count filtered (> 5 in all replicates each timepoint)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_filtered.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_filtered.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings_filtered <- PCA_combined_count_filtered[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, timepoint = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, replicatenumber = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count filtered (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance_filtered[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_filtered.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_filtered.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count filtered (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance_filtered[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_filtered.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_filtered.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

## RUV: removal of unwanted variation in the junction count data

### define packages, paths and functions

```{r}

library(RUVnormalize)

# function to transform a numerical array/matrix/tibble into an RLE plot, assuming genes are given on the y-axis and samples/replicates/timepoints are given on the x axis.

transformRLE <- function(input_array) {
  
  input_array <- log10(input_array)
  
  vec_gene_medians <- apply(X = input_array, MARGIN = 1, FUN = function(X) {median(X)})
  
  RLE_array <- apply(X = input_array, MARGIN = 2, FUN = function(X) {X - vec_gene_medians})
  
  return(RLE_array)
  
}

```


### before normalisation

```{r}

wide_table_of_all_combined_count_files_RLE <- wide_table_of_all_combined_count_files_ADseries

wide_table_of_all_combined_count_files_RLE[, 2:ncol(wide_table_of_all_combined_count_files_RLE)] <- transformRLE(wide_table_of_all_combined_count_files_RLE[, 2:ncol(wide_table_of_all_combined_count_files_RLE)])

long_table_of_all_combined_count_files_RLE <- reshape2::melt(wide_table_of_all_combined_count_files_RLE, value.name = "junction_counts", id = "sub_junction_id", variable.name = "samplename")

ggplot(long_table_of_all_combined_count_files_RLE) +
  geom_boxplot(aes(x = samplename, y = junction_counts)) +
  # ylim(1, 100000) +
  theme_bw() +
  xlab("replicate name")+
  ylab("relative log10 junction counts (RLE)") +
  ggtitle("RLE plot of raw junction counts") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), legend.title.align = 0.5, text = element_text(family ="Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_raw.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_raw.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### RUV

Sort genes by their standard deviation

```{r warning=FALSE}

# Sort genes by their standard deviation

wide_table_of_all_combined_count_files_ADseries <- wide_table_of_all_combined_count_files_ADseries %>% type_convert

# sd <- apply(wide_table_of_all_combined_count_files_ADseries[, 2:ncolwide_table_of_all_combined_count_files_ADseries], 1, FUN = function(X) {sd(X)})

# ssd <- wide_table_of_all_combined_count_files_ADseries[order(sd, decreasing = TRUE), ]

# Cluster the samples

# kmres <- kmeans(ssd[, 2:ncol(ssd)], centers = ADseries_timepoints %>% length, nstart = 200)

# vclust <- kmres$cluster

# Compute the distance between clustering by replicate and clustering obtained by k-means

# uScore <- clScore(ssd[, 2:4], ssd[, 5:7])

```

centering genes by replicate

```{r eval=FALSE, include=FALSE}

ssd_centred <- apply(ssd[, 2:ncol(ssd)], 2, FUN = function(X) {scale(X)}) %>% as_tibble
ssd_centred <- bind_cols(tibble(sub_junction_id = ssd$sub_junction_id), ssd_centred)

ssd_centred_RLE <- ssd_centred
ssd_centred_RLE[, 2:ncol(ssd_centred_RLE)] <- transformRLE(ssd_centred_RLE[, 2:ncol(ssd_centred_RLE)])
tibble_ssd_centred_RLE_long <- reshape2::melt(ssd_centred_RLE, value.name = "junction_counts", id = "sub_junction_id", variable.name = "samplename")

ggplot(tibble_ssd_centred_RLE_long) +
  geom_boxplot(aes(x = samplename, y = junction_counts)) +
  # ylim(1, 100000) +
  xlab("replicate name")+
  ylab("relative log10 junction counts (RLE)") +
  ggtitle("RLE plot of centred junction counts") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), legend.title.align = 0.5, text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_centred.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_centred.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

Naive RUV-2 no shrinkage

```{r}

replicate_rownumbers <- tribble(~rep1, ~rep2, ~rep3,
            1,     2,     3,
            4,     5,     6,
            7,     8,     9,
            10,    11,    12,
            13,    14,    15,
            16,    17,    18,
            19,    20,    21,
            22,    23,    24) %>% as.matrix

nsY <- naiveReplicateRUV(t(wide_table_of_all_combined_count_files_ADseries[, 2:ncol(wide_table_of_all_combined_count_files_ADseries)]), scIdx = replicate_rownumbers, k = 5)

tibble_RUV_wide <- bind_cols(wide_table_of_all_combined_count_files_ADseries[, "sub_junction_id"], t(nsY$cY) %>% as_tibble)

tibble_RUV_wide_RLE <- tibble_RUV_wide
tibble_RUV_wide_RLE[, 2:ncol(tibble_RUV_wide_RLE)] <- transformRLE(tibble_RUV_wide_RLE[, 2:ncol(tibble_RUV_wide_RLE)])
tibble_RUV_RLE_long <- reshape2::melt(tibble_RUV_wide_RLE, value.name = "junction_counts", id = "sub_junction_id", variable.name = "samplename")

ggplot(tibble_RUV_RLE_long) +
  geom_boxplot(aes(x = samplename, y = junction_counts)) +
  # ylim(1, 100000) +
  xlab("replicate name")+
  ylab("relative log10 junction counts (RLE)") +
  ggtitle("RLE plot of RUV junction counts") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), legend.title.align = 0.5, text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

plot PCA

```{r}

# repeat the PCA plots
# PCA analysis

PCA_combined_count_filtered <- prcomp(tibble_RUV_wide[, 2:ncol(tibble_RUV_wide)])

# plot standard deviations 

PCA_stdev_filtered <- tibble(PC = 1:(PCA_combined_count_filtered[["sdev"]] %>% length), stdev = PCA_combined_count_filtered[["sdev"]])
PCA_variance_filtered <- tibble(PC = PCA_stdev_filtered$PC, variance = PCA_stdev_filtered$stdev ^ 2)
PCA_variance_filtered <- add_column(PCA_variance_filtered, variance_explained = PCA_variance_filtered$variance/sum(PCA_variance_filtered$variance) * 100)

ggplot(PCA_variance_filtered) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count_filtered[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on JUM combined count RUV (> 5 in all replicates each timepoint)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings_filtered <- PCA_combined_count_filtered[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, timepoint = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, replicatenumber = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count RUV (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance_filtered[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count RUV (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance_filtered[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### export the normalised combined junction count tables

```{r}

RUV_combined_junction_counts <-  paste(qualitycheck_results_dir, "RUV_combined_junction_counts/", sep = "")

if(! dir.exists(RUV_combined_junction_counts) ) {
     dir.create(RUV_combined_junction_counts, recursive = TRUE)}

wide_tibble_junctioncounts_RUV <- tibble_RUV_wide

# move up the values to prevent negative, then x1000 and round to prevent non-integer values and to minimise relative error when we round

wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)] <- round((wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)] - min(wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)])), digits = 0)

for (timepoint in colnames(wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)])) {
  
  write.table(x = wide_tibble_junctioncounts_RUV[, c("sub_junction_id", paste(timepoint))], file = paste(RUV_combined_junction_counts, gsub(x = timepoint, pattern = "(.*)_count", replacement = "\\1__combined_count.txt"), sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
  
}

```

## can we merge the AD series and AD series?? are they comparable??

NOTE: INCOMPLETE. WE NEED TO DO JUM ON ALL THE SAMPLES IN ONE RUN SO IT CAN COMBINE THE JUNCTION COUNTS INTO CONSISTENT IDs

there are missing values so we can use missMDA to impute for PCA

```{r eval=FALSE, include=FALSE}

library(missMDA)

wide_table_of_all_combined_count_files_ADandADseries <- dplyr::full_join(wide_table_of_all_combined_count_files_ADseries, wide_table_of_all_combined_count_files_ADseries, by = "sub_junction_id")

combined_count_files_ADandADseries_imputePCA <- estim_ncpPCA(wide_table_of_all_combined_count_files_ADandADseries, method.cv = "Kfold", verbose = FALSE)



```

# COMBINING GENE EXPRESSION DATA WITH THE SPLICEOMIC DATA HERE

## set environment

set directories

```{r}

# the EXACT path of the file, not its containing directory

logCPM_ADseries_anysig_DEGs_dir <- "//VBOXSVR/sharedfolder/PGNEXUS_kassem_MSC/Kassem_AD_fastqc/analysis_RSEM_local/run_1_original/R_processing_results/edgeR_anysig_DEGs_logCPM.txt"

```

define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

## extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

logCPM_ADseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_ADseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_ADseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_ADseries_anysig_DEGs <- dplyr::right_join(ENSG_to_genesymbol_DEGs, logCPM_ADseries_anysig_DEGs_import, by = "ensembl_gene_id") %>% average_counts_from_triplicate(., 2)

# reorder the columns to make them chronological

logCPM_ADseries_anysig_DEGs <- logCPM_ADseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_AD_ud_avg", "logCPM_BM_MSC_to_AD_6h_avg", "logCPM_BM_MSC_to_AD_12h_avg", "logCPM_BM_MSC_to_AD_1d_avg", "logCPM_BM_MSC_to_AD_3d_avg", "logCPM_BM_MSC_to_AD_6d_avg", "logCPM_BM_MSC_to_AD_9d_avg", "logCPM_BM_MSC_to_AD_12d_avg", "logCPM_BM_MSC_to_AD_15d_avg")]

colnames(logCPM_ADseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")

# subset CPM table by biological role

  # RBPs
column_RBP_genes_ADseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_ADseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "RNA binding" | .$name_1006 == "spliceosomal complex", "ensembl_gene_id"]

logCPM_ADseries_RBP <- dplyr::semi_join(logCPM_ADseries_anysig_DEGs, column_RBP_genes_ADseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "RBP", .$ensembl_gene_id, sep = "_"), .after = 2)

  # lncRNA
column_lncRNA_genes_ADseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("lncRNA", logCPM_ADseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble

logCPM_ADseries_lncRNA <- dplyr::semi_join(logCPM_ADseries_anysig_DEGs, column_lncRNA_genes_ADseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "lncRNA", .$ensembl_gene_id, sep = "_"), .after = 2)

  # snRNA
column_snRNA_genes_ADseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("snRNA", logCPM_ADseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble %>% mutate_if(is.logical, as.character)

logCPM_ADseries_snRNA <- dplyr::semi_join(logCPM_ADseries_anysig_DEGs, column_snRNA_genes_ADseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "snRNA", .$ensembl_gene_id, sep = "_"), .after = 2)

  # all TF complex 

column_TFcomplex_genes_ADseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_ADseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "transcription factor complex", "ensembl_gene_id"]

logCPM_ADseries_TFcomplex <- dplyr::semi_join(logCPM_ADseries_anysig_DEGs, column_TFcomplex_genes_ADseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "TF complex", .$ensembl_gene_id, sep = "_"), .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_ADseries_subset <- dplyr::bind_rows(logCPM_ADseries_RBP, logCPM_ADseries_lncRNA, logCPM_ADseries_snRNA, logCPM_ADseries_TFcomplex)

# get rid of ENSG id
logCPM_ADseries_subset <- logCPM_ADseries_subset[, -1]

# rename column before next join

colnames(logCPM_ADseries_subset)[1] <- "Gene"

# combine logCPM and PSI values
tibble_combinedexpr_logCPM_PSI_unscaled <- dplyr::bind_rows(PSI_levels_timeseries_AD_wide_processed_AS_plausible %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character), logCPM_ADseries_subset) 

```

## consensus re-clustering of combined expression and PSI data

```{r}

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7)
ydim_range_combinedexpr <- c(8, 9, 10, 11, 6, 7, 8, 5, 6, 7, 4, 5, 4)

som_seed_number <- 7

# AD series #####

tibble_combinedexpr_logCPM_PSI_scaled <- tibble_combinedexpr_logCPM_PSI_unscaled

tibble_combinedexpr_logCPM_PSI_scaled[, 5:ncol(tibble_combinedexpr_logCPM_PSI_scaled)] <- tibble_combinedexpr_logCPM_PSI_unscaled[, 5:ncol(tibble_combinedexpr_logCPM_PSI_unscaled)] %>% genescale(m = ., axis = 1, method = "Z")

# LAST TIME ENSEMBL CHANGED HALFWAY THRU THE ANALYSIS. IM NOT REPEATING THAT MISTAKE AGAIN

write.table(tibble_combinedexpr_logCPM_PSI_scaled, paste(results_directory_figures, "tibble_combinedexpr_logCPM_PSI_scaled_GRCh38.99.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = TRUE)

tibble_combinedexpr_logCPM_PSI_scaled <- read_delim(paste(results_directory_figures, "tibble_combinedexpr_logCPM_PSI_scaled_GRCh38.99.txt", sep = ""), delim = "\t")

set.seed(som_seed_number)

wide_table_combinedexpr_som_sweep_clusters <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~som(tibble_combinedexpr_logCPM_PSI_scaled[, 5:ncol(tibble_combinedexpr_logCPM_PSI_scaled)] %>% as.matrix, grid = somgrid(xdim = .x, ydim = .y, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)) %>% purrr::reduce(bind_cols)

wide_table_combinedexpr_som_sweep_clusters <- wide_table_combinedexpr_som_sweep_clusters %>% as.data.frame

rownames(wide_table_combinedexpr_som_sweep_clusters) <- paste(tibble_combinedexpr_logCPM_PSI_scaled$Gene, "_", tibble_combinedexpr_logCPM_PSI_scaled$isoform_ID, sep = "")


list_matchtest_combinedexpr_som_sweep_byisoform <- purrr::map(wide_table_combinedexpr_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% purrr::map(.f = ~apply(X = wide_table_combinedexpr_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}))

list_percentage_consensus_byisoform_combinedexpr <- purrr::map(list_matchtest_combinedexpr_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble)

# tibble_consensus_matrix_combinedexpr <- purrr::reduce(list_percentage_consensus_byisoform_combinedexpr, bind_rows)

tibble_consensus_matrix_combinedexpr <- list_percentage_consensus_byisoform_combinedexpr %>% rbindlist

matrix_consensus_matrix_combinedexpr <- tibble_consensus_matrix_combinedexpr %>% as.matrix

rownames(matrix_consensus_matrix_combinedexpr) <- names(list_percentage_consensus_byisoform_combinedexpr)

## HOOOOOOOLY SHIT RBINDLIST IS SO QUICK ##########
# WE DONT EVEN NEED THIS
# write.table(tibble_consensus_matrix_combinedexpr, paste(results_directory_figures, "tibble_consensus_matrix_combinedexpr.txt", sep = ""), sep = "\t", row.names = TRUE, quote = FALSE, col.names = TRUE)



# reorder rows of consensus matrix

matrix_consensus_matrix_combinedexpr_dist_result <- matrix_consensus_matrix_combinedexpr %>% Dist(method = "euclidean") %>% as.dist
matrix_consensus_matrix_combinedexpr_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_combinedexpr_dist_result, method = "ward.D2")
matrix_consensus_matrix_combinedexpr_consensus_dendrogram <- as.dendrogram(matrix_consensus_matrix_combinedexpr_hclust_result)
# cols/rows should get darker as you move right/down
matrix_consensus_matrix_combinedexpr_rowmeans <- rowMeans(matrix_consensus_matrix_combinedexpr, na.rm = T)
# matrix_consensus_matrix_combinedexpr_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix_combinedexpr) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_combinedexpr_singular_vectors_byrow <- apply(matrix_consensus_matrix_combinedexpr, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered <- reorder(matrix_consensus_matrix_combinedexpr_consensus_dendrogram, matrix_consensus_matrix_combinedexpr_rowmeans)

ggdendrogram(matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered) +
  xlab("Gene/isoform") +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "dendrogram_som_consensus_matrix_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered_order <- matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered %>% unlist
 
matrix_consensus_matrix_combinedexpr_reordered <- matrix_consensus_matrix_combinedexpr[matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered_order, matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered_order] %>% as_tibble(rownames = "gene_isoform_ID")
 
tibble_consensus_matrix_combinedexpr_long <- reshape2::melt(matrix_consensus_matrix_combinedexpr_reordered, id = c("gene_isoform_ID"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_if(is.factor, as.character)

write.table(x = matrix_consensus_matrix_combinedexpr_reordered, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

ggplot(tibble_consensus_matrix_combinedexpr_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("ADseries consensus matrix for som of ", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), " isoforms, 
                ", nrow(logCPM_ADseries_RBP), " RBPs, ", nrow(logCPM_ADseries_lncRNA), " lncRNAs, ", nrow(logCPM_ADseries_snRNA), " snRNAs, ", nrow(logCPM_ADseries_TFcomplex), " TFcomplexes", " 
                (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID) +
  scale_y_discrete(breaks = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID) +
  scale_fill_gradientn(colours = c("blue", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.tiff", sep = ""), device = "tiff", dpi = 1200, width = 40, height = 25, units = "cm", limitsize = FALSE)

write.table(x = tibble_consensus_matrix_combinedexpr_long, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

ggplot(tibble_consensus_matrix_combinedexpr_long[1, ], aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("ADseries consensus matrix for som of ", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), " isoforms, ", nrow(logCPM_ADseries_RBP), " RBPs, ", nrow(logCPM_ADseries_lncRNA), " lncRNAs, ", nrow(logCPM_ADseries_snRNA), " snRNAs, ", nrow(logCPM_ADseries_TFcomplex), " TFcomplexs", " (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black"), values = c(0, 0.33, 0.67, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 1, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 1, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "xlabs_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 400, width = 200, height = 10, units = "cm", limitsize = FALSE)

```

cluster determination from consensus matrix

```{r message=FALSE, warning=FALSE}

# tibble_consensus_matrix_combinedexpr_long <- read_delim(paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.txt", sep = ""), delim = "\t")

list_genes_or_isoforms_from_combinedexpr <- tibble_consensus_matrix_combinedexpr_long$variable %>% unique %>% array_tree

# testing purposes only 

# list_genes_or_isoforms_from_combinedexpr <- list_genes_or_isoforms_from_combinedexpr[c(1:50, 1000:1050)]

list_genes_or_isoforms_from_combinedexpr_cooccuring <- purrr::map(.x = list_genes_or_isoforms_from_combinedexpr, .f = ~tibble_consensus_matrix_combinedexpr_long[tibble_consensus_matrix_combinedexpr_long$variable == .x & tibble_consensus_matrix_combinedexpr_long$cocluster_percentage >= 0.5, "gene_isoform_ID"])

names(list_genes_or_isoforms_from_combinedexpr_cooccuring) <- list_genes_or_isoforms_from_combinedexpr

# take pairwise intersections

comparisons_genes_or_isoforms_from_combinedexpr <- combn(list_genes_or_isoforms_from_combinedexpr %>% unlist, m = 2) %>% t %>% as_tibble

colnames(comparisons_genes_or_isoforms_from_combinedexpr) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection

list_comparison_1 <- comparisons_genes_or_isoforms_from_combinedexpr %>% .[, 1] %>% array_tree %>% flatten

list_comparison_2 <- comparisons_genes_or_isoforms_from_combinedexpr %>% .[, 2] %>% array_tree %>% flatten

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection <- purrr::map2(.x = list_comparison_1, .y = list_comparison_2, .f = ~dplyr::intersect(list_genes_or_isoforms_from_combinedexpr_cooccuring[[.x]], list_genes_or_isoforms_from_combinedexpr_cooccuring[[.y]]) %>% nrow) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff <- purrr::map2(.x = list_comparison_1, .y = list_comparison_2, .f = ~dplyr::setdiff(list_genes_or_isoforms_from_combinedexpr_cooccuring[[.x]], list_genes_or_isoforms_from_combinedexpr_cooccuring[[.y]]) %>% nrow)  %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- bind_cols(comparisons_genes_or_isoforms_from_combinedexpr %>% as_tibble, list_genes_or_isoforms_from_combinedexpr_itemwise_intersection[, 1], list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff[, 1])

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- add_column(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, "jaccard" = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_intersection/(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_setdiff + list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_intersection))

write.table(x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, file = paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")


list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3 <- list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2[list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_intersection > 0, ]

plot(density(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3$jaccard %>% as.numeric))

write.table(x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3, file = paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_intersection1_consensus0.5.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

########### GO TO CYTOSCAPE HERE ###################

tibble_combinedexpr_logCPM_PSI_scaled_2 <- bind_cols(tibble_combinedexpr_logCPM_PSI_scaled, gene_isoform_ID = paste(tibble_combinedexpr_logCPM_PSI_scaled$Gene, "_", tibble_combinedexpr_logCPM_PSI_scaled$isoform_ID, sep = ""))

cytoscape_result <- read_delim(paste(results_directory_figures, "consensus_combinedexpr_intersection1_min25_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab", sep = ""), delim = "\t", col_names = c("cluster", "gene_isoform_ID"))

cytoscape_result[, "cluster"] <- gsub(x = cytoscape_result$cluster, pattern = "Cluster ", replacement = "") %>% as.numeric

list_cytoscape_cluster_results <- purrr::map(.x = cytoscape_result$cluster %>% unique, .f = ~cytoscape_result[cytoscape_result$cluster == .x, ])

list_combinedexpr_logCPM_PSI_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(tibble_combinedexpr_logCPM_PSI_scaled_2, .x, by = "gene_isoform_ID") %>% na.omit)

wide_table_combinedexpr_logCPM_PSI_scaled_clustered <- list_combinedexpr_logCPM_PSI_scaled_clustered %>% rbindlist %>% as_tibble



```

### generate expression profile map

the goal of this is to get extract timepoint PSI tables according to each consensus cluster

```{r}

# reorder the cluster factor for correct facet order

wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster <- factor(wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster %>% mixedsort, levels = wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster %>% unique %>% mixedsort)

### convert the som table to a long form interprable by ggplot

# reshaping into long table

long_table_combinedexpr_logCPM_PSI_scaled_clustered <- reshape2::melt(wide_table_combinedexpr_logCPM_PSI_scaled_clustered, id.vars = c("Gene", "AS_event_ID", "splicemode", "isoform_ID", "gene_isoform_ID", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

long_table_combinedexpr_logCPM_PSI_scaled_clustered <- long_table_combinedexpr_logCPM_PSI_scaled_clustered %>% as_tibble

# ggplot of consensus som PSI profiles

ggplot(long_table_combinedexpr_logCPM_PSI_scaled_clustered, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = gene_isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of ", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), " isoforms, ", nrow(logCPM_ADseries_RBP), " RBPs, ", nrow(logCPM_ADseries_lncRNA), " lncRNAs, ", nrow(logCPM_ADseries_snRNA), " snRNAs, ", nrow(logCPM_ADseries_TFcomplex), " TFcomplexs", " (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), 
                sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d", "15d")) +
  xlab("Time-point") +
  ylab("Scaled PSI or logCPM Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_combinedexpr_logCPM_PSI_scaled_clustered, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### GO term, family and RBP target enrichment

##### GO term

```{r}

# AD series #####

list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_all <- purrr::map(.x = list_combinedexpr_logCPM_PSI_scaled_clustered
                                                          , .f = ~.x$Gene %>% as.vector %>% unique)

list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly <- purrr::map(.x = list_combinedexpr_logCPM_PSI_scaled_clustered
                                                          , .f = ~.x[.x$splicemode != "RNASeq", "Gene"] %>% unlist %>% as.vector %>% unique)

number_of_consensus_combinedexpr_clusters <- wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster %>% unique %>% length

# let's try to do all enrichment at once using purrr

list_of_combinations_of_consensus_combinedexpr_genes_and_GOterms <- cross2(.x = list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly, .y = list("MF", "BP", "CC"))

# note: each element will be [[1]]: gene set, [[2]]: GO term to query

list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables <- purrr::map(.x = list_of_combinations_of_consensus_combinedexpr_genes_and_GOterms, .f = ~GOHyperGAll(catdb = catdb, gocat = .x[[2]], Nannot = 2, sample = .x[[1]]) %>% GOHyperGAll_benjamini_correction)

list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map(.x = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))

list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map2(.x = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten, .y = 1:number_of_consensus_combinedexpr_clusters %>% rep(., times = 3) %>% as.list, .f = ~cbind(.x, "cluster" = .y) %>% as_tibble)

list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2 <- list(
  "MF" = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten[1:number_of_consensus_combinedexpr_clusters] %>% purrr::reduce(bind_rows), 
  "BP" = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten[(number_of_consensus_combinedexpr_clusters + 1):(number_of_consensus_combinedexpr_clusters*2)] %>% purrr::reduce(bind_rows),
  "CC" = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten[((2*number_of_consensus_combinedexpr_clusters) + 1):(number_of_consensus_combinedexpr_clusters*3)] %>% purrr::reduce(bind_rows)) %>% purrr::map(~type_convert(.x))

# cheeky ggplot

purrr::map2(.x = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented", .y, "GO terms for each consensus cluster of PSI and select gene expression combined")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y, ".svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_ADseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~write.table(x = .x, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

##### family enrichment

```{r}

list_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables <- purrr::map(.x = list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables) <- 1:number_of_consensus_combinedexpr_clusters

list_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten <- purrr::map2(.x = list_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables, .y = 1:number_of_consensus_combinedexpr_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten <- purrr::reduce(.x = list_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten, .f = bind_rows) %>% type_convert

# ggplot

ggplot(wide_table_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster of PSI and select gene expression combined")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("PFAM family") +
  ylab("Number of genes in family and in cluster") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm")

write.table(x = wide_table_of_ADseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

##### RBP target enrichment

```{r}

list_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables <- purrr::map(.x = list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables) <- 1:number_of_consensus_combinedexpr_clusters

list_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten <- purrr::map2(.x = list_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables, .y = 1:number_of_consensus_combinedexpr_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten <- purrr::reduce(.x = list_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten, .f = bind_rows) %>% type_convert

# ggplot

ggplot(wide_table_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten, aes(x = reorder(TermID, pval), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each PLAUSIBLE CONSENSUS cluster in AD series")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP with literature reference") +
  ylab("Number of genes enriched amongst RBP target genes") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm")

write.table(x = wide_table_of_ADseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_AD_wide_processed_AS_plausible), "_isoforms_ADseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```
