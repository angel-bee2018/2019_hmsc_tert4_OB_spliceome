---
title: "Multiomic Synthesis - Phospho-proteo-spliceome project"
author: "Angel Liang"
date: "16/04/2020"
output: html_document
---


# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
library(extrafont)
# font_import(paths = "~/.local/share/fonts/")
loadfonts(device = "pdf")
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(genefilter)

library(ggplot2)
library(ggpattern)

library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
library(svglite)
library(scales)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)
library(data.table)

library(crayon)
library(VennDiagram)

library(biomaRt)
ensembl_mart = useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host = "http://sep2019.archive.ensembl.org")
library(systemPipeR)
library(GOstats)
library(PFAM.db)
# library(bc3net)

# library(ComplexHeatmap)

# library(ggdendro)
# library(data.table)
# library(Rfast)

# shared_dir <- "Z:/"
shared_dir <- "/mnt/Tertiary/sharedfolder/"

# results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/multiomic_synthesis/results/"
results_dir <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/multiomic_synthesis/results/"
# results_dir <- "/media/angel/seagate_500/"

# results_directory_figures <- paste(results_dir, "figures/", sep="")
# 
# if(! dir.exists(results_directory_figures) ) {
#      dir.create(results_directory_figures, recursive = TRUE)}

# ensembl gene_nane gene_stable_id and transcript_stable_id mapping
tibble_ensembl_gene_name_transcript_stable_id_mapping <- read.delim(file = paste(shared_dir, "table_ensembl_gene_name_transcript_stable_id_mapping.txt", sep = ""), header = TRUE, row.names = NULL, check.names = FALSE, stringsAsFactors = FALSE) %>% as_tibble

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf_with_NMD_flagged <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E2.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E2 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E2.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E3 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E3.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E4 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E4.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E5 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E5.gtf") %>% as_tibble

```

## define functions

### Enrichment/Gene Ontology

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

```

### FUNCTION TO CHANGE THE NAME OF ONE COLUMN WITH EXACT MATCH

```{r}

rename_column_exact <- function(input_tibble, target_column, output_colname) {
  
  output_tibble <- input_tibble
  
  colnames(output_tibble)[which(colnames(output_tibble) == target_column)] <- output_colname
  
  return(output_tibble)
  
}

```


### function to split a whole table by a delimiter in a column

```{r}

split_delimited_column_in_table <- function(input_table, target_colname, split, columns_to_deduplicate = NULL) {
  
  # DEBUG ###
  # input_table <- tibble_phosphosites_with_protein_group_ids
  # target_colname <- "Protein.group.IDs"
  # split = "\\;"
  # columns_to_deduplicate <- c("id", "1h_vs_ud|IB")
  ###########
  
  # list-ify the target column
  list_target_column_strsplit_per_element <- input_table[, target_colname] %>% unlist %>% strsplit(., split = split)
  
  # map length
  vector_split_lengths <- list_target_column_strsplit_per_element %>% purrr::map(~length(.x)) %>% unlist(use.names = FALSE)
  
  # repeat table according to the split lengths
  row_indices_of_table_repeated_by_split <- rep(x = 1:nrow(input_table), times = vector_split_lengths)
  
  input_table_repeated_by_split <- input_table[row_indices_of_table_repeated_by_split, ]
  
  # replace target column with split values
  input_table_repeated_by_split[, target_colname] <- list_target_column_strsplit_per_element %>% unlist(use.names = FALSE)
  
  split_table <- input_table_repeated_by_split
  
  # if specified, append an index to a particular column
  if (is.null(columns_to_deduplicate) == FALSE) {
    
    # get the duplicated row indices where split lengths > 1
    indices_of_duplicates <- which(vector_split_lengths > 1)
    
    # get the repetition number where split lengths > 1
    repetition_numbers_of_duplicates <- vector_split_lengths[which(vector_split_lengths > 1)]
    
    # list-ify the columns to be appended
    list_deduplicated_columns <- input_table[, columns_to_deduplicate] %>% array_tree(margin = 2) %>% purrr::map(~array_tree(.x))
    
    # map over each column, split the target element and add _[0-9]+
    list_deduplicated_columns_split <- purrr::map(.x = list_deduplicated_columns, .f = function(a1) {
      
      # map a subset each of the L2 (elements of a column)
      a1[indices_of_duplicates] <- purrr::map2(.x = a1[indices_of_duplicates], .y = repetition_numbers_of_duplicates, 
                  .f = ~rep(.x, times = .y) %>% unlist %>% paste(., 1:.y, sep = "_"))
      
      return(a1 %>% unlist)
      
    } )
    
    # tibblise
    tibble_deduplicated_columns_split <- list_deduplicated_columns_split %>% as_tibble
    
    # add back every row onto the split table
    for (dedupe_colname in columns_to_deduplicate) {
      
      split_table[, dedupe_colname] <- tibble_deduplicated_columns_split[, dedupe_colname]
      
    }
    
  }
  
  return(split_table %>% type_convert)
  
}

```

### function to split a whole table by a delimiter in a few columns (multi ver.)

```{r}

split_delimited_columns_in_table <- function(input_table, target_colname, split, columns_to_deduplicate = NULL) {
  
  # DEBUG ###
  # input_table <- test
  # target_colname <- c("CHR_ID", "CHR_POS", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT")
  # split = "\\;"
  # columns_to_deduplicate <- NULL
  ###########
  
  # list-ify the target column
  list_target_column_strsplit_per_element <- input_table[, target_colname] %>% array_tree(margin = 2) %>% purrr::map(~.x %>% unlist %>% strsplit(., split = split))
  
  # retrieve lengths of each split for each row, each column.
  list_target_column_split_lengths_per_element <- purrr::map(.x = list_target_column_strsplit_per_element, .f = ~purrr::map(.x = .x, .f = ~.x %>% length))
  
  # do not account for rows that were length 1 for one column BUT NOT for others.
  vector_indices_length_one_for_some_colunmns <- purrr::pmap(.l = list_target_column_split_lengths_per_element, .f = ~(c(...) %>% unique %>% length == 2) & (any(c(...) == 1))) %>% unlist %>% which
  
  # map length
  vector_sum_lengths <- list_target_column_strsplit_per_element %>% purrr::map(~.x[setdiff(.x %>% length, vector_indices_length_one_for_some_colunmns)]) %>% purrr::map(~length(.x %>% unlist)) %>% unlist(use.names = FALSE) %>% unique
  
  # check. if the split lengths are different, then die.
  if (length(vector_sum_lengths) != 1) {
    
    # get problem rows for easy debugging
    vector_problem_row_indices <- purrr::pmap(.l = list_target_column_split_lengths_per_element, .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1) %>% unlist %>% which
    
    stop("split lengths are uneven across specified columns. Problem rows: ", paste(vector_problem_row_indices, collapse = ","))
    
  }
  
  # repeat table according to the split lengths
  vector_split_lengths <- purrr::map_depth(.x = list_target_column_strsplit_per_element, .depth = 2, .f = ~length(.x)) %>% 
    purrr::map(~unlist(.x)) %>%
    purrr::pmap(.f = ~max(...)) %>%
    unlist
  
  # if there are elements of length = 1, then repeat to max. length.
  list_target_column_strsplit_per_element <- purrr::map(.x = list_target_column_strsplit_per_element, 
                                                        .f = ~purrr::map2(.x = .x, .y = vector_split_lengths, 
                                                                          .f = function(b1, b2) {
                                                                            
                                                                            if (b1 %>% length == b2) {
                                                                              return(b1)
                                                                            } else {
                                                                              return(rep(b1, times = b2))
                                                                            }
                                                                            
                                                                          } ))
  
  row_indices_of_table_repeated_by_split <- purrr::map2(.x = 1:nrow(input_table), .y = vector_split_lengths, .f = ~rep(x = .x, times = .y)) %>% unlist
  
  input_table_repeated_by_split <- input_table[row_indices_of_table_repeated_by_split, ]
  
  # replace target column with split values
  input_table_repeated_by_split[, target_colname] <- list_target_column_strsplit_per_element %>% purrr::map(~unlist(.x)) %>% purrr::reduce(cbind)
  
  split_table <- input_table_repeated_by_split
  
  # if specified, append an index to a particular column
  if (is.null(columns_to_deduplicate) == FALSE) {
    
    # get the duplicated row indices where split lengths > 1
    indices_of_duplicates <- which(vector_split_lengths > 1)
    
    # get the repetition number where split lengths > 1
    repetition_numbers_of_duplicates <- vector_split_lengths[which(vector_split_lengths > 1)]
    
    # list-ify the columns to be appended
    list_deduplicated_columns <- input_table[, columns_to_deduplicate] %>% array_tree(margin = 2) %>% purrr::map(~array_tree(.x))
    
    # map over each column, split the target element and add _[0-9]+
    list_deduplicated_columns_split <- purrr::map(.x = list_deduplicated_columns, .f = function(a1) {
      
      # map a subset each of the L2 (elements of a column)
      a1[indices_of_duplicates] <- purrr::map2(.x = a1[indices_of_duplicates], .y = repetition_numbers_of_duplicates, 
                  .f = ~rep(.x, times = .y) %>% unlist %>% paste(., 1:.y, sep = "_"))
      
      return(a1 %>% unlist)
      
    } )
    
    # tibblise
    tibble_deduplicated_columns_split <- list_deduplicated_columns_split %>% as_tibble
    
    # add back every row onto the split table
    for (dedupe_colname in columns_to_deduplicate) {
      
      split_table[, dedupe_colname] <- tibble_deduplicated_columns_split[, dedupe_colname]
      
    }
    
  }
  
  return(split_table)
  
}

```

### function to convert a vector of numeric positions into sets of simple ranges

```{r}

# USAGE:
# input_vector: vector of numerical values to convert to ranges
# metadata (optional): vector the same length as `input_vector` containing information such as chromosome.

convert_vector.of.positions_to_simple.ranges <- function(input_vector, metadata_vector) {
  
  # DEBUG ###
  # tibble_input_vector_and_metadata <- tibble_JUM_valid_phosphosites_with_overlap %>% 
  #   dplyr::select(chrom, genome_relative_positions_phosphosite) %>% 
  #   split_delimited_column_in_table(input_table = ., split = ",", target_colname = "genome_relative_positions_phosphosite")
  # input_vector <- tibble_input_vector_and_metadata$genome_relative_positions_phosphosite
  # metadata_vector <- tibble_input_vector_and_metadata$chrom
  
  # input_vector <- tibble_dbPTM_coords_and_chr$vec_all_genome_relative_coords_of_item
  # metadata_vector <- tibble_dbPTM_coords_and_chr$chr
  ###########
  
  # tibblise and soft-convert to numeric.
  # throw error if still not numeric.
  tibble_input_vector <- tibble::enframe(input_vector, value = "vec", name = NULL) %>% type_convert 
  
  if (tibble_input_vector$vec %>% data.class != "numeric") {
    stop("check if the input vector is numeric")
  } 
  
  # join the metadata
  tibble_input_vector_and_metadata <- dplyr::bind_cols(tibble_input_vector, metadata_vector %>% as_tibble)
  
  # subset and list-ify by metadata
  list_input_vector_subset_by_metadata <- tibble_input_vector_and_metadata %>% 
    dplyr::group_split(!!as.name(colnames(tibble_input_vector_and_metadata)[!colnames(tibble_input_vector_and_metadata) %in% "vec"]))
  
  # loop over the list
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  list_blockdata <- purrr::imap(.x = list_input_vector_subset_by_metadata, 
                               .f = function(a1, a2) {
                                 
                                 # DEBUG ###
                                 # a1 <- list_input_vector_subset_by_metadata[[1]]
                                 ###########
                                 
                                 cat("\ndoing: ", a2)
                                 
                                 # sort input vector in increasing order
                                 a1 <- a1 %>% dplyr::arrange(vec)
                                 
                                 tibble_n_n.plus.1 <- tibble("n" = a1$vec %>% head(n = length(a1$vec) - 1),
                                                             "n.plus.1" = a1$vec %>% .[-1]) %>% 
                                   add_column("difference" = .$`n.plus.1` - .$`n`) %>%
                                   dplyr::filter(difference != 0)
                                 
                                 ## if there are no gaps, then just take the genomic range as the start:end
                                 if (tibble_n_n.plus.1$difference %>% unique %>% length == 1 & tibble_n_n.plus.1$difference %>% .[1] == 1) {
                                   
                                   vec_blockCount <- 1
                                   vec_blockSizes <- length(a1$vec)
                                   vec_blockStarts <- dplyr::first(a1$vec)
                                   vec_blockEnds <- dplyr::last(a1$vec)
                                   
                                 } else if ((tibble_n_n.plus.1$difference %>% unique %>% length == 1 & tibble_n_n.plus.1$difference %>% .[1] == 1) != TRUE) {
                                   
                                   vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
                                   vec_blockStarts <- c(dplyr::first(a1$vec), 
                                                        tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
                                   vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                                                      dplyr::last(a1$vec))
                                   vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
                                   
                                 }
                                 
                                 return(list(
                                   "vec_blockCount" = vec_blockCount,
                                   "vec_blockStarts" = vec_blockStarts,
                                   "vec_blockEnds" = vec_blockEnds,
                                   "vec_blockSizes" = vec_blockSizes
                                 ))
                                 
                               } )
  
  # make the list of metadata
  list_metadata <- purrr::map(.x = list_input_vector_subset_by_metadata, .f = ~.x %>% dplyr::select(-vec) %>% unique)
  
  list_tibbles_start_end <- purrr::map2(.x = list_blockdata, 
                                        .y = list_metadata,
                                        .f = ~list("tibble" = tibble("start" = .x$vec_blockStarts,
                                                     "end" = .x$vec_blockEnds),
                                                   "metadata" = .y) %>% flatten %>% as_tibble)
  
  tibble_start_end_metadata <- list_tibbles_start_end %>% rbindlist %>% as_tibble
  
  # create tibble of start end count
  
}

```


## generating enrichment catalog of PFAM protein families

```{r}

# PROTEINFAMILY
polyA_RNAseq_background_pfam <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "pfam"), mart = ensembl_mart) %>% .[.$pfam != "",]

# obtain description(definition, DE) for each PFAM ID

PFAM_all_descriptions <- as.data.frame(PFAMDE[mappedkeys(PFAMDE)]) %>% setNames(., c("pfam", "family_description"))

polyA_RNAseq_background_pfam <- dplyr::left_join(polyA_RNAseq_background_pfam, PFAM_all_descriptions, by = "pfam")

polyA_RNAseq_background_pfam[, "family_description"] <- as.character(polyA_RNAseq_background_pfam[, "family_description"])

write.table(x = polyA_RNAseq_background_pfam, file = paste(results_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

# create list of gene UNIVERSE

reference_geneset_universe <- polyA_RNAseq_background_pfam$external_gene_name

# create list containing collections of genes under their according family descriptions

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam_2[, names(polyA_RNAseq_background_pfam_2) != "pfam"]

list_of_pfam_descriptions <- polyA_RNAseq_background_pfam_2$family_description %>% unique %>% as.list

list_of_pfam_gene_family_categories <- purrr::map(.x = list_of_pfam_descriptions, .f = ~as.list(polyA_RNAseq_background_pfam[polyA_RNAseq_background_pfam$family_description == .x, "external_gene_name"]))

names(list_of_pfam_gene_family_categories) <- list_of_pfam_descriptions

list_of_pfam_gene_family_categories <- list_of_pfam_gene_family_categories %>% purrr::map(~unlist(.x))

```

## import MBNL (HiTS-CLiP) and SRSF (FLASH-Seq) data and match with GTF information

### set directories

```{r}

clipseq_dir <- "/mnt/Tertiary/sharedfolder/isoform_usage_project/CLIPseq_files/"

FLASHseq_dir <- "/mnt/4tb_ironwolf/2019_FLASHseq/results/R_processing_results/"

```

### prepare geneset categories

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/geneset_srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
                                               
  "SRSF1 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR1-SRSF1.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF2 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR5-SRSF2.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF3 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR8-SRSF3.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF4 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR9-SRSF4.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF5 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR10-SRSF5.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF6 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR11-SRSF6.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF7 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR12-SRSF7.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF9 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR13-SRSF9.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF11 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR14-SRSF11.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)

```

### Import coordinate level CLIP-Seq data

```{r}

tibble_GSE111900_SRSF2_coord_info <- read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/GSE111900_srsf2_wt_hits.clip_coord_info.txt", sep = ""), header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

# split the genomic coords into chr start and end
tibble_GSE111900_SRSF2_coord_info_processed <- tibble_GSE111900_SRSF2_coord_info %>% 
  dplyr::mutate("chr" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):.*", replacement = "\\1"),
                "start" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):([^\\-]+)\\-.*", replacement = "\\2"),
                "end" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):([^\\-]+)\\-(.*)", replacement = "\\3")) %>%
  dplyr::filter(clip_FDR <= 0.01)

```

# Import files

## RNA expression section

### import expression tables of DE genes

```{r}

logCPM_OBseries_anysig_DEGs_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_2_eRNA/R_processing_results/edgeR_GLM_DEGs_logCPM.txt"

logCPM_OBseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_OBseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_OBseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_OBseries_anysig_DEGs <- dplyr::right_join(ENSG_to_genesymbol_DEGs, logCPM_OBseries_anysig_DEGs_import, by = "ensembl_gene_id") %>% average_counts_from_triplicate(., 2)

```

### define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

## JUM/PSI-Sigma section

### set global vars.

```{r}

vector_OBseries_timepoints_raw <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")
vector_OBseries_timepoints_edited <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

UNION_junc_coor_path <- "/mnt/4tb_ironwolf/PGNEXUS_OBseries/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

```

### Import differential/constitutive/all detected tables

```{r}

# JUM ###
# tibble_JUM_5x5_som_clustered <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/5x5_SOM_869_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_5x5_som_clustered <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/5x5_SOM_869_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_906_differential_VSRs_qvalue0.01_dPSI0.15_timeseries_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_869_differential_VSRs_qvalue0.01_dPSI0.15_timeseries_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_983_differential_VSRs_qvalue0.01_dPSI0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_983_differential_VSRs_qvalue0.01_dPSI0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_7855_constitutive_VSRs_dPSI_OB_diff_qvalue0.01_dPSI0.15_no_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_7913_constitutive_VSRs_dPSI_OB_diff_qvalue0.01_dPSI0.15_no_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# tibble_JUM_all_junctions_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_all_JUM_results_13137_VSRs_with_na_annotated.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_all_junctions_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_all_JUM_results_13137_VSRs_with_na_annotated.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# PSI-Sigma ###
# tibble_PSIsigma_5x5_som_clustered <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/5x5_SOM_1368_exons_LIV.PSI_OB_diff_any_DEXSeq_padj0.01_any_deltaPSI_greaterthan_15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_5x5_som_clustered <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/5x5_SOM_1368_exons_LIV.PSI_OB_diff_any_DEXSeq_padj0.01_any_deltaPSI_greaterthan_15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_1368LIVs_scaled.PSI_OB_diff.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_1368LIVs_scaled.PSI_OB_diff.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_table_of_all_constitutive_LIV7532_dpsi15_DEXSeq_padj0.01.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_table_of_all_constitutive_LIV7532_dpsi15_DEXSeq_padj0.01.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# tibble_PSIsigma_all_exons_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_DEXSeq_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_all_exons_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_DEXSeq_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

### Import gene ontology enrichment tables

```{r}

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/Top inf significantly over-represented GO terms for OB series dPSI_0.15_anyqvalue0.01_915_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/Top inf significantly over-represented families for OB series dPSI_0.15_anyqvalue0.01_915_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_GOterms_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_PFAM_families_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

### Import junction/exon ontology supporting info

```{r}

# JUM ###
# tibble_JUM_junction_ontology_supp_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# PSI-Sigma ###
# tibble_PSIsigma_exon_ontology_supp_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/R_processing_results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# JUM ###
tibble_JUM_junction_ontology_supp_info <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_supp_info <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_exon_ontology_unmatched_items <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_unmatched_exons_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

### Import junction/exon ontology tables

```{r}

# JUM ###
# tibble_JUM_junction_ontology_transcripts <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_junction_ontology_biomart <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_junction_ontology_PTM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# PSI-Sigma ###
# tibble_PSIsigma_exon_ontology_transcripts <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_exon_ontology_biomart <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_exon_ontology_PTMs <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# JUM ###
tibble_JUM_junction_ontology_transcripts <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_biomart <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_PTMs <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_JUM_junction_ontology_biomart_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/tally_overlapping_interpro_domains_differential_junctions_0.15_qvalue0.01_468_VSRs_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_JUM" = "genes", "tally_JUM" = "tally")
tibble_JUM_junction_ontology_PTMs_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/tally_overlapping_PTMs_differential_0.15_qvalue0.01_468_VSRs_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_JUM" = "tally")

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_transcripts <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_biomart <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_PTMs <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_PSIsigma_exon_ontology_biomart_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/tally_overlapping_interpro_domains_differential_exons_15_DEXSeq_padj0.01_617_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_PSIsigma" = "genes", "tally_PSIsigma" = "tally")
tibble_PSIsigma_exon_ontology_PTMs_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/tally_overlapping_PTMs_differential_dpsi15_DEXSeq_padj0.01_617_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_PSIsigma" = "tally")

```

## scRNA-Seq section

### Import Sierra DTU test results

```{r}

# Cluster-wise, simplified
tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_clusterwise_all_simplified <- tibble_sierra_DTU_clusterwise_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

# Pair-wise between clusters, simplified
tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_pairwise_clusters_all_simplified <- tibble_sierra_DTU_pairwise_clusters_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

```

## Ago2 iCLIP dataset

```{r}

tibble_ago2_iclip_binding_sites <- read.delim("/mnt/4tb_ironwolf/miRNA_hMSC_TERT_OB_diff/iCLIP.hg38.miRNA_targets_MSC_diff_iCLIP_binding_sites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% 
  as_tibble %>% 
  dplyr::filter(chrom != "") %>%
  dplyr::mutate_at(.vars = "chrom", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} )

# split the iclip table by chromosome
list_ago2_iclip_binding_sites_by_chr <- tibble_ago2_iclip_binding_sites %>% 
  dplyr::group_split(chrom) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chrom %>% unique) %>% unlist)
# generate list of vectors of ago2 iCLIP binding site genome coords.
list_of_vectors_ago2_iclip_binding_site_genome_coords <- purrr::map(.x = list_ago2_iclip_binding_sites_by_chr,
                                                                    .f = ~purrr::map2(.x = .x$start,
                                                                                      .y = .x$stop,
                                                                                      .f = ~.x:.y)
)

```


## Proteome section

### Import all the non-homolog and non-superfamily entries from Interpro

```{r}

tibble_non_family_interpro_entries <- c("interpro_active.site_entries.tsv", "interpro_binding.site_entries.tsv", "interpro_conserved.site_entries.tsv", "interpro_domain_entries.tsv", "interpro_PTM_entries.tsv", "interpro_repeat_entries.tsv") %>% 
  purrr::map(.f = ~read.delim(paste(shared_dir, .x, sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble) %>% rbindlist %>% as_tibble

```

### Import the validated junc.exons as well as the validated phosphosites

```{r}

# tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_2020.PO4_valid_phosphosites <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_unconfirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# we have to use all the non-validating PSI-Sigma exons because although they don't validate the RNA exon, they validate any coding regions contained in the differential exon.
tibble_2020.PO4_2012.proteome_valid_junc.exons_coding <- dplyr::bind_rows(
  tibble_2020.PO4_2012.proteome_valid_junc.exons[grep(x = tibble_2020.PO4_2012.proteome_valid_junc.exons$Leading.razor.protein, pattern = "JUM", ignore.case = TRUE), ],
  tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons[grep(x = tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons$Leading.razor.protein, pattern = "PSISigma", ignore.case = TRUE), ]
)

tibble_2020.PO4_valid_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble


```

#### Import the FASTA supplementary information

```{r}

tibble_fasta_supp_info_exons_differential_ensembl <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_differential_strawberry <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_exons_constitutive_ensembl <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_constitutive_strawberry <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_junctions_differential <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_differential_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_junctions_constitutive <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_constitutive_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

# bind rows
tibble_fasta_supp_info_junctions <- dplyr::bind_rows(
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive
                                           )

tibble_fasta_supp_info_exons <- dplyr::bind_rows(
  tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry
                                           )

tibble_fasta_supp_info <- dplyr::bind_rows(
  tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry,
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive
                                           )

```

## SNP and disease section

### import GWAS catalog

```{r}

tibble_ebi_gwas_catalog <- read_tsv(file = "/mnt/4tb_ironwolf/eQTL_catalogue/gwas_catalog_v1.0.2-associations_e98_r2020-05-03.tsv", col_types = cols(.default = "c")) %>% 
  type_convert %>%
  dplyr::filter(CHR_ID %>% is.na == FALSE)

## Join the GWAS catalog with ensembl variation database

## Memo: we NEED this because we need to retrieve calculated consequences

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog$CHR_ID %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a2" = tibble_ebi_gwas_catalog$CHR_POS %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a3" = tibble_ebi_gwas_catalog$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a4" = tibble_ebi_gwas_catalog$SNPS %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a5" = tibble_ebi_gwas_catalog$CONTEXT %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE)
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog[setdiff(1:nrow(tibble_ebi_gwas_catalog), grep(x = paste(tibble_ebi_gwas_catalog$CHR_POS, tibble_ebi_gwas_catalog$`STRONGEST SNP-RISK ALLELE`, tibble_ebi_gwas_catalog$SNPS, tibble_ebi_gwas_catalog$CONTEXT), pattern = "\\;")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog[setdiff(1:nrow(tibble_ebi_gwas_catalog), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\;"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("CHR_ID", "CHR_POS", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\;") %>% dplyr::mutate_all(as.character))

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a2" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a3" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a4" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE)
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "\\,")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\,"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\,") %>% dplyr::mutate_all(as.character))

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a2" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a3" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a4" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE)
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE) %>% unlist %>% which


tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "\\_")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\_"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\_") %>% dplyr::mutate_all(as.character))

# finally split by "x"'s due to gene interaction entries
rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$CHR_ID %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a2" = tibble_ebi_gwas_catalog_deduped$CHR_POS %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a3" = tibble_ebi_gwas_catalog_deduped$`REGION` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a4" = tibble_ebi_gwas_catalog_deduped$`REPORTED GENE(S)` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a5" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a6" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a7" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE),
  "a8" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE)
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "x")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "x"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("CHR_ID", "CHR_POS", "REGION", "REPORTED GENE(S)", "MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "x") %>% dplyr::mutate_all(as.character))

# list-ify by chromosome
list_tibble_ebi_gwas_catalog_by_chr <- tibble_ebi_gwas_catalog_deduped %>% 
  dplyr::group_split(CHR_ID) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$`CHR_ID` %>% unique) %>% unlist)

```

# JUM and PSI-Sigma analysis

## Calculate the number of junction/exons found in common

### Calculate intersections

STRATEGY: use one table to look up other table. one-directional evidence is required and sufficient for intersection.

#### FUNCTION TO CONVERT JUM AS_EVENT_ID TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

JUM_AS.event.ID_to_chr_strand_start_end <- function(tibble) {
  
  vec_AS.event.ID_unique <- tibble$AS_event_ID %>% unique
  
  vec_chr <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\2")
  vec_start <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\3")
  vec_end <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\5")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
  
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end))
  
}

```

#### FUNCTION TO CONVERT PSI-SIGMA DIFF_EXON_COORDS TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

PSIsigma_diff.exon.coords_to_chr_strand_start_end <- function(tibble) {
  
  vec_event.region.coords <- tibble$event_region_coords
  
  vec_chr <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- tibble$matched_strand
  vec_start <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\2")
  vec_end <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\3")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
    
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end) %>% unique)
  
}

```

#### create generic function to do this job.

```{r}

calculate_intersections_from_chr_strand_start_end <- function(tibble_1, tibble_2, tibble_1_tolerance_left, tibble_1_tolerance_right) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na
  # tibble_1_tolerance_left <- 2
  # tibble_1_tolerance_right <- 2
  ###########
  
  tibble_1 <<- tibble_1
  tibble_2 <<- tibble_2
  
  # list-ify tibble_1
  list_tibble_1_array.tree <- tibble_1 %>% array_tree
  # set L1 names as identifier names
  names(list_tibble_1_array.tree) <- tibble_1$identifier
  
  # match each element of tibble_1 to tibble_2 and see if there is a valid subset found.
  list_tibble_1_to_2_matches <- future_map(.x = list_tibble_1_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_tibble_1_array.tree[[3]]
    ###########
    
    subset <- tibble_2[tibble_2$chr == .x$chr %>% paste %>% trimws, ] %>% 
      .[.$strand == .x$strand %>% paste %>% trimws, ] %>% 
      .[(.$start < (.x$end %>% paste %>% trimws %>% as.numeric) + tibble_1_tolerance_right) & (.$end > (.x$start %>% paste %>% trimws %>% as.numeric) - tibble_1_tolerance_left), ]
    
    if (nrow(subset) == 0) {
      return("no_overlap")
    } else {
      return(subset)
    }
    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_2", "tibble_1_tolerance_left", "tibble_1_tolerance_right")))
  
  # extract the list indices which had valid overlap
  vector_list.indices_with_valid_overlap <- list_tibble_1_to_2_matches %>% purrr::map(~all(.x == "no_overlap") == FALSE) %>% unlist %>% which
  # return aggregate number of overlap
  number_of_entries_with_valid_overlap <- vector_list.indices_with_valid_overlap %>% length
  # return summary list of matching table entries
  list_overlapped_table_entries <- future_imap(.x = list_tibble_1_to_2_matches[vector_list.indices_with_valid_overlap], .f = ~list("tibble_1_entry" = tibble_1[tibble_1$identifier == .y, ],
                                                                                                                                   "tibble_2_entry" = .x), .progress = TRUE, .options = future_options(globals = c("tibble_1")))
  
  return(list("number_of_entries_tibble_1" = nrow(tibble_1),
              "number_of_entries_tibble_2" = nrow(tibble_2),
              "number_of_common_entries" = number_of_entries_with_valid_overlap,
              "detailed_result" = list_overlapped_table_entries))
  
}

```

#### run the intersections

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na%>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# constitutive JUM vs. constitutive PSI-Sigma
JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM constitutive (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma constitutive, (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

```

#### repeat the intersections with only genes in common

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_all_junctions_with_na %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_all_junctions_with_na %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# constitutive JUM vs. constitutive PSI-Sigma
JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na, tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% dplyr::rename("Gene" = "matched_gene_names"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na, tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::select(-matched_gene_names) %>% dplyr::rename("matched_gene_names" = "Gene"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM constitutive (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma constitutive, (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

```

### Calculate gene-level spliceome intersections with expression

```{r}

# solo diff. spliced/expressed genes
cat(magenta("\nRSEM/EdgeR differential genes: ", logCPM_OBseries_anysig_DEGs$external_gene_name %>% unique %>% length))
cat(magenta("\nJUM differential genes: ", tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% length))
cat(magenta("\nPSI-Sigma differential genes: ", tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% length))

# JUM diff spliced vs. diff. expression
cat(magenta("\nJUM differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene) %>% unique %>% length))

# PSI-Sigma diff spliced vs. diff. expression
cat(magenta("\nPSI-Sigma differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# JUM diff spliced vs. PSI-Sigma diff spliced
cat(magenta("\nJUM differential genes vs. PSI-Sigma differential genes: ", intersect(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# fetch list of ALWAYS differentially spliced genes vs. ALWAYS constitutively spliced genes
vector_genes_differentially_spliced <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique
vector_genes_constitutively_spliced <- c(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$Gene, tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique

vector_genes_both_diff_and_cons_spliced <- intersect(vector_genes_differentially_spliced, vector_genes_constitutively_spliced)
cat("vector_genes_both_diff_and_cons_spliced:", vector_genes_both_diff_and_cons_spliced %>% length)

vector_genes_differentially_spliced_only <- setdiff(vector_genes_differentially_spliced, vector_genes_both_diff_and_cons_spliced) %>% mixedsort
cat("vector_genes_differentially_spliced_only:", vector_genes_differentially_spliced_only %>% length)
vector_genes_constitutively_spliced_only <- setdiff(vector_genes_constitutively_spliced, vector_genes_both_diff_and_cons_spliced) %>% mixedsort
cat("vector_genes_constitutively_spliced_only:", vector_genes_constitutively_spliced_only %>% length)

```

## determine the genes in common per enrichment

### FUNCTION TO LOOK FOR OVERLAPS IN EACH GO-TERM BETWEEN TWO TABLES (GOhyperGall)

```{r}

extract_common_GOTerms_GOhyperGall <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: GOID, NodeSize, Term, Ont
  colnames(tibble_1)[c(3, 4, 5, 8)] <- paste(colnames(tibble_1)[c(3, 4, 5, 8)], "_1", sep = "")
  colnames(tibble_2)[c(3, 4, 5, 8)] <- paste(colnames(tibble_2)[c(3, 4, 5, 8)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("GOID", "NodeSize", "Term", "Ont"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$SampleKeys_1)), which(is.na(joined_tibble$SampleKeys_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
  # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$SampleKeys_1, .y = joined_tibble$SampleKeys_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### FUNCTION TO LOOK FOR OVERLAPS IN EACH ENRICHMENT BETWEEN TWO TABLES (bc3net::enrichment())

```{r}

extract_common_GOTerms_bc3net <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: c("TermID", "all")
  colnames(tibble_1)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_1)[c(2, 3, 4, 5, 6)], "_1", sep = "")
  colnames(tibble_2)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_2)[c(2, 3, 4, 5, 6)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("TermID"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$genes_contained_1)), which(is.na(joined_tibble$genes_contained_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
    # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$genes_contained_1, .y = joined_tibble$genes_contained_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### calculate intersections

```{r}

tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <-
  extract_common_GOTerms_GOhyperGall(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO, 
                                     tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO)

write.table(tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO, 
            paste(results_dir, "intersection_GOTerm_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <-
  extract_common_GOTerms_bc3net(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM, 
                                tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM)

write.table(tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM, 
            paste(results_dir, "intersection_PFAM_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

## Do GO enrichment (anysig) on both combined.

```{r}

load(paste(shared_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

### hypergeometric test for GO terms

```{r}

# create vector of differential genes
vector_differential_genes_anysig_with_na <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, 
                                              tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% 
  strsplit(split = ",") %>% unlist %>% unique

# count number of differential genes
number.of.genes_differential_anysig_with_na <- vector_differential_genes_anysig_with_na %>% length

cat("\n", number.of.genes_differential_anysig_with_na, "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation")

# create list of GO categories
list_GO_categories <- c("MF", "BP", "CC") %>% array_tree

# map GO test
list_of_GO_test_tibbles_anysig_with_na_raw <- purrr::map(.x = list_GO_categories, .f = ~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = vector_differential_genes_anysig_with_na, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% type_convert) %>% set_names(list_GO_categories)

# filter out the top ~30 most significant GO terms for each node
list_of_GO_test_tibbles_anysig_with_na_top.hits <- purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_raw, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 900) %>% dplyr::filter(NodeSize < 1500) %>% dplyr::mutate_at(.vars = "Term", .funs = function(x) {stringr::str_trunc(string = x, side = "right", width = 78) %>% return}))

# print out the top hits of the GO enrichment
purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_top.hits, .f = ~.x %>% print)

# collapse into a long tibble for plot
long_tibble_GO_test_anysig_with_na_top.hits <- list_of_GO_test_tibbles_anysig_with_na_top.hits %>% rbindlist %>% as_tibble

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(long_tibble_GO_test_anysig_with_na_top.hits, aes(x = reorder(Term, -Phyper), y = -log10(Phyper))) +
  geom_col(aes(fill = SampleMatch)) +
  scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = 1, aesthetics = "fill", na.value = "yellow") +
  geom_hline(yintercept = -log10(0.05), lty = 2) +
  coord_flip() +
  facet_wrap(Ont ~ ., ncol = 3, scales = "free_y") +
  ggtitle(paste("Top 900 significantly over-represented GO terms for OB series for JUM and PSI-Sigma combined")) +
  xlab("GO term") +
  ylab(expression(log["10"](P))) +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype="solid", colour ="black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) 

# write table of top 30 results
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of every enrichment
write.table(x = list_of_GO_test_tibbles_anysig_with_na_raw %>% purrr::map(~dplyr::arrange(.x, Phyper)) %>% rbindlist, file = paste(results_dir, "top_inf_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of geneset
write.table(x = vector_differential_genes_anysig_with_na, file = paste(results_dir, "geneset_OBseries_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
  
```

## plot the interpro and PTM results from JUM and PSI-Sigma together 

### interpro

```{r}

tibble_combined_biomart_RNAlevel <- dplyr::full_join(tibble_JUM_junction_ontology_biomart_plots, tibble_PSIsigma_exon_ontology_biomart_plots, by = c("interpro_id", "interpro_description", "interpro_identifier")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  na.omit %>%
  tail(n = 10) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("interpro_id", "interpro_description", "interpro_identifier"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_biomart_RNAlevel, aes(x = `interpro_description`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_biomart_RNAlevel$tally %>% max * 1.3)) +
  ggtitle("Top 10 interpro domains, JUM and PSI-Sigma, differential") +
  xlab("Interpro domain") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_biomart_RNAlevel_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_biomart_RNAlevel_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

```

### PTMs

```{r}

tibble_combined_PTMs_RNAlevel <- dplyr::full_join(tibble_JUM_junction_ontology_PTMs_plots, tibble_PSIsigma_exon_ontology_PTMs_plots, by = c("PTM_type")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("PTM_type"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_PTMs_RNAlevel, aes(x = `PTM_type`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_PTMs_RNAlevel$tally %>% max(na.rm = TRUE) * 1.3)) +
  ggtitle("Top 10 PTMs, JUM and PSI-Sigma, differential") +
  xlab("PTM type") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 6, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 6, units = "cm")

```

## find out why JUM and PSI-Sigma's PTM matching results are different

```{r}

# join the PTM results onto the differential tables
tibble_JUM_differential_PTM_ontology_with_info <- dplyr::left_join(tibble_JUM_junction_ontology_PTMs, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, by = c("AS_event_ID", "splicemode")) %>% dplyr::distinct(AS_event_ID, splicemode, .keep_all = TRUE)
tibble_PSIsigma_differential_PTM_ontology_with_info <- dplyr::left_join(tibble_PSIsigma_exon_ontology_PTMs, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, by = c("diff_exon_coords", "splicemode")) %>% dplyr::distinct(diff_exon_coords, splicemode, .keep_all = TRUE)

```

## JUM/PSI-Sigma and Ago2 iCLIP

### determine gene-level overlap between differentially spliced genes and Ago2 iCLIP

```{r}

# JUM
## convert transcript_ids to gene_stable_id
# vector_JUM_gene_stable_ids <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$matched_ref_transcript_names %>% strsplit(split = "\\;") %>% purrr::map(~.x %>% type.convert %>% na.omit) %>% future_map(.f = ~tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$transcript_stable_ID %in% .x), "gene_stable_ID"] %>% unlist, .progress = TRUE) %>% unlist

vector_JUM_gene_names <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique

vector_JUM_gene_stable_ids <- tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$gene_name %in% vector_JUM_gene_names), "gene_stable_ID"] %>% unlist %>% unique


tibble_ago2_iclip_binding_sites_JUM_genes <- tibble_ago2_iclip_binding_sites %>% dplyr::filter(`3'UTR` %in% vector_JUM_gene_names |
                                                                                                 `5'UTR` %in% vector_JUM_gene_names |
                                                                                                 `CDS` %in% vector_JUM_gene_names |
                                                                                                 `antisense_gene` %in% vector_JUM_gene_names |
                                                                                                 `lncRNA` %in% vector_JUM_gene_stable_ids)

# PSI-Sigma
## convert transcript_ids to gene_stable_id
vector_PSIsigma_gene_names <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% strsplit(split = "\\,") %>% unlist %>% type.convert %>% unique

vector_PSIsigma_gene_stable_ids <- tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$gene_name %in% vector_PSIsigma_gene_names), "gene_stable_ID"] %>% unlist %>% unique

tibble_ago2_iclip_binding_sites_PSIsigma_genes <- tibble_ago2_iclip_binding_sites %>% dplyr::filter(`3'UTR` %in% vector_PSIsigma_gene_names |
                                                                                                 `5'UTR` %in% vector_PSIsigma_gene_names |
                                                                                                 `CDS` %in% vector_PSIsigma_gene_names |
                                                                                                 `antisense_gene` %in% vector_PSIsigma_gene_names |
                                                                                                 `lncRNA` %in% vector_PSIsigma_gene_stable_ids)

```

### determine if there's any VSR-level overlap between differential regions/exons and Ago2 iCLIP

```{r}

# JUM
## create list of vectors of differential positions (genomic coords)
list_of_vectors_JUM_differential_exon_positions <- tibble_JUM_junction_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_JUM <- future_map2(.x = list_of_vectors_JUM_differential_exon_positions,
                                                                      .y = tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree,
                                                                      .f = function(a1, a2) {
                                                                        
                                                                        # DEBUG ###
                                                                        # a1 <- list_of_vectors_JUM_differential_exon_positions[[1]]
                                                                        # a2 <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree %>% .[[1]]
                                                                        ###########
                                                                        
                                                                        # get chromosome
                                                                        current_chr <- gsub(x = a2$AS_event_ID, pattern = "^([^\\_]+)\\_.*", replacement = "\\1")
                                                                        
                                                                        # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                        vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_ago2_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                        
                                                                        # retrieve iCLIP entries based on logical index
                                                                        tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                        
                                                                        return(purrr::splice(a2,
                                                                                             "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                      }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_JUM_pruned <- list_matched_iCLIP_entries_per_differential_region_JUM %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_JUM_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_JUM_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("AS_event_ID", "splicemode", "Gene")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

# write table
write.table(x = tibble_differential_region_JUM_with_iclip_ago2, file = paste(results_dir, "tibble_differential_region_JUM_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# PSI-Sigma
## create list of vectors of differential positions (genomic coords)
list_of_vectors_PSIsigma_differential_exon_positions <- tibble_PSIsigma_exon_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_PSIsigma <- future_map2(.x = list_of_vectors_PSIsigma_differential_exon_positions,
                                                                           .y = tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")] %>% array_tree,
                                                                           .f = function(a1, a2) {
                                                                             
                                                                             # DEBUG ###
                                                                             # a1 <- list_of_vectors_PSIsigma_differential_exon_positions[[1]]
                                                                             # a2 <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")] %>% array_tree %>% .[[1]]
                                                                             ###########
                                                                             
                                                                             # get chromosome
                                                                             current_chr <- gsub(x = a2$diff_exon_coords, pattern = "^([^\\:]+)\\:.*", replacement = "\\1")
                                                                             
                                                                             # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                             vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_ago2_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                             
                                                                             # retrieve iCLIP entries based on logical index
                                                                             tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                             
                                                                             return(purrr::splice(a2,
                                                                                                  "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                           }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_PSIsigma_pruned <- list_matched_iCLIP_entries_per_differential_region_PSIsigma %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_PSIsigma_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_PSIsigma_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

# write table
write.table(x = tibble_differential_region_PSIsigma_with_iclip_ago2, file = paste(results_dir, "tibble_differential_region_PSIsigma_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Draw a consensus SOM which merges JUM and PSI-Sigma together.

### Tally up the number of repeated VSRs per gene.

```{r}

tibble_exon_tally_per_gene_PSIsigma <- tibble_PSIsigma_5x5_som_clustered %>% 
  split_delimited_column_in_table(input_table = ., target_colname = "matched_gene_names", split = ",") %>%
  dplyr::distinct(matched_gene_names, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(event_region_coords, .keep_all = TRUE) %>%
  dplyr::group_by(matched_gene_names) %>% 
  dplyr::summarise("PSIsigma_tally" = n()) %>%
  dplyr::arrange(desc(PSIsigma_tally)) %>%
  dplyr::rename("Gene" = "matched_gene_names")

ggplot(data = tibble_exon_tally_per_gene_PSIsigma %>% na.omit, aes(x = PSIsigma_tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("PSI-Sigma tally, diff_exon_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

tibble_AS_event_ID_tally_per_gene_JUM <- tibble_JUM_5x5_som_clustered %>% 
  dplyr::distinct(Gene, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(AS_event_ID, .keep_all = TRUE) %>%
  dplyr::group_by(Gene) %>% 
  dplyr::summarise("JUM_tally" = n()) %>%
  dplyr::arrange(desc(JUM_tally))

ggplot(data = tibble_AS_event_ID_tally_per_gene_JUM %>% na.omit, aes(x = JUM_tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("JUM tally, AS_event_ID per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

# merge the two tallies together for co-plotting
tibble_AS_event_ID_tally_per_gene_combined <- dplyr::full_join(tibble_AS_event_ID_tally_per_gene_JUM, tibble_exon_tally_per_gene_PSIsigma, by = "Gene")

tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")][is.na(tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")])] <- 0

# melt into long form for combined ggplot
long_tibble_AS_event_ID_tally_per_gene_combined <- tibble_AS_event_ID_tally_per_gene_combined %>%
  na.omit %>%
  reshape2::melt(id.vars = "Gene", value.name = "tally", variable.name = "tool") %>% as_tibble

long_tibble_AS_event_ID_tally_per_gene_combined[, "tally"] <- long_tibble_AS_event_ID_tally_per_gene_combined$tally %>% as.character

write.table(x = long_tibble_AS_event_ID_tally_per_gene_combined, file = paste(results_dir, "long_tibble_AS_event_ID_tally_per_gene_combined.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# create tally frequency
long_tibble_AS_event_ID_tally_per_gene_combined_tally <- long_tibble_AS_event_ID_tally_per_gene_combined %>% 
  dplyr::group_by(tool, tally) %>% 
  dplyr::summarise("frequency" = n()) %>% 
  # tidyr complete for consistent bar width
  tidyr::complete(tool, tally)

# combined tally plot
ggplot(data = long_tibble_AS_event_ID_tally_per_gene_combined_tally, aes(x = tally, y = frequency, fill = tool)) +
  geom_bar(stat = "identity", position = position_dodge(width = 1)) +
  geom_text(stat = "identity", aes(label = frequency), position = position_dodge(width = 1), angle = 90, hjust = -0.1) +
  scale_x_discrete(breaks = c(1 : max(long_tibble_AS_event_ID_tally_per_gene_combined$tally)) %>% as.character, limits = c(1 : max(long_tibble_AS_event_ID_tally_per_gene_combined$tally)) %>% as.character) +
  scale_fill_manual(breaks = c("JUM_tally", "PSIsigma_tally"), labels = c("JUM", "PSI-Sigma"), values = c("purple3", "firebrick4")) +
  ylim(c(0, 900)) +
  ggtitle("Combined tally, AS_event_ID/event_region_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_highest_LSVs_per_gene_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 6, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_highest_LSVs_per_gene_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 6, units = "cm")

```

### preprocessing of tables in preparation for mixing

```{r}

# create unique ID that can be traced.
tibble_PSIsigma_scaled_PSI_timeseries_wide_processed <- tibble_PSIsigma_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("PSIsigma", .$matched_gene_names, .$diff_exon_coords, .$splicemode, .$matched_strand, sep = "|")) %>%
  dplyr::select(id, vector_OBseries_timepoints_edited)

tibble_JUM_scaled_PSI_timeseries_wide_processed <- tibble_JUM_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("JUM", .$Gene, .$AS_event_ID, .$sub_junction_start_coor, .$sub_junction_end_coor, .$splicemode, sep = "|")) %>%
  dplyr::select(id, c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d")) %>%
  dplyr::rename("1d" = "24h")

# join
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- dplyr::bind_rows(tibble_PSIsigma_scaled_PSI_timeseries_wide_processed, tibble_JUM_scaled_PSI_timeseries_wide_processed)

# rescale values
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### Skim off the top and bottom most included exons/LSVs to get biomarkers at each timepoint.

```{r}

# melt into long form
long_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% reshape2::melt(id.vars = "id", variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# subset by timepoint
list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint <- purrr::map(.x = long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint %>% unique,
                                                                               .f = ~long_tibble_JUM_PSIsigma_PSI_timeseries_merged[long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint == .x, ])

# take the items with scaled PSI greater/less than +/-1.
# rbind and tibblise
list_biomarkers_JUM_PSIsigma_per_timepoint <- list(
  "inclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value >= 1)),
  "exclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value <= -1))
) %>% purrr::map(~rbindlist(.x) %>% as_tibble)

# create tally of counts to determine which markers are unique
# splice in unique counts
list_biomarkers_JUM_PSIsigma_per_timepoint <- list_biomarkers_JUM_PSIsigma_per_timepoint %>% 
  purrr::map(~dplyr::left_join(.x, .x %>% dplyr::group_by(id) %>% dplyr::summarise("uniqueness_tally" = n()))) %>%
  purrr::splice(
    "unique_inclusion" = .$inclusion %>% dplyr::filter(uniqueness_tally == 1),
    "unique_exclusion" = .$exclusion %>% dplyr::filter(uniqueness_tally == 1)
  )

# save the list
save(list_biomarkers_JUM_PSIsigma_per_timepoint, file = paste(results_dir, "list_biomarkers_JUM_PSIsigma_per_timepoint.Rlist", sep = ""))

```

### TRADITIONAL SOM

#### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# remove na
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% add_column("id" = rownames(.)) %>% na.omit %>% .$id, ]

somdata_5_by_5_OBseries <- som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries <- cbind(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, c("id", vector_OBseries_timepoints_edited)], cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("id", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### THE GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of PSI values for JUM and PSI-Sigma")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Scaled PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("wide_tibble_JUM_PSIsigma_PSI_timeseries_merged", "dplyr", "som")) ) %>% as.data.frame

wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, "id"] <- paste(1:nrow(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged), wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id, sep = "_")

# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

rm(list_matchtest_som_sweep_byisoform)

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 32)
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for clustering by PSI\nOB spliceome: JUM and PSI-Sigma", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED LEVELS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combined_.*seedeverynode.tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1"), pattern = "\\|", n = 6) %>% as_tibble %>% setNames(c("S1", "S2", "S3", "S4", "S5", "S6")),
                                                             wide_tibble_consensus_clusters_MQ_ratios) %>%
  # preallocate columns
  add_column("method" = "NA",
             "gene" = "NA", 
             "item_id" = "NA", 
             "category" = "NA", 
             "sub_junction_start" = "NA",
             "sub_junction_end" = "NA", 
             "matched_strand" = "NA", .after = "S6")

# shuffle the ids around
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S1"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S2"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S2"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S1"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S4"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S6"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S3"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_start"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_end"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "matched_strand"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios <- wide_tibble_consensus_clusters_MQ_ratios %>%
  dplyr::select(-S1, -S2, -S3, -S4, -S5, -S6) %>% 
  type_convert %>%
  dplyr::mutate_at(.vars = "cluster", as.character)

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

cat("\nnumber of unique items originally: ", gsub(x = wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id, pattern = "^[^_]+_(.*)", replacement = "\\1") %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1") %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
vector_items_chucked_out <- setdiff(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id %>% unique, wide_tibble_consensus_clusters_MQ_ratios$id %>% unique)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("method", "gene", "item_id", "category", "sub_junction_start", "sub_junction_end", "matched_strand", "cluster", "id"), variable.name = "timepoint", value.name = "scaled_PSI") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_PSI" = mean(scaled_PSI))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_PSI, group = paste(id)), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_PSI, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI\n",
                "JUM and PSI-Sigma\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled MQ ratios") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster, separate and summed PSI

#### preparation of separate data frames containing gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot, separate PSI
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(.x = list_of_genesets_by_cluster, .y = names(list_of_genesets_by_cluster), .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column("cluster" = .y), .progress = TRUE)

# tibble of everything PFAM results
tibble_consensus.SOM_family.enrichment_clusterwise <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

# save PFAM family tables (all)
write.table(x = tibble_consensus.SOM_family.enrichment_clusterwise, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combined_JUM_PSIsigma_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Consensus SOM: Expression co-clustering with JUM and PSI-Sigma

### extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

# reorder the columns to make them chronological

logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_OB_ud_avg", "logCPM_BM_MSC_to_OB_6h_avg", "logCPM_BM_MSC_to_OB_12h_avg", "logCPM_BM_MSC_to_OB_24h_avg", "logCPM_BM_MSC_to_OB_3d_avg", "logCPM_BM_MSC_to_OB_6d_avg", "logCPM_BM_MSC_to_OB_9d_avg", "logCPM_BM_MSC_to_OB_12d_avg")]

colnames(logCPM_OBseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

# subset CPM table by biological role

  # RBPs
column_RBP_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "RNA binding" | .$name_1006 == "spliceosomal complex", "ensembl_gene_id"]

logCPM_OBseries_RBP <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_RBP_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # lncRNA
column_lncRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("lncRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble

logCPM_OBseries_lncRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_lncRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # snRNA
column_snRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("snRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble %>% mutate_if(is.logical, as.character)

logCPM_OBseries_snRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_snRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # all TF complex 
column_TFcomplex_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "transcription factor complex", "ensembl_gene_id"]

logCPM_OBseries_TFcomplex <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_TFcomplex_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_OBseries_subset <- dplyr::bind_rows(logCPM_OBseries_RBP, logCPM_OBseries_lncRNA, logCPM_OBseries_snRNA, logCPM_OBseries_TFcomplex)

# get rid of ENSG id
logCPM_OBseries_subset <- logCPM_OBseries_subset[, -1]

# rename column before next join

colnames(logCPM_OBseries_subset)[1] <- "matched_gene_names"

# add id column and get rid of the rest
logCPM_OBseries_subset <- logCPM_OBseries_subset %>% 
  add_column("id" = paste(.$matched_gene_names, .$splicemode, .$diff_exon_coords, sep = "|")) %>%
  .[, c("id", vector_OBseries_timepoints_raw)] %>%
  setNames(c("id", vector_OBseries_timepoints_edited))

# combine logCPM and PSI values
tibble_combinedexpr_logCPM_PSI_unscaled <- dplyr::bind_rows(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged, logCPM_OBseries_subset)

tibble_combinedexpr_logCPM_PSI_scaled <- tibble_combinedexpr_logCPM_PSI_unscaled

# scale values
tibble_combinedexpr_logCPM_PSI_scaled[, vector_OBseries_timepoints_edited] <- tibble_combinedexpr_logCPM_PSI_scaled[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(tibble_combinedexpr_logCPM_PSI_scaled %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_combinedexpr_logCPM_PSI_scaled", "dplyr", "genescale", "som")) ) %>% as.data.frame

# use "id" column as rownames
tibble_combinedexpr_logCPM_PSI_scaled[, "id"] <- paste(1:nrow(tibble_combinedexpr_logCPM_PSI_scaled), tibble_combinedexpr_logCPM_PSI_scaled$id, sep = "_")

rownames(wide_table_som_sweep_clusters) <- tibble_combinedexpr_logCPM_PSI_scaled$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

rm(list_matchtest_som_sweep_byisoform)

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- tibble_combinedexpr_logCPM_PSI_scaled$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 16)
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_combinedexpr_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combinedexpr_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_consensus_matrix_reordered, file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_reordered.tibble", sep = ""))
load(file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_reordered.tibble", sep = ""))

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_long.tibble", sep = ""))
load(file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for co-clustering by PSI and logCPM\nJUM and PSI-Sigma + RSEM/EdgeR", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_combinedexpr_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_combinedexpr_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combinedexpr_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combinedexpr_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED MQ RATIOS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combinedexpr_.*seedeverynode.tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, tibble_combinedexpr_logCPM_PSI_scaled %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

cat("\nnumber of unique items originally: ", tibble_combinedexpr_logCPM_PSI_scaled$id %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
tibble_items_chucked_out <- dplyr::anti_join(tibble_combinedexpr_logCPM_PSI_scaled$id %>% unique %>% tibble::enframe(name = NULL, value = "id"),
                                             wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% tibble::enframe(name = NULL, value = "id"), by = "id")

# write the items that got chucked out
write.table(x = tibble_items_chucked_out, file = paste(results_dir, "consensus_combinedexpr_items_chucked_out.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# remove TSS from PSI-Sigma ids
wide_tibble_consensus_clusters_MQ_ratios[, "id"] <- gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "TSS\\|", replacement = "")
# i fucked up the delimiting for expression
wide_tibble_consensus_clusters_MQ_ratios[, "id"] <- gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "_ENSG", replacement = "\\|ENSG")

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1"), pattern = "\\|", n = 6) %>% as_tibble %>% setNames(c("S1", "S2", "S3", "S4", "S5", "S6")),
                                                             wide_tibble_consensus_clusters_MQ_ratios) %>%
  # preallocate columns
  add_column("method" = "NA",
             "gene" = "NA", 
             "item_id" = "NA", 
             "category" = "NA", 
             "sub_junction_start" = "NA",
             "sub_junction_end" = "NA", 
             "matched_strand" = "NA", .after = "S6")

# shuffle the ids around
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S1"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S2"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S2"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S1"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S4"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S6"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S3"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_start"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_end"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "matched_strand"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios <- wide_tibble_consensus_clusters_MQ_ratios %>%
  dplyr::select(-S1, -S2, -S3, -S4, -S5, -S6) %>% 
  type_convert %>%
  dplyr::mutate_at(.vars = "cluster", as.character)

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("id", "method", "gene", "item_id", "category", "sub_junction_start", "sub_junction_end", "matched_strand", "cluster"), variable.name = "timepoint", value.name = "scaled_level") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_level" = mean(scaled_level))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_level, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_level, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI and expression logCPM\n",
                "JUM, PSI-Sigma, EdgeR/RSEM\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled PSI or logCPM") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_combinedexpr_timeseries_profiles.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_combinedexpr_timeseries_profiles.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster

#### preparation of separate data frames containing DIFFSPLICED gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x[.x$method == "JUM" | .x$method == "PSIsigma", ] %>% .$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combinedexpr.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(.x = list_of_genesets_by_cluster, .y = names(list_of_genesets_by_cluster), .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column(cluster = paste(.y)), .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_pfam_gene_family_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))

# rbind and write table
tibble_consensus_combinedexpr_PFAM_topinf <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus_combinedexpr_PFAM_topinf, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combinedexpr_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- future_map(.x = list_of_genesets_by_cluster, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_RBP_target_gene_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble

# reorder cluster as factor
tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits[, "cluster"] <- factor(tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits$cluster, levels = tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits$cluster %>% unique %>% mixedsort)

# plot RBP enrichment per cluster
ggplot(tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits %>% dplyr::arrange(pval), aes(x = reorder(TermID, pval), y = -log10(pval), size = (padj < 0.05) %>% as.character)) +
  geom_col(aes(fill = genes), colour = "black") +
  scale_fill_distiller(name = "Number of genes targeted by RBP", type = "seq", palette = "Spectral", direction = -1, aesthetics = "fill", na.value = "yellow") +
  scale_size_discrete(name = "FDR", breaks = c("TRUE", "FALSE"), limits = c("TRUE", "FALSE"), labels = c("< 0.05", "> 0.05"), range = c(0.1, 0)) +
  geom_hline(yintercept = -log10(0.05), lty = 2, col = "red") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series\nJUM, PSI-Sigma, RSEM/EdgeR", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 20)) +
  xlab("Upstream RBP") +
  ylab(expression(log["10"](p))) +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 20, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 20, units = "cm")

write.table(x = tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, file = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# JUM, PSI-Sigma and proteome/phosphoproteome.

## JUM: Filter the junction/exon ontology by validated junc.exons
### Match the validated JUM junction identifiers to the junction ID

```{r}

# generate mapping of final_identifiers to junction_ID
UNION_junc_coor_table_with_junction_identifier <- read.delim(paste(UNION_junc_coor_path), sep = "\t", stringsAsFactors = FALSE, col.names = c("chr", "start", "end", "strand", "junction_ID"), check.names = FALSE) %>% 
  as_tibble %>%
  dplyr::mutate("junction_identifier" = paste(chr, ":", start, "-", end, ":", strand, sep = "") %>% gsub(pattern = "(.*)0$", replacement = "\\1*"))

tibble_JUM_valid_junc.exons_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_2012.proteome_valid_junc.exons_coding %>%
                                                               dplyr::rename("final_identifier" = "Leading.razor.protein") %>% 
                                                               dplyr::mutate("junction_identifier" = gsub(x = final_identifier, pattern = "JUM_.*junction_", replacement = "")),
                                                             UNION_junc_coor_table_with_junction_identifier,
                                                             by = "junction_identifier")



```

### calculate statistics

loop thru all the junction ontology AS_event_IDs, return the number of contributing junctions that were validated in the proteome.

```{r}

list_number_of_contributing_junctions_validated <- tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique %>% strsplit(split = ",") %>% 
  purrr::map(.f = ~purrr::map(.x = .x, .f = ~any(.x == tibble_JUM_valid_junc.exons_with_junc_ID$junction_ID %>% unique %>% na.omit))) %>% set_names(tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique) %>%
  purrr::keep(.p = ~any(.x == TRUE)) %>%
  purrr::map(.f = ~which(.x == TRUE) %>% length)

```

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_JUM_junction_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_JUM_junction_ontology_supp_info,
                                                                                names(list_number_of_contributing_junctions_validated) %>% tibble::enframe(value = "contributing_junctions"), 
                                                                                by = "contributing_junctions")

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# JUM ###
tibble_JUM_junction_ontology_transcripts_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_transcripts, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_biomart_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_biomart, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_PTMs_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_PTMs, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")

```

#### stats summary of JUM junction ontology

```{r}

# PROTEIN-LEVEL
# vector_unique_interpro_ids <- tibble_JUM_junction_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(AS_event_ID) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per AS_event_ID
tibble_interpro_id_tally_per_ASeventID <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(Gene %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched AS_event_ID mapping
tibble_interpro_ID_to_matched_ASeventID_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("AS_event_IDs" = paste(AS_event_ID %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "AS_event_IDs"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_ASeventID_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of JUM VSRs")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique VSRs with any sort of protein-level annotation: ", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length, " (", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length *100/length(tibble_JUM_junction_ontology_transcripts$AS_event_ID %>% unique), "% of those which have any transcript annotation)")

message("total percent of unique VSRs overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique VSRs overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_filtered_by_proteome_JUM_tally <- tibble_JUM_junction_ontology_PTMs_filtered %>% 
  dplyr::distinct(AS_event_ID, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_filtered_by_proteome_JUM_tally, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nJUM")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_filtered_by_proteome_JUM_tally$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## PSI-Sigma: Filter the junction/exon ontology by validated diff_exon_coords

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_supp_info,
                                                                                tibble_2020.PO4_2012.proteome_valid_junc.exons_coding %>% 
                                                                                  dplyr::mutate("event_region_coords" = gsub(x = Leading.razor.protein, pattern = "^.*_VSR_([^\\_]+)_exon_(.*)$", replacement = "\\1"),
                                                                                                "diff_exon_coords" = gsub(x = Leading.razor.protein, pattern = "^.*_VSR_([^\\_]+)_exon_(.*)$", replacement = "\\2")), 
                                                                                by = c("event_region_coords", "diff_exon_coords"))

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_biomart_filtered <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_biomart, tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome, by = "diff_exon_coords")
tibble_PSIsigma_exon_ontology_PTMs_filtered <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_PTMs, tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome, by = "diff_exon_coords")

```

#### stats summary of PSI-Sigma junction ontology

```{r}

# PROTEIN-LEVEL
# vector_unique_interpro_ids <- tibble_PSIsigma_exon_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(diff_exon_coords) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per diff_exon_coords
tibble_interpro_id_tally_per_diff_exon_coords <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(matched_gene_names %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched diff_exon_coords mapping
tibble_interpro_ID_to_matched_diff_exon_coords_mapping <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("diff_exon_coords" = paste(diff_exon_coords %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "diff_exon_coords"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_matched_diff_exon_coords_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of PSI-Sigma exons")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique exons with any sort of protein-level annotation: ", tibble_PSIsigma_exon_ontology_biomart_filtered$diff_exon_coords %>% unique %>% length, " (", tibble_PSIsigma_exon_ontology_biomart_filtered$diff_exon_coords %>% unique %>% length *100/length(tibble_PSIsigma_exon_ontology_transcripts$diff_exon_coords %>% unique), "% of those which have any transcript annotation)")

message("total percent of unique exons overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique exons overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_tally_filtered_by_proteome_PSIsigma <- tibble_PSIsigma_exon_ontology_PTMs_filtered %>% 
  dplyr::distinct(diff_exon_coords, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_tally_filtered_by_proteome_PSIsigma, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nPSI-Sigma")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_tally_filtered_by_proteome_PSIsigma$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_PSISigma_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_PSISigma_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## Combined plot of interpro/PTM filtered by proteome evidence

```{r}

### interpro

tibble_combined_biomart_RNAlevel_filtered_by_proteome <- dplyr::full_join(tibble_interpro_id_tally_per_ASeventID %>% dplyr::rename("tally_JUM" = "tally", "genes_JUM" = "genes"), 
                                                                          tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::rename("tally_PSIsigma" = "tally", "genes_PSIsigma" = "genes"), 
                                                                          by = c("interpro_id", "interpro_description", "interpro_identifier")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  na.omit %>%
  tail(n = 10) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("interpro_id", "interpro_description", "interpro_identifier"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_biomart_RNAlevel_filtered_by_proteome, aes(x = `interpro_description`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_biomart_RNAlevel_filtered_by_proteome$tally %>% max * 1.2)) +
  ggtitle("Top 10 interpro domains, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("Interpro domain") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_biomart_RNAlevel_filtered_by_proteome_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_biomart_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

### PTMs
tibble_combined_PTMs_RNAlevel_filtered_by_proteome <- dplyr::full_join(tibble_PTM_filtered_by_proteome_JUM_tally %>% dplyr::rename("tally_JUM" = "tally"), 
                                                                       tibble_PTM_tally_filtered_by_proteome_PSIsigma %>% dplyr::rename("tally_PSIsigma" = "tally"), 
                                                                       by = c("PTM_type")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("PTM_type"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_PTMs_RNAlevel_filtered_by_proteome, aes(x = `PTM_type`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_PTMs_RNAlevel_filtered_by_proteome$tally %>% max(na.rm = TRUE) * 1.2)) +
  ggtitle("Top 10 PTMs, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("PTM type") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 6, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 6, units = "cm")

```

## filter the valid phosphosites by differential CDS positions.

### JUM

```{r}

# add junction ID onto the phosphosites table
tibble_JUM_valid_phosphosites_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_valid_phosphosites %>% 
                                                                 dplyr::mutate("junction_identifier" = gsub(x = `final_identifier`, pattern = "JUM_.*_junction_", replacement = "")),
                                                                        UNION_junc_coor_table_with_junction_identifier[, c("junction_identifier", "junction_ID")],
                                                               by = "junction_identifier")

# loop thru each junction ID for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_JUM_valid_phosphosites_with_junc_ID$junction_ID,
  .y = tibble_JUM_valid_phosphosites_with_junc_ID$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    subset_junction_ontology_supp_info_by_identifier <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[grep(x = tibble_JUM_junction_ontology_supp_info_filtered_by_proteome$contributing_junctions, pattern = a1), ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_junction_ontology_supp_info_by_identifier$vector_genomic_coords_of_all_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_JUM_valid_phosphosites_with_overlap <- tibble_JUM_valid_phosphosites_with_junc_ID %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

tibble_validated_phosphosites_JUM <- tibble_JUM_valid_phosphosites_with_overlap %>% 
  dplyr::filter(differential_overlap == TRUE) %>% 
  dplyr::distinct(genome_relative_positions_phosphosite, .keep_all = TRUE)

write.table(tibble_validated_phosphosites_JUM, paste(results_dir, "tibble_validated_phosphosites_JUM.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

cat("\nthere are ", tibble_validated_phosphosites_JUM$genome_relative_positions_phosphosite %>% unique %>% length, " phosphosites validated in JUM AS region")

```

### PSI-Sigma

```{r}

# loop thru each identifier for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_2020.PO4_valid_phosphosites$final_identifier,
  .y = tibble_2020.PO4_valid_phosphosites$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- tibble_2020.PO4_valid_phosphosites$final_identifier %>% .[[781]]
    # a2 <- tibble_2020.PO4_valid_phosphosites$genome_relative_positions_phosphosite %>% strsplit(split = ",") %>% .[[781]]
    ###########
    
    # extract the VSR identifier and the alternative exon identifiers by strsplit
    VSR_identifier <- gsub(x = a1, pattern = "PSISigma_.*_VSR_(.*)_exon_(.*)", replacement = "\\1")
    alternative_exon_identifier <- gsub(x = a1, pattern = "PSISigma_.*_VSR_(.*)_exon_(.*)", replacement = "\\2")
    
    subset_exon_ontology_supp_info_by_identifier <-
      tibble_PSIsigma_exon_ontology_supp_info[tibble_PSIsigma_exon_ontology_supp_info$event_region_coords == VSR_identifier & 
                                                tibble_PSIsigma_exon_ontology_supp_info$diff_exon_coords == alternative_exon_identifier, ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_exon_ontology_supp_info_by_identifier$list_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_PSIsigma_valid_phosphosites_with_overlap <- tibble_2020.PO4_valid_phosphosites %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

tibble_validated_phosphosites_PSIsigma <- tibble_PSIsigma_valid_phosphosites_with_overlap %>% 
  dplyr::filter(differential_overlap == TRUE) %>% 
  dplyr::distinct(genome_relative_positions_phosphosite, .keep_all = TRUE)

write.table(tibble_validated_phosphosites_PSIsigma, paste(results_dir, "tibble_validated_phosphosites_PSIsigma.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

cat("\nthere are ", tibble_validated_phosphosites_PSIsigma$genome_relative_positions_phosphosite %>% unique %>% length, " phosphosites validated in PSI-Sigma AS region")

```

## Calculate bootstrap P values of the JUM/PSI-Sigma:

- Transcript regions
- Interpro domains (ALL + proteome filtered)
- Biomart regions esp. LCR (ALL + proteome filtered)
- PTM overlap  (ALL + proteome filtered)

NOTE: For all the proteome-filtered, MUST walk along the **CDS**.

### Meaning we need to cast onto the genome, convert to Granges then convert to transcript-relative topology:

- Biomart reference regions (easiest to do)
- Biomart regions, incl. interpro domains, LCR.
- Each interpro domain
- dbPTM sites (which already includes phosphositeplus)

### set environment and GTF

```{r}

library(regioneR)
library(rtracklayer)
library(BSgenome.Hsapiens.UCSC.hg38)

tibble_ref_gtf_original <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(tibble_ref_gtf_original) <- c("chr", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES
tibble_PTM_combined <- dplyr::bind_rows(tibble_dbPTM_allhuman_annotations, tibble_phosphositeplus_allhuman_phosphosites)

```

### Reference preprocessing: define and map topologies, cast reference regions onto exon-relative coords.

1. define exonic and CDS relative topology mapping
2. create the effective exome/CDSome
3. convert transcript regions, biomart regions and PTM sites to exon/CDS-relative coords.

NOTE: biomart regions and PTM sites need to be pre-cast onto the genome before converting to CDS-relative coords.

#### construction of the effective exome AND transcript region conversion

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# extract exonic entries only
tibble_exonic_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "exon", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_exonic_GTF_entries_unique <- tibble_exonic_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutely necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_exonic_GTF_entries_unique <- granges_exonic_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_exonic_GTF_entries <- tibble_exonic_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_exonic_GTF_entries) <- list_exonic_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_exonic_GTF_entries <- list_exonic_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO TRANSCRIPT-RELATIVE TOPOLOGY MAPPING
list_exonic_GTF_entries_genome_to_exon_relative_mapping <- future_map(.x = list_exonic_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_exonic_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_transcript_relative_end <- vec_sum_of_widths
                                                            vec_transcript_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("transcript_relative_start" = vec_transcript_relative_start,
                                                                                              "transcript_relative_end" = vec_transcript_relative_end)
                                                            
                                                          }, .progress = TRUE )

# create granges of the effective exome
## first get start and end based on the exon relative coords
tibble_effective_exome <- list_exonic_GTF_entries_genome_to_exon_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$transcript_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_exome <- toGRanges(tibble_effective_exome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

# move non-exonic entries over to transcript-relative coords.
## we will choose everything except for gene, transcript and selenocysteine because they span across multiple exons and hence will break the matching algorithm.
tibble_non_exonic_GTF_entries <- dplyr::bind_rows(
  tibble_ref_gtf_original[tibble_ref_gtf_original$type %in% c("CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr"), ],
  tibble_ref_gtf_original[tibble_ref_gtf_original$type == "exon" & tibble_ref_gtf_original$transcript_biotype %in% c("protein_coding", "lncRNA", "miRNA"), ] )
## group-split the non-exonic entries by chromosome so we can map2 over both.
list_non_exonic_GTF_entries <- purrr::map(.x = names(list_exonic_GTF_entries_genome_to_exon_relative_mapping),
                                          .f = ~tibble_non_exonic_GTF_entries[tibble_non_exonic_GTF_entries$chr == .x, ])

## map2 over exonic and non-exonic GTF entries.
list_non_exonic_GTF_entries_exon_relative_coords <- future_map2(.x = list_exonic_GTF_entries_genome_to_exon_relative_mapping,
                                                                .y = list_non_exonic_GTF_entries,
                                                                .f = function(a1, a2) {
                                                                  
                                                                  # DEBUG ###
                                                                  # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
                                                                  # a2 <- list_non_exonic_GTF_entries[[1]]
                                                                  ###########
                                                                  
                                                                  # list-ify the non-exonic entries
                                                                  list_non_exonic_subset <- a2 %>% array_tree
                                                                  # loop thru each element, find overlapping exonic interval, subtract 
                                                                  list_non_exonic_subset_transcript_relative_coords <- future_map(
                                                                    .x = list_non_exonic_subset,
                                                                    .f = function(b1) {
                                                                      
                                                                      # DEBUG ###
                                                                      # b1 <- list_non_exonic_subset[[1]]
                                                                      ###########
                                                                      
                                                                      tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
                                                                      
                                                                      # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
                                                                      shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
                                                                      transcript_relative_start <- (b1$start %>% type.convert) - shift
                                                                      transcript_relative_end <- (b1$end %>% type.convert) - shift
                                                                      
                                                                      output_tibble <- splice(
                                                                        b1,
                                                                        "transcript_relative_start" = transcript_relative_start %>% list,
                                                                        "transcript_relative_end" = transcript_relative_end %>% list
                                                                      ) %>% as_tibble
                                                                      
                                                                      return(output_tibble)
                                                                      
                                                                    }, .progress = TRUE, .options = future_options(globals = c("a1")) )
                                                                  
                                                                }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_non_exonic_GTF_entries_exon_relative_coords <- list_non_exonic_GTF_entries_exon_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

# create granges of transcript "type" and "transcript_biotype".
## this is a little complicated because we're splitting by two rows. but basically we have to group_split the exonic and non-exonic entries separately
## the non-exonic will be split by "type" and the exonic will be split by "transcript_biotype".
## then splice the lists together.
## this is because transcript biotypes to be split can be both non-exon or exon, whereas non-exon/exon to be split are always in one transcript_biotype.
list_split_ensembl_transcript_types_and_biotypes <- purrr::splice(
  tibble_non_exonic_GTF_entries_exon_relative_coords %>% 
    dplyr::filter(type != "exon") %>%
    dplyr::group_split(type) %>%
    set_names(purrr::map(.x = ., .f = ~.x$type %>% unique)),
  tibble_non_exonic_GTF_entries_exon_relative_coords %>% 
    dplyr::filter(type == "exon") %>%
    dplyr::group_split(transcript_biotype) %>%
    set_names(purrr::map(.x = ., .f = ~.x$transcript_biotype %>% unique))
) %>% flatten

list_granges_ensembl_transcript_types <- list_split_ensembl_transcript_types_and_biotypes %>%
  purrr::map(~toGRanges(.x[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                          # turn chr column into chr1 chr2 etc...
                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                          type_convert %>% 
                          # data frame is absolutely necessary for regioneR.
                          as.data.frame))

# NOTE: not planning to do "transcript_biotype" anymore.

# list_granges_ensembl_transcript_biotypes <- tibble_ref_gtf_original %>%
#   dplyr::filter(type == "exon") %>%
#   dplyr::group_split(transcript_biotype) %>%
#   set_names(purrr::map(.x = ., .f = ~.x$transcript_biotype %>% unique)) %>%
#   purrr::map(~toGRanges(.x[, c("chr", "start", "end")] %>% 
#                           # turn chr column into chr1 chr2 etc...
#                           dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
#                           type_convert %>% 
#                           # data frame is absolutely necessary for regioneR.
#                           as.data.frame))

# list_granges_ensembl_transcript_by_type_and_biotype <- purrr::splice(list_granges_ensembl_transcript_types, list_granges_ensembl_transcript_biotypes)

```

#### construct the effective CDSome

```{r}

# extract CDS entries only
tibble_CDS_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "CDS", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_CDS_GTF_entries_unique <- tibble_CDS_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutele necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_CDS_GTF_entries_unique <- granges_CDS_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_CDS_GTF_entries <- tibble_CDS_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_CDS_GTF_entries) <- list_CDS_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_CDS_GTF_entries <- list_CDS_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO CDS-RELATIVE TOPOLOGY MAPPING
list_CDS_GTF_entries_genome_to_CDS_relative_mapping <- future_map(.x = list_CDS_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_CDS_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_CDS_relative_end <- vec_sum_of_widths
                                                            vec_CDS_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("CDS_relative_start" = vec_CDS_relative_start,
                                                                                              "CDS_relative_end" = vec_CDS_relative_end)
                                                            
                                                          }, .progress = TRUE)

# create granges of the effective CDSome
## first get start and end based on the CDS relative coords
tibble_effective_CDSome <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$CDS_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_CDSome <- toGRanges(tibble_effective_CDSome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

```

### Preprocessing: convert differential positions into UNIQUE Granges and convert to exon-relative coords.

#### differential exonic positions

```{r}

# JUM - unfiltered RNA
## create tibble of item coords and chr
tibble_JUM_differential_exonic_coords_and_chr <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_JUM_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_unfiltered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_exonic_regions_all.RNA <- toGRanges(tibble_JUM_differential_unfiltered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutele necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_differential_exonic_regions_all.RNA <- regioneR::mergeRegions(granges_JUM_differential_exonic_regions_all.RNA, granges_JUM_differential_exonic_regions_all.RNA)

# PSI-Sigma - unfiltered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_exonic_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_unfiltered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_exonic_regions_all.RNA <- toGRanges(tibble_PSIsigma_differential_unfiltered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutele necessary for regioneR.
                                                       as.data.frame)
# make unique regions only
granges_PSIsigma_differential_exonic_regions_all.RNA <- regioneR::mergeRegions(granges_PSIsigma_differential_exonic_regions_all.RNA, granges_PSIsigma_differential_exonic_regions_all.RNA)

# JUM - proteome-filtered RNA
## create tibble of item coords and chr
tibble_JUM_differential_exonic_coords_and_chr <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_JUM_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_proteome_filtered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_exonic_regions_proteome.filtered.RNA <- toGRanges(tibble_JUM_differential_proteome_filtered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                                             # turn chr column into chr1 chr2 etc...
                                                                             dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                             type_convert %>% 
                                                                             # data frame is absolutele necessary for regioneR.
                                                                             as.data.frame)
# make unique regions only
granges_JUM_differential_exonic_regions_proteome.filtered.RNA <- regioneR::mergeRegions(granges_JUM_differential_exonic_regions_proteome.filtered.RNA, granges_JUM_differential_exonic_regions_proteome.filtered.RNA)

# PSI-Sigma - proteome-filtered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_exonic_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome[, c("diff_exon_coords", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_proteome_filtered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA <- toGRanges(tibble_PSIsigma_differential_proteome_filtered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutely necessary for regioneR.
                                                       as.data.frame)
# make unique regions only
granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA <- regioneR::mergeRegions(granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA, granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA)

```

#### differential CDS positions

```{r}

# JUM - unfiltered RNA
## create tibble of item coords and chr
tibble_JUM_differential_CDS_coords_and_chr <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_CDS_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_CDS_coords_and_chr$vector_genomic_coords_of_all_differential_CDS_positions, 
  metadata_vector = tibble_JUM_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_unfiltered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_CDS_regions_all.RNA <- toGRanges(tibble_JUM_differential_unfiltered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutele necessary for regioneR.
                                                               as.data.frame)

# PSI-Sigma - unfiltered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_CDS_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "list_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "list_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "list_differential_CDS_positions") %>%
  dplyr::arrange(list_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$list_differential_CDS_positions, 
  metadata_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_unfiltered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_CDS_regions_all.RNA <- toGRanges(tibble_PSIsigma_differential_unfiltered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutele necessary for regioneR.
                                                       as.data.frame)

# JUM - proteome-filtered RNA
## create tibble of item coords and chr
tibble_JUM_differential_CDS_coords_and_chr <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_CDS_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_CDS_coords_and_chr$vector_genomic_coords_of_all_differential_CDS_positions, 
  metadata_vector = tibble_JUM_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_proteome_filtered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_CDS_regions_proteome.filtered.RNA <- toGRanges(tibble_JUM_differential_proteome_filtered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                                             # turn chr column into chr1 chr2 etc...
                                                                             dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                             type_convert %>% 
                                                                             # data frame is absolutele necessary for regioneR.
                                                                             as.data.frame)

# PSI-Sigma - proteome-filtered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_CDS_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome[, c("diff_exon_coords", "list_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "list_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "list_differential_CDS_positions") %>%
  dplyr::arrange(list_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$list_differential_CDS_positions, 
  metadata_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & b1$end %>% type.convert <= a1$end), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_proteome_filtered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_CDS_regions_proteome.filtered.RNA <- toGRanges(tibble_PSIsigma_differential_proteome_filtered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutely necessary for regioneR.
                                                       as.data.frame)

```

### Preprocessing: map target (fixed) regions onto genome

#### get all the genome-relative positions of CDS nucleotides for every ENSP id

```{r}

# tibble_ENSP_to_genome_relative_CDS_positions <- tibble_ref_gtf_original %>% 
#   dplyr::filter(type == "CDS") %>% 
#   dplyr::group_split(protein_id) %>% 
#   future_map(.f = ~list("protein_id" = .x$protein_id %>% unique, "chr" = .x$chr %>% unique, "vec_all_parent_ENSP_CDS_positions_sorted" = purrr::map2(.x = .$start, .y = .$end, .f = ~.x:.y) %>% unlist %>% sort), .progress = TRUE, .options = future_options(globals = FALSE)) %>% 
#   future_map(.f = ~as_tibble(.x) %>% nest(data = "vec_all_parent_ENSP_CDS_positions_sorted") %>% dplyr::rename("vec_all_parent_ENSP_CDS_positions_sorted" = "data"), .progress = TRUE, .options = future_options(globals = c("as_tibble", "nest", "dplyr::rename"))) %>% 
#   rbindlist %>% as_tibble

# save(tibble_ENSP_to_genome_relative_CDS_positions, file = paste(results_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

load(file = paste(results_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

```

#### Cast biomart regions onto the genome, convert to exon*-relative topology, then convert to granges.

```{r}

# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

# read tables
list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(shared_dir, "table_biomart_ENSP_to_", .x, ".txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble", "shared_dir"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

# filter the interpro entries for the non-family entries only
list_of_tibbles_biomart_domain_annotation <- purrr::modify_at(.x = list_of_tibbles_biomart_domain_annotation,
                                                              .at = "interpro",
                                                              .f = ~dplyr::semi_join(.x, tibble_non_family_interpro_entries %>% dplyr::rename("interpro" = "Accession"), by = "interpro"))

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

list_of_tibbles_biomart_regions_cast_onto_genome <- future_imap(.x = list_of_tibbles_biomart_domain_annotation, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- list_of_tibbles_biomart_domain_annotation[["interpro"]]
  ###########
  
  cat("\nnow processing: ", a2, "\n")
  
  tibble_sorted_CDS_relative_positions <- a1 %>% 
    add_column("CDS_relative_coords_start" = ((3*.$start) - 2), "CDS_relative_coords_end" = (3*.$end)) %>% 
    dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
    dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
    # some ENSP ids from interpro are not in ensembl.
    dplyr::filter(is.na(chr) != TRUE) 
  
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  vec_all_genome_relative_coords_of_item <- future_map2(
    .x = tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions`, 
    .y = tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted`, 
    .f = function(b1, b2) {
      
      # DEBUG ###
      # b1 <- tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions` %>% .[[1]]
      # b2 <- tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted` %>% .[[1]]
      ###########
      
      vec_parent_ENSP_CDS_positions <- b2 %>% unlist
      
      vec_parent_ENSP_CDS_positions[b1] %>% return
      
    }, .progress = TRUE, .options = future_options(globals = FALSE))
  
  nucleotide_width <- purrr::map(.x = vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist
  
  # add the genome-relative coords and nucleotide width in
  final_tibble_with_genome_relative_coords <- tibble_sorted_CDS_relative_positions %>% 
    add_column("vec_all_genome_relative_coords_of_item" = vec_all_genome_relative_coords_of_item,
               "nucleotide_width" = nucleotide_width)
  
}, .progress = TRUE ) 

# drop the columns of all ENSP positions. we dont need them anymore.
list_of_tibbles_biomart_regions_cast_onto_genome <- list_of_tibbles_biomart_regions_cast_onto_genome %>% purrr::map(~.x %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted))
# drop empty "chr" rows
# list_of_tibbles_biomart_regions_cast_onto_genome <- list_of_tibbles_biomart_regions_cast_onto_genome %>% purrr::map(~.x %>% dplyr::filter(is.na(chr) != TRUE))

# save(list_of_tibbles_biomart_regions_cast_onto_genome, file = paste(results_dir, "list_of_tibbles_biomart_regions_cast_onto_genome.Rlist", sep = ""))

# load(file = paste(results_dir, "list_of_tibbles_biomart_regions_cast_onto_genome.Rlist", sep = ""))

# plan(list(tweak(multiprocess, workers = 8),
#           tweak(multiprocess, workers = 8))
# )

## convert vector of discontinuous sites into chr, start, end.
list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_genome, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_biomart_regions_cast_onto_genome[[1]]
    ###########
    
    # make a tibble which maps the genome-relative coords of item with the corresponding chromosome
    tibble_genome_relative_coords_and_chr <- a1[, c("chr", "vec_all_genome_relative_coords_of_item")]
    # group split by chromosome
    list_of_tibbles_genome_relative_coords_by_chr <- tibble_genome_relative_coords_and_chr %>% 
      dplyr::group_split(chr)
    names(list_of_tibbles_genome_relative_coords_by_chr) <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$chr %>% unique, .progress = TRUE) %>% unlist
    # unlist each element and make unique
    list_of_tibbles_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unlist %>% unique %>% sort, .progress = TRUE)
    # re-tibblise and rbind for 1:1 chromosome marker to position mapping
    list_of_tibbles_genome_relative_coords_by_chr <- purrr::map2(.x = list_of_tibbles_genome_relative_coords_by_chr,
                                                                 .y = names(list_of_tibbles_genome_relative_coords_by_chr),
                                                                 .f = ~.x %>% tibble::enframe(name = NULL, value = "position") %>% 
                                                                   add_column("chr" = .y))
    
    tibble_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% rbindlist(use.names = TRUE) %>% as_tibble
    
    # convert tibble of chr and position to simple ranges
    tibble_simple_ranges <- convert_vector.of.positions_to_simple.ranges(
      input_vector = tibble_genome_relative_coords_by_chr$position, 
      metadata_vector = tibble_genome_relative_coords_by_chr$chr) %>% 
      # rename metadata column)
      dplyr::rename("chr" = "value") %>% 
      # filter out non-1:22/X/Y chromosome entries
      dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
      return
                    
  }, .progress = TRUE)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# recast the continuous genome-relative biomart ranges onto the CDS.
# L1: different biomart annotations
# L2: split by chromosome
list_of_tibbles_biomart_regions_cast_onto_exome_simple_ranges <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges[[1]]
    ###########
    
    # split by chromosome
    list_tibbles_biomart_regions_split_by_chromosome <- a1 %>% 
      dplyr::group_split(chr) %>%
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
    
    # get chromosomes in common with the CDS-relative mapping
    chr_in_common <- intersect(
      names(list_tibbles_biomart_regions_split_by_chromosome),
      names(list_exonic_GTF_entries_genome_to_exon_relative_mapping)
    )
    
    ## map2 over exonic and non-exonic GTF entries, per chromosome
    list_of_tibbles_biomart_regions_exome_relative_coords_single_annotation <- future_map2(
      .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common],
      .y = list_tibbles_biomart_regions_split_by_chromosome[chr_in_common],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common] %>% .[[1]]
        # b2 <- list_tibbles_biomart_regions_split_by_chromosome[chr_in_common] %>% .[[1]]
        ###########
        
        # list-ify the biomart entries, one element per row.
        list_biomart_subset <- b2 %>% array_tree
        # loop thru each element, find overlapping exonic interval, subtract 
        list_biomart_subset_exome_relative_coords <- future_map(
          .x = list_biomart_subset,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_biomart_subset[[1]]
            ###########
            
            tibble_matching_exome_entry <- b1[which(b1$start <= c1$start %>% type.convert & c1$end %>% type.convert <= b1$end), ]
            
            # based on shift (start)g - (start)t, we splice in the the CDS-relative coords of this genome-relative biomart element.
            shift <- tibble_matching_exome_entry$start - tibble_matching_exome_entry$transcript_relative_start
            transcript_relative_start <- (c1$start %>% type.convert) - shift
            transcript_relative_end <- (c1$end %>% type.convert) - shift
            
            output_tibble <- splice(
              c1,
              "transcript_relative_start" = transcript_relative_start %>% list,
              "transcript_relative_end" = transcript_relative_end %>% list
            ) %>% as_tibble
            
            return(output_tibble)
            
          }, .progress = TRUE, .options = future_options(globals = c("b1")) )
        
        # rbindlist and tibblise
        tibble_biomart_subset_exome_relative_coords <- list_biomart_subset_exome_relative_coords %>% rbindlist %>% as_tibble
        
        return(tibble_biomart_subset_exome_relative_coords)
        
      }, .progress = TRUE)
    
    # rbind and tibblise
    tibble_biomart_regions_exome_relative_coords_single_annotation <- list_of_tibbles_biomart_regions_exome_relative_coords_single_annotation %>% 
      rbindlist %>% as_tibble %>% type_convert
    
    return(tibble_biomart_regions_exome_relative_coords_single_annotation)
    
  }, .progress = TRUE )

# finally convert the CDS relative biomart regions into granges
list_granges_biomart_regions_exome_relative <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_exome_simple_ranges,
  .f = function(a1) {
    
    granges_biomart_region <- toGRanges(a1[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                          # turn chr column into chr1 chr2 etc...
                                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                          type_convert %>% 
                                          # data frame is absolutele necessary for regioneR.
                                          as.data.frame)
    
    return(granges_biomart_region)
    
  }, .progress = TRUE )

```

#### cast dbPTM sites onto the genome, convert to exon*-relative topology, then convert to granges.

```{r}

# get ENSP to uniprotkb_entry mapping
# tibble_ENSP_to_uniprotkb <- biomaRt::getBM(attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
# type_convert %>% 
# as_tibble %>%
# na.omit

# save(tibble_ENSP_to_uniprotkb, file = paste(shared_dir, "tibble_uniprot_to_ENSP_mapping_table.tibble", paste = ""))
load(file = paste(shared_dir, "tibble_uniprot_to_ENSP_mapping_table.tibble", paste = ""))

# convert uniprotkb_entry into ENSP
tibble_dbPTM_allhuman_annotations_with_ENSP <- dplyr::left_join(tibble_dbPTM_allhuman_annotations, tibble_ENSP_to_uniprotkb, by = "uniprotkb_entry") %>% 
  dplyr::filter(is.na(ensembl_peptide_id) != TRUE) %>% type_convert

# cast onto genome.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_with_ENSP %>% 
  add_column("CDS_relative_coords_start" = ((3*.$modified_residue_position) - 2), "CDS_relative_coords_end" = (3*.$modified_residue_position)) %>% 
  dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
  dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
  # some ENSP ids from interpro are not in ensembl.
  dplyr::filter(is.na(chr) != TRUE) %>%
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  dplyr::mutate("vec_all_genome_relative_coords_of_item" = purrr::map2(.x = .$vec_all_CDS_relative_positions, .y = .$vec_all_parent_ENSP_CDS_positions_sorted, .f = ~.y %>% unlist %>% .[.x], .progress = TRUE, .options = future_options(globals = FALSE))) %>%
  dplyr::mutate("nucleotide_width" = purrr::map(.x = .$vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist)

# drop the columns of all ENSP positions. we dont need them anymore.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted)
# save(tibble_dbPTM_allhuman_annotations_cast_onto_genome, file = paste(results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.Rlist", sep = ""))

# load(file = paste(results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.Rlist", sep = ""))

# split by PTM type
list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>%
  dplyr::group_split(PTM_type) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$PTM_type %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

## convert vector of discontinuous sites into chr, start, end.
list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges <- future_map(
  .x = list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome[[1]]
    ###########
    
    # make a tibble which maps the genome-relative coords of item with the corresponding chromosome
    tibble_genome_relative_coords_and_chr <- a1[, c("chr", "vec_all_genome_relative_coords_of_item")]
    # group split by chromosome
    list_of_tibbles_genome_relative_coords_by_chr <- tibble_genome_relative_coords_and_chr %>% 
      dplyr::group_split(chr)
    names(list_of_tibbles_genome_relative_coords_by_chr) <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$chr %>% unique, .progress = TRUE) %>% unlist
    # unlist each element and make unique
    list_of_tibbles_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unlist %>% unique %>% sort, .progress = TRUE)
    # re-tibblise and rbind for 1:1 chromosome marker to position mapping
    list_of_tibbles_genome_relative_coords_by_chr <- purrr::map2(.x = list_of_tibbles_genome_relative_coords_by_chr,
                                                                 .y = names(list_of_tibbles_genome_relative_coords_by_chr),
                                                                 .f = ~.x %>% tibble::enframe(name = NULL, value = "position") %>% 
                                                                   add_column("chr" = .y))
    
    tibble_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% rbindlist(use.names = TRUE) %>% as_tibble
    
    # convert tibble of chr and position to simple ranges
    tibble_simple_ranges <- convert_vector.of.positions_to_simple.ranges(
      input_vector = tibble_genome_relative_coords_by_chr$position, 
      metadata_vector = tibble_genome_relative_coords_by_chr$chr) %>% 
      # rename metadata column)
      dplyr::rename("chr" = "value") %>% 
      # filter out non-1:22/X/Y chromosome entries
      dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
      return
                    
  }, .progress = TRUE)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# recast the continuous genome-relative biomart ranges onto the *exome
# L1: different biomart annotations
# L2: split by chromosome
list_of_tibbles_PTM_sites_cast_onto_exome_simple_ranges <- future_map(
  .x = list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges[[1]]
    ###########
    
    # split by chromosome
    list_tibbles_regions_split_by_chromosome <- a1 %>% 
      dplyr::group_split(chr) %>%
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
    
    # get chromosomes in common with the CDS-relative mapping
    chr_in_common <- intersect(
      names(list_tibbles_regions_split_by_chromosome),
      names(list_exonic_GTF_entries_genome_to_exon_relative_mapping)
    )
    
    ## map2 over exonic and non-exonic GTF entries, per chromosome
    list_of_tibbles_PTM_sites_exome_relative_coords_single_annotation <- future_map2(
      .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common],
      .y = list_tibbles_regions_split_by_chromosome[chr_in_common],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common] %>% .[[1]]
        # b2 <- list_tibbles_regions_split_by_chromosome[chr_in_common] %>% .[[1]]
        ###########
        
        # list-ify the entries, one element per row.
        list_subset <- b2 %>% array_tree
        # loop thru each element, find overlapping CDS interval, subtract 
        list_PTM_subset_exome_relative_coords <- future_map(
          .x = list_subset,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_subset[[1]]
            ###########
            
            tibble_matching_CDS_entry <- b1[which(b1$start <= c1$start %>% type.convert & c1$end %>% type.convert <= b1$end), ]
            
            # based on shift (start)g - (start)t, we splice in the the CDS-relative coords of this genome-relative biomart element.
            shift <- tibble_matching_CDS_entry$start - tibble_matching_CDS_entry$transcript_relative_start
            transcript_relative_start <- (c1$start %>% type.convert) - shift
            transcript_relative_end <- (c1$end %>% type.convert) - shift
            
            output_tibble <- splice(
              c1,
              "transcript_relative_start" = transcript_relative_start %>% list,
              "transcript_relative_end" = transcript_relative_end %>% list
            ) %>% as_tibble
            
            return(output_tibble)
            
          }, .progress = TRUE, .options = future_options(globals = c("b1")) )
        
        # rbindlist and tibblise
        tibble_PTM_subset_exome_relative_coords <- list_PTM_subset_exome_relative_coords %>% rbindlist %>% as_tibble
        
        return(tibble_PTM_subset_exome_relative_coords)
        
      }, .progress = TRUE)
    
    # rbind and tibblise
    tibble_PTM_sites_exome_relative_coords_single_annotation <- list_of_tibbles_PTM_sites_exome_relative_coords_single_annotation %>% 
      rbindlist %>% as_tibble %>% type_convert
    
    return(tibble_PTM_sites_exome_relative_coords_single_annotation)
    
  }, .progress = TRUE )

# finally convert the CDS relative PTM sites into granges
list_granges_PTM_sites_exome_relative <- future_map(
  .x = list_of_tibbles_PTM_sites_cast_onto_exome_simple_ranges,
  .f = function(a1) {
    
    granges_PTM_sites <- toGRanges(a1[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                          # turn chr column into chr1 chr2 etc...
                                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                          type_convert %>% 
                                          # data frame is absolutely necessary for regioneR.
                                          as.data.frame)
    
    return(granges_PTM_sites)
    
  }, .progress = TRUE )

```

### Permutation test

#### Set up all granges topology, source and target lists

```{r}

# granges_effective_CDSome
# granges_effective_exome 

# list_granges_ensembl_transcript_types
# list_granges_biomart_regions_CDS_relative 
# list_granges_PTM_sites_CDS_relative

list_granges_exonic_differential_positions <- list(
  "JUM_exonic_unfiltered" = granges_JUM_differential_exonic_regions_all.RNA,
  "PSIsigma_exonic_unfiltered" = granges_PSIsigma_differential_exonic_regions_all.RNA,
  "JUM_exonic_proteome_filtered" = granges_JUM_differential_exonic_regions_proteome.filtered.RNA,
  "PSIsigma_exonic_proteome_filtered" = granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA)

list_granges_CDS_differential_positions <- list(
  "JUM_CDS_unfiltered" = granges_JUM_differential_CDS_regions_all.RNA,
  "PSIsigma_CDS_unfiltered" = granges_PSIsigma_differential_CDS_regions_all.RNA,
  "JUM_CDS_proteome_filtered" = granges_JUM_differential_CDS_regions_proteome.filtered.RNA,
  "PSIsigma_CDS_proteome_filtered" = granges_PSIsigma_differential_CDS_regions_proteome.filtered.RNA)

```

#### transcript regions - loop thru each type of region - **EXOME**

- we use random shuffle permutations at the level of the exome or CDS. This is because contiguity is achieved in the exome and CDS.

```{r}

plan(list(tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: transcript type
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_transcript_types <- future_map(
  .x = list_granges_exonic_differential_positions[c("JUM_exonic_unfiltered", "PSIsigma_exonic_unfiltered")], 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_ensembl_transcript_types,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_ensembl_transcript_types[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 8) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_transcript_types, file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_transcript_types_pvalues <- list_permtest_exonic_transcript_types %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

```

#### biomarts regions - loop thru each type of region - **EXOME (revised)**

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 7),
          tweak(multiprocess, workers = 4))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: biomart region
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_biomart_regions <- future_map(
  .x = list_granges_exonic_differential_positions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_biomart_regions_exome_relative,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_biomart_regions_exome_relative[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 4) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_biomart_regions, file = paste(results_dir, "list_permtest_exonic_biomart_regions.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_biomart_regions.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_biomart_regions_pvalues <- list_permtest_exonic_biomart_regions %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

```

#### PTMs - loop thru each type of PTM - **EXOME (revised)**

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 4))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: biomart region
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_PTMs <- future_map(
  .x = list_granges_exonic_differential_positions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_PTM_sites_exome_relative,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_PTM_sites_exome_relative[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 4) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_PTMs, file = paste(results_dir, "list_permtest_exonic_PTMs.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_PTMs.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_PTMs_pvalues <- list_permtest_exonic_PTMs %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))


```

```{r}

# optional: save workspace for debugging because i'm going to run this overnight and go to sleep.
save.image(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/multiomic_synthesis/source/22092020_topology_conversion_bootstrapping.RData")

```

# benchmark performance of NMD flagger

comparisons are done at the level of transcripts.

```{r}

tibble_ref_gtf_with_NMD_flagged_unique_transcripts <- tibble_ref_gtf_with_NMD_flagged_E2 %>% .[-which(is.na(.$transcript_id)), c("transcript_id", "seqnames", "strand", "start", "end", "transcript_biotype", "NMD_candidate")] %>% dplyr::distinct(transcript_id, .keep_all = TRUE) %>% add_column("identifier" = paste(.$seqnames, ":", .$start, "-", .$end, sep = ""))

# get row indices of those transcripts with ref. annotated NMD
row.indices_ref_NMD <- which(tibble_ref_gtf_with_NMD_flagged_unique_transcripts$transcript_biotype == "nonsense_mediated_decay")

# get row indices of those transcripts flagged as NMD
row.indices_flagged_NMD <- grep(x = tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate, pattern = "TRUE")

message("number of reference transcripts with reference NMD annotation: ", row.indices_ref_NMD %>% length, " (", (row.indices_ref_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of reference transcripts flagged as NMD: ", row.indices_flagged_NMD %>% length, " (", (row.indices_flagged_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of transcripts flagged as NMD in common with annotation: ", intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)
message("jaccard: ", (intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)/(union(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length))

# ggplot of the transcript_biotype of NMD candidates

## neat descending order of x-axis
tibble_frequency_distribution <- tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% 
  dplyr::filter(NMD_candidate == "TRUE") %>% 
  dplyr::group_by(transcript_biotype) %>% 
  dplyr::summarise("count_per_transcript_biotype" = n()) %>% 
  dplyr::arrange(desc(count_per_transcript_biotype))

message("percent protein_coding of total: ", (tibble_frequency_distribution[tibble_frequency_distribution$transcript_biotype == "protein_coding", "count_per_transcript_biotype"] %>% paste %>% as.numeric)*100/sum(tibble_frequency_distribution$count_per_transcript_biotype), "%")

x_axis_order <- tibble_frequency_distribution %>% .$transcript_biotype %>% unique

ggplot(data = tibble_ref_gtf_with_NMD_flagged_unique_transcripts[tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate == "TRUE", ]) +
  geom_bar(mapping = aes(x = transcript_biotype, y = ..count..)) +
  geom_label(stat = "count", aes(x = transcript_biotype, label = ..count..)) +
  scale_x_discrete(breaks = x_axis_order, limits = x_axis_order) +
  ggtitle("Common Ensembl transcript_biotype annotations associated with flagged NMD transcripts
          (minimum 5 exons)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

# sQTL and disease ontology - JUM and PSI-Sigma

## Cross reference SNPs from the GWAS catalog

### find SNPs which lie in AS regions.

#### prepare bootstrapping tools

```{r}

library(regioneR)

library(BSgenome.Hsapiens.UCSC.hg38)

set.seed(7)

options(mc.cores = 16)

```

At the present time, we are looking for SNPs in whole LSV regions for both JUM and PSI-Sigma. This is because mutations can occur at the cis-ESS/ESE/ISS/ISEs, which are not always in the exons/introns of interest.

#### calculate overlap

##### JUM differential

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end_differential <- tibble(
  "AS_event_ID" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_differential_array.tree <- tibble_AS.event.IDs_chr_start_end_differential %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_differential <- future_map(.x = list_JUM_AS.event.IDs_differential_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_differential_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog %>% dplyr::filter(CHR_ID == .x$chr &
                                                .x$start %>% as.numeric <= CHR_POS &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .x$AS_event_ID,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end,
                                                  "AS_event_ID_splicemode" = .x$splicemode)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog", "add_column")))

tibble_JUM_differential_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_differential %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

# get a tally of traits
tibble_JUM_differential_AS.event.ID_snps_summary_by_trait <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_JUM_differential" = n()) %>% dplyr::arrange(desc(trait_tally_JUM_differential))
# get a tally of context e.g. intron or coding sequence variant
tibble_JUM_differential_AS.event.ID_snps_summary_by_context <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_JUM_differential" = n()) %>% dplyr::arrange(desc(context_tally_JUM_differential))

```

##### JUM constitutive

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end_constitutive <- tibble(
  "AS_event_ID" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_constitutive_array.tree <- tibble_AS.event.IDs_chr_start_end_constitutive %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_constitutive <- future_map(.x = list_JUM_AS.event.IDs_constitutive_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_differential_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog %>% dplyr::filter(CHR_ID == .x$chr &
                                                .x$start %>% as.numeric <= CHR_POS &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .x$AS_event_ID,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end,
                                                  "AS_event_ID_splicemode" = .x$splicemode)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog", "add_column")))

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_constitutive %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_JUM_constitutive" = n()) %>% dplyr::arrange(desc(trait_tally_JUM_constitutive))
# get a tally of context e.g. intron or coding sequence variant
tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_JUM_constitutive" = n()) %>% dplyr::arrange(desc(context_tally_JUM_constitutive))

```

##### psi-sigma differential

```{r}

# extract chr, start and end from diff_exon_coords
tibble_psisigma_differential_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_psisigma_differential_chr_start_end_array.tree <- tibble_psisigma_differential_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_differential <- future_map(.x = list_psisigma_differential_chr_start_end_array.tree, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog %>% dplyr::filter(CHR_ID == .x$chr &
                                                               .x$start %>% as.numeric <= CHR_POS &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("event_region_coords" = .x$event_region_coords,
                                                "event_region_start" = .x$start,
                                                "event_region_end" = .x$end,
                                                "event_region_splicemode" = .x$splicemode)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog", "add_column")))

tibble_psisigma_differential_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_differential %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_differential_all_overlapping_snps_filtered <- tibble_psisigma_differential_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_psisigma_differential_snps_summary_by_trait <- tibble_psisigma_differential_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_PSIsigma_differential" = n()) %>% dplyr::arrange(desc(trait_tally_PSIsigma_differential))
# get a tally of context e.g. intron or coding sequence variant
tibble_psisigma_differential_snps_summary_by_context <- tibble_psisigma_differential_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_PSIsigma_differential" = n()) %>% dplyr::arrange(desc(context_tally_PSIsigma_differential))

```


##### psi-sigma constitutive

```{r}

# extract chr, start and end from diff_exon_coords
tibble_psisigma_constitutive_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_psisigma_constitutive_chr_start_end_array.tree <- tibble_psisigma_constitutive_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_constitutive <- future_map(.x = list_psisigma_constitutive_chr_start_end_array.tree, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog %>% dplyr::filter(CHR_ID == .x$chr &
                                                               .x$start %>% as.numeric <= CHR_POS &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("event_region_coords" = .x$event_region_coords,
                                                "event_region_start" = .x$start,
                                                "event_region_end" = .x$end,
                                                "event_region_splicemode" = .x$splicemode)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog", "add_column")))

tibble_psisigma_constitutive_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_constitutive %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_constitutive_all_overlapping_snps_filtered <- tibble_psisigma_constitutive_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_psisigma_constitutive_snps_summary_by_trait <- tibble_psisigma_constitutive_all_overlapping_snps_filtered %>% dplyr::summarise("trait_tally_PSIsigma_constitutive" = n()) %>% dplyr::arrange(desc(trait_tally_PSIsigma_constitutive))
# get a tally of context e.g. intron or coding sequence variant
tibble_psisigma_constitutive_snps_summary_by_context <- tibble_psisigma_constitutive_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_PSIsigma_constitutive" = n()) %>% dplyr::arrange(desc(context_tally_PSIsigma_constitutive))

```

#### combine overlap data

```{r}

# merge trait and context tally tables together for all data series and melt
long_tibble_combined_overlap_traits <- list(tibble_JUM_differential_AS.event.ID_snps_summary_by_trait, 
                                    tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait, 
                                    tibble_psisigma_differential_snps_summary_by_trait,
                                    tibble_psisigma_constitutive_snps_summary_by_trait) %>% 
  purrr::reduce(dplyr::left_join, by = "DISEASE/TRAIT") %>%
  # arrange in descending order of geometric mean
  dplyr::arrange((trait_tally_JUM_differential * trait_tally_JUM_constitutive * trait_tally_PSIsigma_differential * trait_tally_PSIsigma_constitutive) ^ (1/4)) %>%
  na.omit %>%
  tail(n = 8) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = "DISEASE/TRAIT", .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "DISEASE/TRAIT", variable.name = "tool_diff.cons", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {column <- factor(x = x, levels = c("trait_tally_PSIsigma_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_JUM_constitutive", "trait_tally_JUM_differential")); return(column)} )

long_tibble_combined_overlap_contexts <- list(tibble_JUM_differential_AS.event.ID_snps_summary_by_context, 
                                      tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context, 
                                      tibble_psisigma_differential_snps_summary_by_context,
                                      tibble_psisigma_constitutive_snps_summary_by_context) %>% 
  purrr::reduce(dplyr::left_join, by = "CONTEXT") %>%
  # arrange in descending order of geometric mean
  dplyr::arrange(((context_tally_JUM_differential) ^ (1/4)) * 
                   ((context_tally_JUM_constitutive) ^ (1/4)) * 
                   ((context_tally_PSIsigma_differential) ^ (1/4)) * 
                   ((context_tally_PSIsigma_constitutive) ^ (1/4))) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = "CONTEXT", .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "CONTEXT", variable.name = "tool_diff.cons", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {column <- factor(x = x, levels = c("context_tally_PSIsigma_constitutive", "context_tally_PSIsigma_differential", "context_tally_JUM_constitutive", "context_tally_JUM_differential")) ; return(column)} )

```

#### bootstrapping to calculate p-value of region overlapping with SNP

##### JUM differential
###### traits

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_differential_traits <- future_map(.x = tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[tibble_JUM_differential_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
  # DEBUG ###
  # .x <- tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[tibble_JUM_differential_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT` %>% .[[1]]
  ###########
  
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>% 
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_differential[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_differential_traits <- list_permtest_results_JUM_differential_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_JUM_differential"))

save(list_permtest_results_JUM_differential_traits, file = paste(results_dir, "list_permtest_results_JUM_differential_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_differential_contexts <- future_map(.x = tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
  # DEBUG ###
  # .x <- tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT` %>% .[[10]]
  ###########
  
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutely necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_differential[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_differential_contexts <- list_permtest_results_JUM_differential_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_JUM_differential"))

save(list_permtest_results_JUM_differential_contexts, file = paste(results_dir, "list_permtest_results_JUM_differential_contexts.Rlist", sep = ""))

```

 
##### JUM constitutive
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_constitutive_traits <- future_map(.x = tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait[tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_constitutive[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = FALSE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_constitutive_traits <- list_permtest_results_JUM_constitutive_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_JUM_constitutive"))

save(list_permtest_results_JUM_constitutive_traits, file = paste(results_dir, "list_permtest_results_JUM_constitutive_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_constitutive_contexts <- future_map(.x = tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_constitutive[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_constitutive_contexts <- list_permtest_results_JUM_constitutive_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_JUM_constitutive"))

save(list_permtest_results_JUM_constitutive_contexts, file = paste(results_dir, "list_permtest_results_JUM_constitutive_contexts.Rlist", sep = ""))

```


##### PSI-Sigma differential
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_differential_traits <- future_map(.x = tibble_psisigma_differential_snps_summary_by_trait[tibble_psisigma_differential_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 500, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_psisigma_differential_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_differential_traits <- list_permtest_results_PSIsigma_differential_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_PSIsigma_differential"))

save(list_permtest_results_PSIsigma_differential_traits, file = paste(results_dir, "list_permtest_results_PSIsigma_differential_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_differential_contexts <- future_map(.x = tibble_psisigma_differential_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 500, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_psisigma_differential_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_differential_contexts <- list_permtest_results_PSIsigma_differential_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_PSIsigma_differential"))

save(list_permtest_results_PSIsigma_differential_contexts, file = paste(results_dir, "list_permtest_results_PSIsigma_differential_contexts.Rlist", sep = ""))

```


##### PSI-Sigma constitutive
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_constitutive_traits <- future_map(.x = tibble_psisigma_constitutive_snps_summary_by_trait[tibble_psisigma_constitutive_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_constitutive_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 500, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_psisigma_constitutive_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_constitutive_traits <- list_permtest_results_PSIsigma_constitutive_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_PSIsigma_constitutive"))

save(list_permtest_results_PSIsigma_constitutive_traits, file = paste(results_dir, "list_permtest_results_PSIsigma_constitutive_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_constitutive_contexts <- future_map(.x = tibble_psisigma_constitutive_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_constitutive_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 500, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_items_chr_start_end, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 500, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 64)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }) %>% set_names(tibble_psisigma_constitutive_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_constitutive_contexts <- list_permtest_results_PSIsigma_constitutive_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_PSIsigma_constitutive"))

save(list_permtest_results_PSIsigma_constitutive_contexts, file = paste(results_dir, "list_permtest_results_PSIsigma_constitutive_contexts.Rlist", sep = ""))

```


##### combine bootstrap significance tibbles

```{r}

long_tibble_combined_significance_traits <- list(tibble_significance_logical_test_JUM_differential_traits, 
                                                 tibble_significance_logical_test_JUM_constitutive_traits, 
                                                 tibble_significance_logical_test_PSIsigma_differential_traits,
                                                 tibble_significance_logical_test_PSIsigma_constitutive_traits) %>% 
  purrr::reduce(dplyr::full_join, by = "DISEASE/TRAIT") %>%
  (function(x) {y <- x; y[is.na(y)] <- FALSE; return(y)} ) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "DISEASE/TRAIT", variable.name = "tool_diff.cons", value.name = "significant") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {gsub(x = x, pattern = "significant_", replacement = "trait_tally_")} )

long_tibble_combined_significance_contexts <- list(tibble_significance_logical_test_JUM_differential_contexts, 
                                                 tibble_significance_logical_test_JUM_constitutive_contexts, 
                                                 tibble_significance_logical_test_PSIsigma_differential_contexts,
                                                 tibble_significance_logical_test_PSIsigma_constitutive_contexts) %>% 
  purrr::reduce(dplyr::full_join, by = "CONTEXT") %>%
  (function(x) {y <- x; y[is.na(y)] <- FALSE; return(y)} ) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "CONTEXT", variable.name = "tool_diff.cons", value.name = "significant") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {gsub(x = x, pattern = "significant_", replacement = "context_tally_")} )

```

#### combine the traits and significance tables and plot on the same graph

```{r}

long_tibble_combined_overlap_and_significance_traits <- dplyr::left_join(long_tibble_combined_overlap_traits, long_tibble_combined_significance_traits, by = c("DISEASE/TRAIT", "tool_diff.cons")) %>% dplyr::mutate_at(.vars = c("DISEASE/TRAIT", "tool_diff.cons"), .funs = as_factor) %>% (function(x) {y <- x; y$`DISEASE/TRAIT` <- factor(x = x$`DISEASE/TRAIT`, levels = long_tibble_combined_overlap_traits$`DISEASE/TRAIT` %>% levels); y$`tool_diff.cons` <- factor(x = x$`tool_diff.cons`, levels = long_tibble_combined_overlap_traits$tool_diff.cons %>% levels); return(y)} )
long_tibble_combined_overlap_and_significance_contexts <- dplyr::left_join(long_tibble_combined_overlap_contexts, long_tibble_combined_significance_contexts, by = c("CONTEXT", "tool_diff.cons")) %>% dplyr::mutate_at(.vars = c("CONTEXT", "tool_diff.cons"), .funs = as_factor) %>% (function(x) {y <- x; y$`CONTEXT` <- factor(x = x$`CONTEXT`, levels = long_tibble_combined_overlap_contexts$CONTEXT %>% levels); y$`tool_diff.cons` <- factor(x = x$`tool_diff.cons`, levels = long_tibble_combined_overlap_contexts$tool_diff.cons %>% levels); return(y)} )

# combined tally plot, traits
ggplot(data = long_tibble_combined_overlap_and_significance_traits, aes(x = `DISEASE/TRAIT`, y = tally, fill = tool_diff.cons)) +
  geom_col_pattern(position = "dodge", aes(pattern = tool_diff.cons), pattern_spacing = 0.01, pattern_density = 0.1, pattern_colour = "white", size = 0.2, colour = "black") +
  scale_pattern_discrete(name = "Data series", 
                         breaks = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                         limits = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                         labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                         choices = c("none", "stripe", "none", "stripe")) +
  scale_fill_manual(name = "Tool", 
                    breaks = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                    limits = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                    labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                    values = c("purple3", "purple3", "firebrick4", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, long_tibble_combined_overlap_and_significance_traits$tally %>% max * 1.2)) +
  ggtitle("Top 8 traits, JUM and PSI-Sigma, differential and constitutive") +
  ylab("# Overlapping SNPs") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_SNPs_traits_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 16, height = 16, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_SNPs_traits_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 16, height = 16, units = "cm")

# combined tally plot, contexts
ggplot(data = long_tibble_combined_overlap_and_significance_contexts, aes(x = `CONTEXT`, y = tally, fill = tool_diff.cons)) +
  geom_col_pattern(position = "dodge", aes(pattern = tool_diff.cons), pattern_spacing = 0.01, pattern_density = 0.1, pattern_colour = "white", size = 0.2, colour = "black") +
  scale_pattern_discrete(name = "Data series", 
                         breaks = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                         limits = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                         labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                         choices = c("none", "stripe", "none", "stripe")) +
  scale_fill_manual(name = "Tool", 
                    breaks = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                    limits = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                    labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                    values = c("purple3", "purple3", "firebrick4", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  geom_text(stat = "identity", aes(y = tally + 150 + ((floor(tally %>% log10) + 1) * 250), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 30)) +
  ylim(c(0, long_tibble_combined_overlap_and_significance_contexts$tally %>% max * 1.4)) +
  ggtitle("SNP Contexts tally, JUM and PSI-Sigma, differential and constitutive") +
  ylab("# Overlapping SNPs") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_SNPs_contexts_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 16, height = 16, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_SNPs_contexts_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 16, height = 16, units = "cm")

```

## Look for coordinate-level overlap between SRSF2 CLIP-Seq sites and differential/constitutive VSRs.

### set match tolerance (size of RBP footprint or splicing enhancer/silencer site)

```{r}

match_tolerance_start <- 0
match_tolerance_end <- 0

```

```{r}

tibble_AS.event.IDs_chr_start_end_differential
tibble_AS.event.IDs_chr_start_end_constitutive

tibble_psisigma_differential_chr_start_end
tibble_psisigma_constitutive_chr_start_end

# PSI-Sigma constitutive
## loop thru each matched SNP and look for overlap with CLIP-Seq region within a tolerance range
## list-ify the matched SNP chr and coords.
list_query_VSR_coord_array.tree <- tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% array_tree
## parallel loop thru each list-ified matched SNP to find whether there is a match with an entry in the CLIP-Seq data.
vector_matched_VSR_with_CLIP_seq_logical <- future_map(.x = list_query_VSR_coord_array.tree,
                                                             .f = function(a1) {
                                                               
                                                               # DEBUG ###
                                                               # a1 <- list_query_VSR_coord_array.tree[[1]]
                                                               ###########
                                                               
                                                               any(tibble_GSE111900_SRSF2_coord_info_processed$chr == a1$chr & 
                                                                     (tibble_GSE111900_SRSF2_coord_info_processed$start %>% type.convert) - match_tolerance_start <= a1$end %>% type.convert &
                                                                     (tibble_GSE111900_SRSF2_coord_info_processed$end %>% type.convert) + match_tolerance_end >= a1$start %>% type.convert) %>% return
                                                               
                                                             }, .progress = TRUE, .options = future_options(globals = c("tibble_GSE111900_SRSF2_coord_info_processed", "match_tolerance_start", "match_tolerance_end")) ) %>% unlist

# filter the original coord table by those that overlapped with clip-seq data.
tibble_VSRs_with_overlap <- tibble_psisigma_differential_chr_start_end[which(vector_matched_VSR_with_CLIP_seq_logical), ]

```

### look for coordinate-level overlap between matched SNPs and CLIP-Seq sites

```{r}

tibble_GSE111900_SRSF2_coord_info_processed

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered
tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered

tibble_psisigma_differential_all_overlapping_snps_filtered
tibble_psisigma_constitutive_all_overlapping_snps_filtered

# PSI-Sigma constitutive
## loop thru each matched SNP and look for overlap with CLIP-Seq region within a tolerance range
## list-ify the matched SNP chr and coords.
list_matched_SNP_chr_coord_array.tree <- tibble_psisigma_differential_all_overlapping_snps_filtered[, c("CHR_ID", "CHR_POS")] %>% array_tree
## parallel loop thru each list-ified matched SNP to find whether there is a match with an entry in the CLIP-Seq data.
vector_matched_SNP_overlap_with_CLIP_seq_logical <- future_map(.x = list_matched_SNP_chr_coord_array.tree,
                                                             .f = function(a1) {
                                                               
                                                               # DEBUG ###
                                                               a1 <- list_matched_SNP_chr_coord_array.tree[[1]]
                                                               ###########
                                                               
                                                               any(tibble_GSE111900_SRSF2_coord_info_processed$chr == a1$CHR_ID & 
                                                                     (tibble_GSE111900_SRSF2_coord_info_processed$start %>% type.convert) - match_tolerance_start <= a1$CHR_POS %>% type.convert &
                                                                     (tibble_GSE111900_SRSF2_coord_info_processed$end %>% type.convert) + match_tolerance_end >= a1$CHR_POS %>% type.convert) %>% return
                                                               
                                                             }, .progress = TRUE, .options = future_options(globals = c("tibble_GSE111900_SRSF2_coord_info_processed", "match_tolerance_start", "match_tolerance_end")) ) %>% unlist

tibble_psisigma_constitutive_all_overlapping_snps_filtered_with_clipseq_overlap

```


## Assess whether SNPs lie in Ago2 CLIP binding sites

### Append SNP information to the Ago2 CLIP table

```{r}

# map over the Ago2 tibble and the GWAS catalog tibble by chromosome
## but first, we have to find which chromosomes the lists have in common
chr_in_common <- intersect(list_tibble_ebi_gwas_catalog_by_chr %>% names, list_ago2_iclip_binding_sites_by_chr %>% names)

tibble_ago2_iclip_binding_sites_with_SNP_info <- future_map2(
  .x = list_ago2_iclip_binding_sites_by_chr[chr_in_common],
  .y = list_tibble_ebi_gwas_catalog_by_chr[chr_in_common],
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_ago2_iclip_binding_sites_by_chr[chr_in_common][[1]]
    # a2 <- list_tibble_ebi_gwas_catalog_by_chr[chr_in_common][[1]]
    ###########
    
    list_ago2_iclip_per_element_with_snp <- future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[1]]
        ###########
        
        # create NA otherwise the original iclip data will be erased upon dplyr::bind_cols
        tibble_matching_SNP_entries_na <- a2[1, ]
        tibble_matching_SNP_entries_na[1, ] <- NA
        
        # get SNP entries which fall within the binding site
        tibble_matching_SNP_entries <- a2[which(a2$CHR_POS >= b1$start %>% type.convert &
                                                  a2$CHR_POS <= b1$stop %>% type.convert), ]
        
        # dplyr join the matching SNP entries back onto the binding site entry
        if (tibble_matching_SNP_entries %>% nrow > 0) {
          tibble_binding_site_entry_with_SNP_entry <- dplyr::bind_cols(b1 %>% as_tibble, tibble_matching_SNP_entries)
        } else if (tibble_matching_SNP_entries %>% nrow == 0) {
          tibble_binding_site_entry_with_SNP_entry <- dplyr::bind_cols(b1 %>% as_tibble, tibble_matching_SNP_entries_na)
        }
        
        return(tibble_binding_site_entry_with_SNP_entry)
        
      } )
    
    return(list_ago2_iclip_per_element_with_snp)
    
  }, .progress = TRUE) %>% flatten %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble


## create list of vectors of differential positions (genomic coords)
list_of_vectors_JUM_differential_exon_positions <- tibble_JUM_junction_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_JUM <- future_map2(.x = list_of_vectors_JUM_differential_exon_positions,
                                                                  .y = tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree,
                                                                  .f = function(a1, a2) {
                                                                    
                                                                    # DEBUG ###
                                                                    # a1 <- list_of_vectors_JUM_differential_exon_positions[[1]]
                                                                    # a2 <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree %>% .[[1]]
                                                                    ###########
                                                                    
                                                                    # get chromosome
                                                                    current_chr <- gsub(x = a2$AS_event_ID, pattern = "^([^\\_]+)\\_.*", replacement = "\\1")
                                                                    
                                                                    # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                    vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                    
                                                                    # retrieve iCLIP entries based on logical index
                                                                    tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                    
                                                                    return(purrr::splice(a2,
                                                                                         "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                  }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_JUM_pruned <- list_matched_iCLIP_entries_per_differential_region_JUM %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_JUM_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_JUM_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("AS_event_ID", "splicemode", "Gene")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble


```

# Bulk JUM, PSI-Sigma and scRNA-Seq Sierra !!! WARNING: TEMPORARILY ON HOLD !!!

## Find extent of genes with differential AS in common between Sierra and JUM/PSI-Sigma

```{r}

vector_sierra_genes_clusterwise <- tibble_sierra_DTU_clusterwise_all_simplified$gene_name %>% unique %>% mixedsort %>% na.omit

vector_JUM_diff_genes <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% mixedsort %>% na.omit

vector_PSIsigma_diff_genes <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% mixedsort %>% na.omit

cat("\nSierra total DS genes: ", vector_sierra_genes_clusterwise %>% length)
cat("\nJUM total DS genes: ", vector_JUM_diff_genes %>% length)
cat("\nPSI-Sigma total DS genes: ", vector_PSIsigma_diff_genes %>% length)

cat("\nSierra and JUM DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_JUM_diff_genes) %>% length)
cat("\nSierra and PSI-Sigma DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_PSIsigma_diff_genes) %>% length)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_JUM_diff_genes),
  category.names = c("Sierra" , "JUM"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_JUM.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "mediumorchid4")
)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_PSIsigma_diff_genes),
  category.names = c("Sierra" , "PSI-Sigma"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_PSIsigma.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "brown4")
)

```

## Find the extent of overlap between the Sierra differential peaks and JUM/PSI-Sigma

```{r}

# list-ify the JUM contributing junctions using array_tree then unpack using strsplit
list_JUM_diff_junctions_array.tree <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("contributing_junction_IDs", "chr", "start", "end", "strand")] %>% 
  array_tree %>% 
  purrr::map_depth(.depth = 2, .f = ~strsplit(.x, split = ";")) %>%
  purrr::map(~.x %>% flatten %>% as_tibble)

# match to Sierra's differential junctions

```


