---
title: "Multiomic Synthesis - Phospho-proteo-spliceome project"
author: "Angel Liang"
date: "16/04/2020"
output: html_document
---

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
library(extrafont)
# font_import(paths = "~/.local/share/fonts/")
loadfonts(device = "pdf")
windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(genefilter)

library(ggplot2)
library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
library(svglite)
library(scales)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)
library(data.table)

library(crayon)
library(VennDiagram)

library(biomaRt)
ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", mirror = "asia")
library(systemPipeR)
library(GOstats)
library(PFAM.db)
# library(bc3net)

# library(ComplexHeatmap)

# library(ggdendro)
# library(data.table)
# library(Rfast)

shared_dir <- "Z:/"
# shared_dir <- "/media/Ubuntu/sharedfolder/"

results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/multiomic_synthesis/results/"
# results_dir <- "/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/multiomic_synthesis/results/"

# results_directory_figures <- paste(results_dir, "figures/", sep="")
# 
# if(! dir.exists(results_directory_figures) ) {
#      dir.create(results_directory_figures, recursive = TRUE)}

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf_with_NMD_flagged <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E2.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E2 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E2.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E3 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E3.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E4 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E4.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E5 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E5.gtf") %>% as_tibble

```

## define functions

### Enrichment/Gene Ontology

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

```

### FUNCTION TO CHANGE THE NAME OF ONE COLUMN WITH EXACT MATCH

```{r}

rename_column_exact <- function(input_tibble, target_column, output_colname) {
  
  output_tibble <- input_tibble
  
  colnames(output_tibble)[which(colnames(output_tibble) == target_column)] <- output_colname
  
  return(output_tibble)
  
}

```


### function to split a whole table by a delimiter in a column

```{r}

split_delimited_column_in_table <- function(input_table, target_colname, split, columns_to_deduplicate = NULL) {
  
  # DEBUG ###
  # input_table <- tibble_phosphosites_with_protein_group_ids
  # target_colname <- "Protein.group.IDs"
  # split = "\\;"
  # columns_to_deduplicate <- c("id", "1h_vs_ud|IB")
  ###########
  
  # list-ify the target column
  list_target_column_strsplit_per_element <- input_table[, target_colname] %>% unlist %>% strsplit(., split = split)
  
  # map length
  vector_split_lengths <- list_target_column_strsplit_per_element %>% purrr::map(~length(.x)) %>% unlist(use.names = FALSE)
  
  # repeat table according to the split lengths
  row_indices_of_table_repeated_by_split <- rep(x = 1:nrow(input_table), times = vector_split_lengths)
  
  input_table_repeated_by_split <- input_table[row_indices_of_table_repeated_by_split, ]
  
  # replace target column with split values
  input_table_repeated_by_split[, target_colname] <- list_target_column_strsplit_per_element %>% unlist(use.names = FALSE)
  
  split_table <- input_table_repeated_by_split
  
  # if specified, append an index to a particular column
  if (is.null(columns_to_deduplicate) == FALSE) {
    
    # get the duplicated row indices where split lengths > 1
    indices_of_duplicates <- which(vector_split_lengths > 1)
    
    # get the repetition number where split lengths > 1
    repetition_numbers_of_duplicates <- vector_split_lengths[which(vector_split_lengths > 1)]
    
    # list-ify the columns to be appended
    list_deduplicated_columns <- input_table[, columns_to_deduplicate] %>% array_tree(margin = 2) %>% purrr::map(~array_tree(.x))
    
    # map over each column, split the target element and add _[0-9]+
    list_deduplicated_columns_split <- purrr::map(.x = list_deduplicated_columns, .f = function(a1) {
      
      # map a subset each of the L2 (elements of a column)
      a1[indices_of_duplicates] <- purrr::map2(.x = a1[indices_of_duplicates], .y = repetition_numbers_of_duplicates, 
                  .f = ~rep(.x, times = .y) %>% unlist %>% paste(., 1:.y, sep = "_"))
      
      return(a1 %>% unlist)
      
    } )
    
    # tibblise
    tibble_deduplicated_columns_split <- list_deduplicated_columns_split %>% as_tibble
    
    # add back every row onto the split table
    for (dedupe_colname in columns_to_deduplicate) {
      
      split_table[, dedupe_colname] <- tibble_deduplicated_columns_split[, dedupe_colname]
      
    }
    
  }
  
  return(split_table %>% type_convert)
  
}

```


### function to convert a vector of numeric positions into sets of simple ranges

```{r}

# USAGE:
# input_vector: vector of numerical values to convert to ranges
# metadata (optional): vector the same length as `input_vector` containing information such as chromosome.

vector.of.positions_to_simple.ranges <- function(input_vector, metadata_vector) {
  
  # DEBUG ###
  # tibble_input_vector_and_metadata <- tibble_JUM_valid_phosphosites_with_overlap %>% 
  #   dplyr::select(chrom, genome_relative_positions_phosphosite) %>% 
  #   split_delimited_column_in_table(input_table = ., split = ",", target_colname = "genome_relative_positions_phosphosite")
  # input_vector <- tibble_input_vector_and_metadata$genome_relative_positions_phosphosite
  # metadata_vector <- tibble_input_vector_and_metadata$chrom
  ###########
  
  # tibblise and soft-convert to numeric.
  # throw error if still not numeric.
  tibble_input_vector <- tibble::enframe(input_vector, value = "vec", name = NULL) %>% type_convert
  
  if (tibble_input_vector$vec %>% data.class != "numeric") {
    stop("check if the input vector is numeric")
  } 
  
  # join the metadata
  tibble_input_vector_and_metadata <- dplyr::bind_cols(tibble_input_vector, metadata_vector)
  
  # subset and list-ify by metadata
  list_input_vector_subset_by_metadata <- tibble_input_vector_and_metadata %>% 
    dplyr::group_split(!!as.name(colnames(tibble_input_vector_and_metadata)[!colnames(tibble_input_vector_and_metadata) %in% "vec"]))
  
  # loop over the list
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  list_blockdata <- purrr::map(.x = list_input_vector_subset_by_metadata, 
                               .f = function(a1) {
                                 
                                 # DEBUG ###
                                 a1 <- list_input_vector_subset_by_metadata[[15]]
                                 ###########
                                 
                                 tibble_n_n.plus.1 <- tibble("n" = a1$vec %>% head(n = length(a1$vec) - 1),
                                                             "n.plus.1" = a1$vec %>% .[-1]) %>% 
                                   add_column("difference" = .$`n.plus.1` - .$`n`)
                                 
                                 ## if there are no gaps, then just take the genomic range as the start:end
                                 if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
                                   
                                   vec_blockCount <- 1
                                   vec_blockSizes <- length(a1$vec)
                                   vec_blockStarts <- dplyr::first(a1$vec)
                                   
                                 } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
                                   
                                   vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
                                   vec_blockStarts <- c(dplyr::first(a1$vec), 
                                                        tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
                                   vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                                                      dplyr::last(a1$vec))
                                   vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
                                   
                                 }
                                 
                                 return(list(
                                   "vec_blockCount" = vec_blockCount,
                                   "vec_blockStarts" = vec_blockStarts,
                                   "vec_blockEnds" = vec_blockEnds,
                                   "vec_blockSizes" = vec_blockSizes
                                 ))
                                 
                               } )
  
  # make the list of metadata
  list_metadata <- purrr::map(.x = list_input_vector_subset_by_metadata, .f = ~.x %>% dplyr::select(-vec) %>% unique)
  
  list_tibbles_start_end <- purrr::map2(.x = list_blockdata, 
                                        .y = list_metadata,
                                        .f = ~tibble("start" = .x$vec_blockStarts,
                                                     "end" = .x$vec_blockEnds) %>% 
                                          dplyr::bind_cols(., .y))
  
  tibble_start_end_metadata <- list_tibbles_start_end %>% rbindlist %>% as_tibble
  
  # create tibble of start end count
  
}

```

## Import files

### JUM/PSI-Sigma section

#### set global vars.

```{r}

vector_OBseries_timepoints_raw <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")
vector_OBseries_timepoints_edited <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

```

#### Import differential/constitutive/all detected tables

```{r}

# JUM ###
tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/5x5_SOM_997_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_long.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/5x5_SOM_997_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_long.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/wide_table_of_1062_junctions_dPSI_OB_diff_any_qvalue0.01_any_dPSI_greaterthan_0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/wide_table_of_1062_junctions_dPSI_OB_diff_any_qvalue0.01_any_dPSI_greaterthan_0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_JUM_all_junctions_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/wide_table_of_all_JUM_results_37264_entries_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_all_junctions_with_na <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/wide_table_of_all_JUM_results_37264_entries_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# PSI-Sigma ###
tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/5x5_SOM_2095_exons_exon.PSI_OB_diff_any_pvalue0.01_any_deltaPSI_greaterthan_10_long.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/5x5_SOM_2095_exons_exon.PSI_OB_diff_any_pvalue0.01_any_deltaPSI_greaterthan_10_long.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/long_table_of_all_differential_exons_info_dpsi_10_anypvalue0.01_3272_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/long_table_of_all_differential_exons_info_dpsi_10_anypvalue0.01_3272_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_all_exons_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_of_all_psi.sigma_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_all_exons_with_na <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_of_all_psi.sigma_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

#### Import gene ontology enrichment tables

```{r}

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/Top inf significantly over-represented GO terms for OB series dPSI_0.15_anyqvalue0.01_983_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/Top inf significantly over-represented families for OB series dPSI_0.15_anyqvalue0.01_983_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/top_inf_GOterms_OB_series_dPSI_10_anypvalue0.01_1899_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/top_inf_PFAM_families_OB_series_dPSI_10_anypvalue0.01_1899_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

#### Import junction/exon ontology supporting info

```{r}

# JUM ###
tibble_JUM_junction_ontology_supp_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_supp_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

#### Import junction/exon ontology tables

```{r}

# JUM ###
tibble_JUM_junction_ontology_transcripts <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_biomart <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_PTM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_transcripts <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_biomart <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_PTM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

### scRNA-Seq section

#### Import Sierra DTU test results

```{r}

# Cluster-wise, simplified
tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_clusterwise_all_simplified <- tibble_sierra_DTU_clusterwise_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

# Pair-wise between clusters, simplified
tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_pairwise_clusters_all_simplified <- tibble_sierra_DTU_pairwise_clusters_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

```


### Proteome section

#### Import all the non-homolog and non-superfamily entries from Interpro

```{r}

tibble_non_family_interpro_entries <- c("interpro_active.site_entries.tsv", "interpro_binding.site_entries.tsv", "interpro_conserved.site_entries.tsv", "interpro_domain_entries.tsv", "interpro_PTM_entries.tsv", "interpro_repeat_entries.tsv") %>% 
  purrr::map(.f = ~read.delim(paste(shared_dir, .x, sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble) %>% rbindlist %>% as_tibble

```

#### Import the validated junc.exons as well as the validated phosphosites

```{r}

tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_2020.PO4_valid_phosphosites <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

#### Import the FASTA supplementary information

```{r}

# tibble_fasta_supp_info_exons <- read.delim(file = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_exons/exon_table_OB_diff_dpsi10_anypvalue0.01_3272_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

tibble_fasta_supp_info_junctions <- read.delim(file = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_junctions/junction_table_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

```

### SNP and disease section

#### import GWAS catalog

```{r}

tibble_ebi_gwas_catalog <- read_tsv(file = "Y:/eQTL_catalogue/gwas_catalog_v1.0.2-associations_e98_r2020-05-03.tsv", col_types = cols(.default = "c")) %>% 
  # can't be bothered doing fancy strsplit for such a small amount of weirdo values - i'll just take the first value out of each one instead.
  dplyr::mutate_at(.vars = c("CHR_ID", "CHR_POS"), .funs = function(x) {
  
  y <- strsplit(x, split = ";") %>% purrr::map(~strsplit(.x, split = " x ") %>% unlist %>% .[1]) %>% unlist
  
  return(y)
  
} ) %>% type_convert

```

# Comparison between JUM and PSI-Sigma

## Calculate the number of junction/exons found in common

### Calculate intersections

STRATEGY: use one table to look up other table. one-directional evidence is required and sufficient for intersection.

#### FUNCTION TO CONVERT JUM AS_EVENT_ID TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

JUM_AS.event.ID_to_chr_strand_start_end <- function(tibble) {
  
  vec_AS.event.ID_unique <- tibble$AS_event_ID %>% unique
  
  vec_chr <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\2")
  vec_start <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\3")
  vec_end <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\5")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
  
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end))
  
}

```

#### FUNCTION TO CONVERT PSI-SIGMA DIFF_EXON_COORDS TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

PSIsigma_diff.exon.coords_to_chr_strand_start_end <- function(tibble) {
  
  vec_event.region.coords <- tibble$event_region_coords
  
  vec_chr <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- tibble$matched_strand
  vec_start <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\2")
  vec_end <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\3")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
    
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end) %>% unique)
  
}

```

#### create generic function to do this job.

```{r}

calculate_intersections_from_chr_strand_start_end <- function(tibble_1, tibble_2, tibble_1_tolerance_left, tibble_1_tolerance_right) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na
  # tibble_1_tolerance_left <- 2
  # tibble_1_tolerance_right <- 2
  ###########
  
  tibble_1 <<- tibble_1
  tibble_2 <<- tibble_2
  
  # list-ify tibble_1
  list_tibble_1_array.tree <- tibble_1 %>% array_tree
  # set L1 names as identifier names
  names(list_tibble_1_array.tree) <- tibble_1$identifier
  
  # match each element of tibble_1 to tibble_2 and see if there is a valid subset found.
  list_tibble_1_to_2_matches <- future_map(.x = list_tibble_1_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_tibble_1_array.tree[[3]]
    ###########
    
    subset <- tibble_2[tibble_2$chr == .x$chr %>% paste %>% trimws, ] %>% 
      .[.$strand == .x$strand %>% paste %>% trimws, ] %>% 
      .[(.$start < (.x$end %>% paste %>% trimws %>% as.numeric) + tibble_1_tolerance_right) & (.$end > (.x$start %>% paste %>% trimws %>% as.numeric) - tibble_1_tolerance_left), ]
    
    if (nrow(subset) == 0) {
      return("no_overlap")
    } else {
      return(subset)
    }
    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_2", "tibble_1_tolerance_left", "tibble_1_tolerance_right")))
  
  # extract the list indices which had valid overlap
  vector_list.indices_with_valid_overlap <- list_tibble_1_to_2_matches %>% purrr::map(~all(.x == "no_overlap") == FALSE) %>% unlist %>% which
  # return aggregate number of overlap
  number_of_entries_with_valid_overlap <- vector_list.indices_with_valid_overlap %>% length
  # return summary list of matching table entries
  list_overlapped_table_entries <- future_imap(.x = list_tibble_1_to_2_matches[vector_list.indices_with_valid_overlap], .f = ~list("tibble_1_entry" = tibble_1[tibble_1$identifier == .y, ],
                                                                                                                                   "tibble_2_entry" = .x), .progress = TRUE, .options = future_options(globals = c("tibble_1")))
  
  return(list("number_of_entries_tibble_1" = nrow(tibble_1),
              "number_of_entries_tibble_2" = nrow(tibble_2),
              "number_of_common_entries" = number_of_entries_with_valid_overlap,
              "detailed_result" = list_overlapped_table_entries))
  
}

```

#### run the intersections

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na%>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

```

#### repeat the intersections with only genes in common

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_all_junctions_with_na %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_all_junctions_with_na %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

```

## determine the genes in common per enrichment

### FUNCTION TO LOOK FOR OVERLAPS IN EACH GO-TERM BETWEEN TWO TABLES (GOhyperGall)

```{r}

extract_common_GOTerms_GOhyperGall <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: GOID, NodeSize, Term, Ont
  colnames(tibble_1)[c(3, 4, 5, 8)] <- paste(colnames(tibble_1)[c(3, 4, 5, 8)], "_1", sep = "")
  colnames(tibble_2)[c(3, 4, 5, 8)] <- paste(colnames(tibble_2)[c(3, 4, 5, 8)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("GOID", "NodeSize", "Term", "Ont"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$SampleKeys_1)), which(is.na(joined_tibble$SampleKeys_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
  # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$SampleKeys_1, .y = joined_tibble$SampleKeys_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### FUNCTION TO LOOK FOR OVERLAPS IN EACH ENRICHMENT BETWEEN TWO TABLES (bc3net::enrichment())

```{r}

extract_common_GOTerms_bc3net <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: c("TermID", "all")
  colnames(tibble_1)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_1)[c(2, 3, 4, 5, 6)], "_1", sep = "")
  colnames(tibble_2)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_2)[c(2, 3, 4, 5, 6)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("TermID"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$genes_contained_1)), which(is.na(joined_tibble$genes_contained_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
    # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$genes_contained_1, .y = joined_tibble$genes_contained_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### calculate intersections

```{r}

tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <-
  extract_common_GOTerms_GOhyperGall(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO, 
                                     tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO)

write.table(tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO, 
            paste(results_dir, "intersection_GOTerm_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <-
  extract_common_GOTerms_bc3net(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM, 
                                tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM)

write.table(tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM, 
            paste(results_dir, "intersection_PFAM_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

## Do GO enrichment (anysig) on both combined.

```{r}

load(paste(shared_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

### hypergeometric test for GO terms

```{r}

# create vector of differential genes
vector_differential_genes_anysig_with_na <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, 
                                              tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% 
  strsplit(split = ",") %>% unlist %>% unique

# count number of differential genes
number.of.genes_differential_anysig_with_na <- vector_differential_genes_anysig_with_na %>% length

cat("\n", number.of.genes_differential_anysig_with_na, "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation")

# create list of GO categories
list_GO_categories <- c("MF", "BP", "CC") %>% array_tree

# map GO test
list_of_GO_test_tibbles_anysig_with_na_raw <- purrr::map(.x = list_GO_categories, .f = ~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = vector_differential_genes_anysig_with_na, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% type_convert) %>% set_names(list_GO_categories)

# filter out the top ~30 most significant GO terms for each node
list_of_GO_test_tibbles_anysig_with_na_top.hits <- purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_raw, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 900) %>% dplyr::filter(NodeSize < 1500) %>% dplyr::mutate_at(.vars = "Term", .funs = function(x) {stringr::str_trunc(string = x, side = "right", width = 78) %>% return}))

# print out the top hits of the GO enrichment
purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_top.hits, .f = ~.x %>% print)

# collapse into a long tibble for plot
long_tibble_GO_test_anysig_with_na_top.hits <- list_of_GO_test_tibbles_anysig_with_na_top.hits %>% rbindlist %>% as_tibble

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(long_tibble_GO_test_anysig_with_na_top.hits, aes(x = reorder(Term, -Phyper), y = -log10(Phyper))) +
  geom_col(aes(fill = SampleMatch)) +
  scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = 1, aesthetics = "fill", na.value = "yellow") +
  geom_hline(yintercept = -log10(0.05), lty = 2) +
  coord_flip() +
  facet_wrap(Ont ~ ., ncol = 3, scales = "free_y") +
  ggtitle(paste("Top 900 significantly over-represented GO terms for OB series for JUM and PSI-Sigma combined")) +
  xlab("GO term") +
  ylab(expression(log["10"](P["b-hoch"]))) +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype="solid", colour ="black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) 

# write table of top 30 results
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of every enrichment
write.table(x = list_of_GO_test_tibbles_anysig_with_na_raw %>% purrr::map(~dplyr::arrange(.x, Phyper)) %>% rbindlist, file = paste(results_dir, "top_inf_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of geneset
write.table(x = vector_differential_genes_anysig_with_na, file = paste(results_dir, "geneset_OBseries_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
  
```


## Draw a consensus SOM which merges JUM and PSI-Sigma together.

### Tally up the number of repeated LSVs per gene.

```{r}

tibble_exon_tally_per_gene_PSIsigma <- tibble_PSIsigma_scaled_PSI_timeseries_wide %>% 
  split_delimited_column_in_table(input_table = ., target_colname = "matched_gene_names", split = ",") %>%
  dplyr::distinct(matched_gene_names, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(diff_exon_coords, .keep_all = TRUE) %>%
  dplyr::group_by(matched_gene_names) %>% 
  dplyr::summarise("PSIsigma_tally" = n()) %>%
  dplyr::arrange(desc(PSIsigma_tally)) %>%
  dplyr::rename("Gene" = "matched_gene_names")

ggplot(data = tibble_exon_tally_per_gene_PSIsigma %>% na.omit %>% dplyr::filter(tally > 1), aes(x = tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("PSI-Sigma tally, diff_exon_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

tibble_AS_event_ID_tally_per_gene_JUM <- tibble_JUM_scaled_PSI_timeseries_wide %>% 
  dplyr::distinct(Gene, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(AS_event_ID, .keep_all = TRUE) %>%
  dplyr::group_by(Gene) %>% 
  dplyr::summarise("JUM_tally" = n()) %>%
  dplyr::arrange(desc(JUM_tally))

ggplot(data = tibble_AS_event_ID_tally_per_gene_JUM %>% na.omit %>% dplyr::filter(tally > 1), aes(x = tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("JUM tally, AS_event_ID per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

# merge the two tallies together for co-plotting
tibble_AS_event_ID_tally_per_gene_combined <- dplyr::full_join(tibble_AS_event_ID_tally_per_gene_JUM, tibble_exon_tally_per_gene_PSIsigma, by = "Gene")

tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")][is.na(tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")])] <- 0

# melt into long form for combined ggplot
long_tibble_AS_event_ID_tally_per_gene_combined <- tibble_AS_event_ID_tally_per_gene_combined %>%
  na.omit %>%
  reshape2::melt(id.vars = "Gene", value.name = "tally", variable.name = "tool") %>% as_tibble

long_tibble_AS_event_ID_tally_per_gene_combined[, "tally"] <- long_tibble_AS_event_ID_tally_per_gene_combined$tally %>% as.character

write.table(x = long_tibble_AS_event_ID_tally_per_gene_combined, file = paste(results_dir, "long_tibble_AS_event_ID_tally_per_gene_combined.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# create tally frequency
long_tibble_AS_event_ID_tally_per_gene_combined_tally <- long_tibble_AS_event_ID_tally_per_gene_combined %>% 
  dplyr::group_by(tool, tally) %>% 
  dplyr::summarise("frequency" = n()) %>% 
  # tidyr complete for consistent bar width
  tidyr::complete(tool, tally)

# combined tally plot
ggplot(data = long_tibble_AS_event_ID_tally_per_gene_combined_tally, aes(x = tally, y = frequency, fill = tool)) +
  geom_bar(stat = "identity", position = position_dodge(width = 1)) +
  geom_text(stat = "identity", aes(label = frequency), position = position_dodge(width = 1), angle = 90, hjust = -0.1) +
  scale_x_discrete(breaks = c(max(long_tibble_AS_event_ID_tally_per_gene_combined$tally) : 2) %>% as.character, limits = c(max(long_tibble_AS_event_ID_tally_per_gene_combined$tally) : 2) %>% as.character) +
  scale_fill_manual(breaks = c("JUM_tally", "PSIsigma_tally"), labels = c("JUM", "PSI-Sigma"), values = c("purple3", "firebrick4")) +
  ylim(c(0, 280)) +
  ggtitle("Combined tally, AS_event_ID/diff_exon_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_highest_exons_LSVs_per_gene_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 6, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_highest_exons_LSVs_per_gene_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 6, units = "cm")

```

### preprocessing of tables in preparation for mixing

```{r}

# create unique ID that can be traced.
tibble_PSIsigma_scaled_PSI_timeseries_wide_processed <- tibble_PSIsigma_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("PSIsigma", .$matched_gene_names, .$diff_exon_coords, .$splicemode, .$matched_strand, sep = "|")) %>%
  dplyr::select(id, timepoint, scaled_PSI_value)

tibble_JUM_scaled_PSI_timeseries_wide_processed <- tibble_JUM_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("JUM", .$Gene, .$AS_event_ID, .$sub_junction_start_coor, .$sub_junction_end_coor, .$splicemode, sep = "|")) %>%
  dplyr::select(id, timepoint, scaled_PSI_value)

# join
tibble_JUM_PSIsigma_PSI_timeseries_merged <- dplyr::bind_rows(tibble_PSIsigma_scaled_PSI_timeseries_wide_processed, tibble_JUM_scaled_PSI_timeseries_wide_processed)
## fix the timepoint names
tibble_JUM_PSIsigma_PSI_timeseries_merged[, "timepoint"] <- gsub(x = tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint, pattern = "ud", replacement = "MSC")
tibble_JUM_PSIsigma_PSI_timeseries_merged[, "timepoint"] <- gsub(x = tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint, pattern = "24h", replacement = "1d")

# dcast into a wide tibble
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- reshape2::dcast(data = tibble_JUM_PSIsigma_PSI_timeseries_merged,
                                                                  formula = id ~ timepoint,
                                                                  fun.aggregate = sum,
                                                                  value.var = "scaled_PSI_value") %>% as_tibble %>% .[, c("id", vector_OBseries_timepoints_edited)]

# rescale values
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### Skim off the top and bottom most included exons/LSVs to get biomarkers at each timepoint.

```{r}

# melt into long form
long_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% reshape2::melt(id.vars = "id", variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# subset by timepoint
list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint <- purrr::map(.x = long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint %>% unique,
                                                                               .f = ~long_tibble_JUM_PSIsigma_PSI_timeseries_merged[long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint == .x, ])

# take the items with scaled PSI greater/less than +/-1.
# rbind and tibblise
list_biomarkers_JUM_PSIsigma_per_timepoint <- list(
  "inclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value >= 1)),
  "exclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value <= -1))
) %>% purrr::map(~rbindlist(.x) %>% as_tibble)

# create tally of counts to determine which markers are unique
# splice in unique counts
list_biomarkers_JUM_PSIsigma_per_timepoint <- list_biomarkers_JUM_PSIsigma_per_timepoint %>% 
  purrr::map(~dplyr::left_join(.x, .x %>% dplyr::group_by(id) %>% dplyr::summarise("uniqueness_tally" = n()))) %>%
  purrr::splice(
    "unique_inclusion" = .$inclusion %>% dplyr::filter(uniqueness_tally == 1),
    "unique_exclusion" = .$exclusion %>% dplyr::filter(uniqueness_tally == 1)
  )

# save the list
save(list_biomarkers_JUM_PSIsigma_per_timepoint, file = paste(results_dir, "list_biomarkers_JUM_PSIsigma_per_timepoint.Rlist", sep = ""))

```

### TRADITIONAL SOM

#### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# OB series #####

som_5_by_5_OBseries_table  <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited]

som_5_by_5_OBseries_table <- som_5_by_5_OBseries_table %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_OBseries <- som(som_5_by_5_OBseries_table, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries <- cbind(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, c("id")], som_5_by_5_OBseries_table, cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("id", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### THE GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of PSI values for JUM and PSI-Sigma")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Scaled PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("wide_tibble_JUM_PSIsigma_PSI_timeseries_merged", "dplyr", "som")) ) %>% as.data.frame

# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% Rfast::Dist(method = "euclidean") %>% as.dist
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  xlab(b2) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for clustering by PSI\nOB spliceome: JUM and PSI-Sigma", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED MQ RATIOS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combined.*tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "\\|", n = 5) %>% as_tibble %>% setNames(c("tool", "gene", "event_or_exon_coords", "splicemode", "matched_strand")),
                                                             wide_tibble_consensus_clusters_MQ_ratios %>% dplyr::select(-id))

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

cat("\nnumber of unique items originally: ", wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
vector_items_chucked_out <- setdiff(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id %>% unique, wide_tibble_consensus_clusters_MQ_ratios$id %>% unique)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("tool", "gene", "event_or_exon_coords", "splicemode", "matched_strand", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_PSI" = mean(scaled_PSI))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_PSI, group = paste(tool, gene, event_or_exon_coords, splicemode)), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_PSI, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI\n",
                "JUM and PSI-Sigma\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled MQ ratios") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 35, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 35, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster, separate and summed PSI

#### preparation of separate data frames containing gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot, separate PSI
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```




# JUM, PSI-Sigma and proteome/phosphoproteome.

## Filter the junction/exon ontology by validated junc.exons
## Match the validated JUM junction identifiers to the junction ID

```{r}

tibble_JUM_valid_junc.exons_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_2012.proteome_valid_junc.exons %>%
                                                                          dplyr::rename("identifier" = "Leading.razor.protein"),
                                                                        tibble_fasta_supp_info_junctions[, c("identifier", "junction_ID")],
                                                             by = "identifier")

```

### calculate statistics

loop thru all the junction ontology AS_event_IDs, return the number of contributing junctions that were validated in the proteome.

```{r}

list_number_of_contributing_junctions_validated <- tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique %>% strsplit(split = ",") %>% 
  purrr::map(.f = ~purrr::map(.x = .x, .f = ~any(.x == tibble_JUM_valid_junc.exons_with_junc_ID$junction_ID %>% unique %>% na.omit))) %>% set_names(tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique) %>%
  purrr::keep(.p = ~any(.x == TRUE)) %>%
  purrr::map(.f = ~which(.x == TRUE) %>% length)

```

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_JUM_junction_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_JUM_junction_ontology_supp_info,
                                                                                names(list_number_of_contributing_junctions_validated) %>% tibble::enframe(value = "contributing_junctions"), 
                                                                                by = "contributing_junctions")

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# JUM ###
tibble_JUM_junction_ontology_transcripts_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_transcripts, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_biomart_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_biomart, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID") %>% 
  dplyr::semi_join(., tibble_non_family_interpro_entries %>% dplyr::rename("interpro" = "Accession")) %>% 
  dplyr::bind_rows(., dplyr::semi_join(tibble_JUM_junction_ontology_biomart, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID") %>% .[is.na(.$interpro), ])
tibble_JUM_junction_ontology_PTM_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_PTM, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_biomart_filtered <- tibble_PSIsigma_exon_ontology_biomart %>% dplyr::semi_join(., tibble_non_family_interpro_entries %>% dplyr::rename("interpro" = "Accession"))

```

#### stats summary of JUM junction ontology

```{r}

# PROTEIN-LEVEL
vector_unique_interpro_ids <- tibble_JUM_junction_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(AS_event_ID) %>% 
  dplyr::summarise(overlaps_interpro_domain = all(is.na(interpro)) == FALSE,
                   unique_interpro_ids = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   overlaps_LCR = all(is.na(seg_start)) == FALSE,
                   overlaps_disordered_region = all(is.na(mobidblite)) == FALSE,
                   overlaps_ncoils = all(is.na(ncoils_start)) == FALSE,
                   overlaps_signalp = all(is.na(signalp_start)) == FALSE,
                   overlaps_tmhmm = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort

# create tally of each unique instance of interpro ID per AS_event_ID
tibble_interpro_id_tally_per_ASeventID <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% .[order(.$tally), ] %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(Gene %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched AS_event_ID mapping
tibble_interpro_ID_to_matched_ASeventID_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("AS_event_IDs" = paste(AS_event_ID %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "AS_event_IDs"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_ASeventID_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of JUM VSRs")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique VSRs with any sort of protein-level annotation: ", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length, " (", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length *100/nrow(tibble_JUM_junction_ontology_transcripts_filtered), "% of those which have any transcript annotation)")

message("total percent of unique VSRs overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique VSRs overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique VSRs overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique VSRs overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique VSRs overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique VSRs overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_tally <- tibble_JUM_junction_ontology_PTM_filtered %>% 
  dplyr::distinct(AS_event_ID, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_tally, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nJUM")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_tally$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## filter the valid phosphosites by differential CDS positions.

```{r}

# add junction ID onto the phosphosites table
tibble_JUM_valid_phosphosites_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_valid_phosphosites,
                                                                        tibble_fasta_supp_info_junctions[, c("identifier", "junction_ID")],
                                                               by = "identifier")

temp_junction_ID <- tibble_JUM_valid_phosphosites_with_junc_ID$junction_ID %>% .[1]

# loop thru each junction ID for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_JUM_valid_phosphosites_with_junc_ID$junction_ID,
  .y = tibble_JUM_valid_phosphosites_with_junc_ID$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    subset_junction_ontology_supp_info_by_identifier <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[grep(x = tibble_JUM_junction_ontology_supp_info_filtered_by_proteome$contributing_junctions, pattern = a1), ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_junction_ontology_supp_info_by_identifier$vector_genomic_coords_of_all_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_JUM_valid_phosphosites_with_overlap <- tibble_JUM_valid_phosphosites_with_junc_ID %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

```

# benchmark performance of NMD flagger

comparisons are done at the level of transcripts.

```{r}

tibble_ref_gtf_with_NMD_flagged_unique_transcripts <- tibble_ref_gtf_with_NMD_flagged_E2 %>% .[-which(is.na(.$transcript_id)), c("transcript_id", "seqnames", "strand", "start", "end", "transcript_biotype", "NMD_candidate")] %>% dplyr::distinct(transcript_id, .keep_all = TRUE) %>% add_column("identifier" = paste(.$seqnames, ":", .$start, "-", .$end, sep = ""))

# get row indices of those transcripts with ref. annotated NMD
row.indices_ref_NMD <- which(tibble_ref_gtf_with_NMD_flagged_unique_transcripts$transcript_biotype == "nonsense_mediated_decay")

# get row indices of those transcripts flagged as NMD
row.indices_flagged_NMD <- grep(x = tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate, pattern = "TRUE")

message("number of reference transcripts with reference NMD annotation: ", row.indices_ref_NMD %>% length, " (", (row.indices_ref_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of reference transcripts flagged as NMD: ", row.indices_flagged_NMD %>% length, " (", (row.indices_flagged_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of transcripts flagged as NMD in common with annotation: ", intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)
message("jaccard: ", (intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)/(union(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length))

# ggplot of the transcript_biotype of NMD candidates

## neat descending order of x-axis
tibble_frequency_distribution <- tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% 
  dplyr::filter(NMD_candidate == "TRUE") %>% 
  dplyr::group_by(transcript_biotype) %>% 
  dplyr::summarise("count_per_transcript_biotype" = n()) %>% 
  dplyr::arrange(desc(count_per_transcript_biotype))

message("percent protein_coding of total: ", (tibble_frequency_distribution[tibble_frequency_distribution$transcript_biotype == "protein_coding", "count_per_transcript_biotype"] %>% paste %>% as.numeric)*100/sum(tibble_frequency_distribution$count_per_transcript_biotype), "%")

x_axis_order <- tibble_frequency_distribution %>% .$transcript_biotype %>% unique

ggplot(data = tibble_ref_gtf_with_NMD_flagged_unique_transcripts[tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate == "TRUE", ]) +
  geom_bar(mapping = aes(x = transcript_biotype, y = ..count..)) +
  geom_label(stat = "count", aes(x = transcript_biotype, label = ..count..)) +
  scale_x_discrete(breaks = x_axis_order, limits = x_axis_order) +
  ggtitle("Common Ensembl transcript_biotype annotations associated with flagged NMD transcripts
          (minimum 5 exons)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

# sQTL and disease ontology - JUM and PSI-Sigma

## Cross reference SNPs from the GWAS catalog

### find SNPs which lie in AS regions.

At the present time, we are looking for SNPs in whole LSV regions for both JUM and PSI-Sigma. This is because mutations can occur at the cis-ESS/ESE/ISS/ISEs, which are not always in the exons/introns of interest.

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end <- tibble("chr" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID %>% unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
                                            "start" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID %>% unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
                                            "end" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID %>% unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"))

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_array.tree <- tibble_AS.event.IDs_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs <- future_map2(.x = list_JUM_AS.event.IDs_array.tree, .y = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID %>% unique, .f = function(.x, .y) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog %>% dplyr::filter(CHR_ID == .x$chr &
                                                .x$start %>% as.numeric <= CHR_POS &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .y,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog", "add_column")))

tibble_JUM_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_AS.event.ID_snps_summary_by_trait <- tibble_JUM_AS.event.ID_all_overlapping_snps %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally" = n()) %>% dplyr::arrange(desc(trait_tally))

```

###  calculate the p-value of region overlapping with SNP

```{r}

library(regioneR)

library(BSgenome.Hsapiens.UCSC.hg38)

set.seed(7)

```

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM <- future_map(.x = tibble_JUM_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x, .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                                                                ntimes = 500, 
                                                                                genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                                # min.parallel = 8,
                                                                                allow.overlaps = FALSE, 
                                                                                per.chromosome = FALSE, 
                                                                                alternative = "greater", 
                                                                                force.parallel = FALSE, 
                                                                                verbose = TRUE)
                                                                                # ,
                                                                                # mc.cores = 8)
                                                                                # 
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE ) %>% set_names(tibble_JUM_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

```

psi-sigma

```{r}

# extract chr, start and end from diff_exon_coords
tibble_diff.exon.coords_chr_start_end <- tibble("chr" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
                                            "start" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
                                            "end" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"))

# list-ify the AS_event_IDs
list_PSIsigma_diff.exon.coords_array.tree <- tibble_diff.exon.coords_chr_start_end %>% unique %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_diff.exon.coords <- future_map2(.x = list_PSIsigma_diff.exon.coords_array.tree, .y = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords %>% unique, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog %>% dplyr::filter(CHR_ID == .x$chr &
                                                               .x$start %>% as.numeric <= CHR_POS &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("diff_exon_coords" = .y)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog", "add_column")))

tibble_psisigma_diff.exon.coords_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_diff.exon.coords %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_diff.exon.coords_snps_summary_by_trait <- tibble_psisigma_diff.exon.coords_all_overlapping_snps %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally" = n()) %>% dplyr::arrange(desc(trait_tally))

```

###  calculate the p-value of region overlapping with SNP

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma <- future_map(.x = tibble_psisigma_diff.exon.coords_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x, .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                                                                ntimes = 500, 
                                                                                genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                                # min.parallel = 8,
                                                                                allow.overlaps = FALSE, 
                                                                                per.chromosome = FALSE, 
                                                                                alternative = "greater", 
                                                                                force.parallel = FALSE, 
                                                                                verbose = TRUE)
                                                                                # ,
                                                                                # mc.cores = 8)
                                                                                # 
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE ) %>% set_names(tibble_JUM_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

```
# Bulk JUM, PSI-Sigma and scRNA-Seq Sierra !!! WARNING: TEMPORARILY ON HOLD !!!

## Find extent of genes with differential AS in common between Sierra and JUM/PSI-Sigma

```{r}

vector_sierra_genes_clusterwise <- tibble_sierra_DTU_clusterwise_all_simplified$gene_name %>% unique %>% mixedsort %>% na.omit

vector_JUM_diff_genes <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% mixedsort %>% na.omit

vector_PSIsigma_diff_genes <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% mixedsort %>% na.omit

cat("\nSierra total DS genes: ", vector_sierra_genes_clusterwise %>% length)
cat("\nJUM total DS genes: ", vector_JUM_diff_genes %>% length)
cat("\nPSI-Sigma total DS genes: ", vector_PSIsigma_diff_genes %>% length)

cat("\nSierra and JUM DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_JUM_diff_genes) %>% length)
cat("\nSierra and PSI-Sigma DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_PSIsigma_diff_genes) %>% length)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_JUM_diff_genes),
  category.names = c("Sierra" , "JUM"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_JUM.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "mediumorchid4")
)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_PSIsigma_diff_genes),
  category.names = c("Sierra" , "PSI-Sigma"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_PSIsigma.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "brown4")
)

```

## Find the extent of overlap between the Sierra differential peaks and JUM/PSI-Sigma

```{r}

# list-ify the JUM contributing junctions using array_tree then unpack using strsplit
list_JUM_diff_junctions_array.tree <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("contributing_junction_IDs", "chr", "start", "end", "strand")] %>% 
  array_tree %>% 
  purrr::map_depth(.depth = 2, .f = ~strsplit(.x, split = ";")) %>%
  purrr::map(~.x %>% flatten %>% as_tibble)

# match to Sierra's differential junctions

```


