---
title: "Sorting JUM output files and analysing them for the PGNEXUS OB series bulk RNA-Seq"
author: "Angel Liang"
date: "10/21/2019"
output: pdf_document
---

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
# library(extrafont)
# font_import(paths = "~/.local/share/fonts/")
# loadfonts(device = "pdf")
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(genefilter)

library(ggplot2)
library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
library(svglite)
library(scales)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)

library(biomaRt)
ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", mirror = "uswest")
library(systemPipeR)
library(GOstats)
library(PFAM.db)
library(bc3net)

library(ComplexHeatmap)

library(ggdendro)
library(data.table)
library(Rfast)

# shared_dir <- "/media/Ubuntu/sharedfolder/"
shared_dir <- "Z:/"

results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/"
# results_dir <- "/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/"

results_directory_figures <- paste(results_dir, "figures/", sep="")

if(! dir.exists(results_directory_figures) ) {
     dir.create(results_directory_figures, recursive = TRUE)}

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

UNION_junc_coor_path <- "Y:/PGNEXUS_OBseries/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"
# UNION_junc_coor_path <- "/media/sbi/4tb_ironwolf/PGNEXUS_OBseries/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

```

## defining functions

```{r}

# FUNCTION to extract the information from matched GTF entries.
# input: a list containing ref + recon GTF entries, a single element of a list of all the matches for each exon.
# things to annotate: gene name, strand, all exons are NMD in the reference GTF, first/last/only exon in reference or recon. GTF
# this function appends to the original table before GTF entry match.

annotate_differential_exon <- function(list_matched_ref_recon_gtf, original_tibble) {
  
  # print(paste("now processing junction number", index))
  
  # DEBUG ######
  
  # list_matched_ref_recon_gtf <- list_gtf_matching_exon_entries[[1]]
  
  ##############
  
  # gene name
  matched_gene_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    matched_gene_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$gene_name %>% unique, collapse = ",")
    
  }
  
  # transcript name (ref)
  matched_ref_transcript_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    matched_ref_transcript_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$transcript_id %>% unique, collapse = ",")
    
  }
  
  # transcript name (recon)
  matched_recon_transcript_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    matched_recon_transcript_names <- paste(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$transcript_id %>% unique, collapse = ",")
    
  }
  
  # NMD - reference
  NMD_reference <- FALSE
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    if (all(list_matched_ref_recon_gtf[["reference_gtf_match"]]$transcript_biotype == "nonsense_mediated_decay")) {
      
      NMD_reference <- TRUE 
      
    }
    
  }
  
  # NMD - recon
  NMD_recon <- FALSE
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    if (all(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$NMD_candidate == TRUE)) {
      
      NMD_recon <- TRUE 
      
    }
    
  } 
  
  # first/last/only exon - reference and recon
  first_or_last_exon_reference <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    first_or_last_exon_reference_temp <- list_matched_ref_recon_gtf[["reference_gtf_match"]]$first_or_last_exon %>% unique 
    
    if (all(is.na(first_or_last_exon_reference_temp)) != TRUE) {
      
      first_or_last_exon_reference <- first_or_last_exon_reference_temp %>% na.omit %>% paste(collapse = ",")
      
    }
    
  }
  
  first_or_last_exon_recon <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    first_or_last_exon_recon_temp <- list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$first_or_last_exon %>% unique 
    
    if (all(is.na(first_or_last_exon_recon_temp)) != TRUE) {
      
      first_or_last_exon_recon <- first_or_last_exon_recon_temp %>% na.omit %>% paste(collapse = ",")
      
    }
    
  }
  
  return(purrr::splice(original_tibble, 
              "matched_gene_names" = matched_gene_names,
              "matched_ref_transcript_names" = matched_ref_transcript_names,
              "matched_recon_transcript_names" = matched_recon_transcript_names,
              "NMD_reference" = NMD_reference,
              "NMD_recon" = NMD_recon,
              "first_or_last_exon_reference" = first_or_last_exon_reference,
              "first_or_last_exon_recon" = first_or_last_exon_recon
              ))
  
}

```

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $chr, $start, $end, $strand
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons_JUM <- function(spliceregion_list, tibble_gtf_table, match_consecutive = TRUE) {
  
  # DEBUG ###################

  # spliceregion_list <- UNION_junc_coor_table_array.tree[[50]]
  # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_recon_gtf
  # index <- 50

  ###########################

  # print(paste("now processing junction number", index))
  
if (spliceregion_list$strand == "." | spliceregion_list$strand == 0 | spliceregion_list$strand == "*") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "exon", ]
    
  } else if (spliceregion_list$strand == "+" | spliceregion_list$strand == "-") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$strand == spliceregion_list$strand %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "exon", ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks a junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
  
  if (match_consecutive == TRUE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
    
  } else if (match_consecutive == FALSE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2)
    
  }
  
  return(list_of_tibbles_flanking_exon_gtf.entries_per_transcript)
  
}

```

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING CDS regions.
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $chr, $start, $end, $strand
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap
# NOTE 29/4/2020: RELAXED THE CONSECUTIVE EXON CRITERION. This is because there can be some novel exon skip events not annotated in reference. To reduce even more complicated calculations, however, we still need to match within the SAME transcript.

extract_junction.flanking.CDS_JUM <- function(spliceregion_list, tibble_gtf_table, match_consecutive = TRUE) {
  
  # DEBUG ###################

  # spliceregion_list <- UNION_junc_coor_table_array.tree[[50]]
  # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_recon_gtf
  # index <- 50

  ###########################

  # print(paste("now processing junction number", index))
  
if (spliceregion_list$strand == "." | spliceregion_list$strand == 0 | spliceregion_list$strand == "*") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "CDS", ]
    
  } else if (spliceregion_list$strand == "+" | spliceregion_list$strand == "-") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$strand == spliceregion_list$strand %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "CDS", ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks a junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
  
  if (match_consecutive == TRUE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(start %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
    
  } else if (match_consecutive == FALSE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(start %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2)
    
  }
  
  list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(start %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2)
  
  return(list_of_tibbles_flanking_exon_gtf.entries_per_transcript)
  
}

```

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch != 0, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes != 0, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

```

```{r}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

```

```{r}

# THIS TABLE WILL SPLIT THE IN-CELL CONCATENATED/DELIMITED OUTPUT FOR EACH SUMMARY TABLE FOR EACH SPLICEMODE

split_JUM_output_table <- function(summary_table_onesplicemode, name_of_extra_colname_to_split, name_of_splicemode) {
  
  # SPLITTING THE SEMICOLON DELIMITED VALUES INTO NEW ROWS

summary_table_onesplicemode <- summary_table_onesplicemode %>% na.omit

summary_table_onesplicemode_column_names <- colnames(summary_table_onesplicemode)

summary_table_onesplicemode_dPSI_column_numbers <- summary_table_onesplicemode_column_names %>% grep(., pattern = paste("deltaPSI(.*)|", name_of_extra_colname_to_split, sep = ""))

# A. SPLITTING EACH CELL OF DELTAPSI INTO SEPARATE ROWS
# THIS OUTPUTS A LIST WITH EACH ELEMENT CONTAINING THE VALUES OF EACH ROW
list_of_onesplicemode_dPSI_values_only_split <- summary_table_onesplicemode[, summary_table_onesplicemode_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){strsplit(x, split = ";")})

# WE MUST FIRST DEFINE THE FINAL TABLE THEN GO BACK TO FINISHING THE FINAL TABLE BECAUSE IT NEEDS TO SCAFFOLD BASED ON A PREDETERMINED NUMBER OF ROWS IN data.frame(matrix(...))

# B. USE SPLITTING LENGTH FOR EACH ROW TO DETERMINE THE AMOUNT OF TIMES ROWS ARE TO BE REPEATED.
# THIS OUTPUTS THE SAME DATA.FRAME EXCEPT THE RIGHT COLUMNS ARE REPEATED THE SAME NUMBER OF TIMES AS SEMICOLONS
summary_table_onesplicemode_non_dPSI_values_only_split <- summary_table_onesplicemode[, -summary_table_onesplicemode_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){rep(x, sapply(list_of_onesplicemode_dPSI_values_only_split[[1]], length))}) %>% data.frame

list_of_isoform_number <- list_of_onesplicemode_dPSI_values_only_split[[1]] %>% lapply(length) %>% purrr::map(.x = ., ~c(1:.x)) %>% unlist

# DONE STEP B.

# BACK TO A.
summary_table_onesplicemode_dPSI_values_only_split <- data.frame(matrix(unlist(list_of_onesplicemode_dPSI_values_only_split), nrow = nrow(summary_table_onesplicemode_non_dPSI_values_only_split), byrow = FALSE), stringsAsFactors = FALSE)

colnames(summary_table_onesplicemode_dPSI_values_only_split) <- names(list_of_onesplicemode_dPSI_values_only_split)

# DONE STEP A.

# APPEND THE TWO TABLES TO RE-CREATE THE WIDE MASTER TABLE EXCEPT THE VALUES ARE ACTUALLY REOBABLE BY R NOW.
summary_table_onesplicemode_split <- dplyr::bind_cols(summary_table_onesplicemode_non_dPSI_values_only_split, summary_table_onesplicemode_dPSI_values_only_split)

# rearrange the columns to preserve consistency with the rest of the wide_tables

summary_table_onesplicemode_split <- summary_table_onesplicemode_split[, summary_table_onesplicemode_column_names]

# append the list of isoform numbers

summary_table_onesplicemode_split <- cbind(summary_table_onesplicemode_split, isoform_number = list_of_isoform_number)

# append the list of isoform IDs

summary_table_onesplicemode_split <- cbind(summary_table_onesplicemode_split, isoform_ID = paste(name_of_splicemode, summary_table_onesplicemode_split$AS_event_ID, summary_table_onesplicemode_split$isoform_number, sep = "_"))

# remove non-integer values

summary_table_onesplicemode_split <- type_convert(summary_table_onesplicemode_split, na = c("Inf", "-Inf"), trim_ws = TRUE)

summary_table_onesplicemode_split_with_na <- summary_table_onesplicemode_split

# summary_table_onesplicemode_split <- summary_table_onesplicemode_split %>% na.omit

row.names(summary_table_onesplicemode_split) <- NULL

# re-interpret numbers as numeric

# summary_table_onesplicemode_split[, !(colnames(summary_table_onesplicemode_split) == c("Gene", "AS_event_ID", "splicemode", name_of_extra_colname_to_split))] <- summary_table_onesplicemode_split[, !(colnames(summary_table_onesplicemode_split) == c("Gene", "AS_event_ID", "splicemode", name_of_extra_colname_to_split))] %>% mutate_each(., funs = as.character) %>% mutate_each(., funs = as.numeric)

summary_table_onesplicemode_split <- summary_table_onesplicemode_split %>% type_convert
  
return(summary_table_onesplicemode_split)


}

# END split_JUM_output_table

```

```{r}

# function to convert the isoform_ID from JUM and splicemode of isoforms of interest into chr, strand, start and end co-ordinates that ensembldb can read.
# input tibble structure: MUST CONTAIN: gene "Gene", JUM isoform ID "AS_event_ID" and "splicemode"

JUM_ASeventID_and_splicemode_to_chr_strand_start_end <- function(tibble_of_isoforms_to_be_consequence_assessed) {
  
  # as long as there is the AS_event_ID, then we are fine.
  
  # subset A3SS_events, filter out the isoform of interest from the master A3SS_events table and then return all 4 co-ordinates
  # for A3SS, we consider the entire differential area.
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A3SS_events",] %>% nrow != 0) {
    
  A3SS_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A3SS_events", c("Gene", "AS_event_ID")]
  A3SS_subset <- dplyr::inner_join(A3SS_summary_table, A3SS_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "common_5_SS_coor", "A3SS_coordinates")]
  A3SS_subset <- cbind(A3SS_subset, chr = gsub(x = A3SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% 
    cbind(., strand = gsub(x = A3SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% 
    cbind(., start = gsub(x = A3SS_subset$A3SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\1")) %>% 
    cbind(., end = gsub(x = A3SS_subset$A3SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\3"))
  A3SS_subset <- A3SS_subset[, c("Gene", "AS_event_ID", "chr", "strand", "start", "end")] %>% as_tibble
  A3SS_subset[, "splicemode"] <- "A3SS_events"
  
  }

  # subset A5SS_events
  # for A5SS, we consider the entire differential area.
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A5SS_events",] %>% nrow != 0) {
    
  A5SS_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "A5SS_events", c("Gene", "AS_event_ID")]
  A5SS_subset <- dplyr::inner_join(A5SS_summary_table, A5SS_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "common_3_SS_coor", "A5SS_coordinates")]
  A5SS_subset <- cbind(A5SS_subset, chr = gsub(x = A5SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = A5SS_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% cbind(., start = gsub(x = A5SS_subset$A5SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\1")) %>% cbind(., end = gsub(x = A5SS_subset$A5SS_coordinates, pattern = "([0-9]{1,10})(.*{0,1});([0-9]{1,10})", replacement = "\\3"))
  A5SS_subset <- A5SS_subset[, c("Gene", "AS_event_ID", "chr", "strand", "start", "end")] %>% as_tibble
  A5SS_subset[, "splicemode"] <- "A5SS_events"
  
  }

  # subset cassette
  # for cassette, we consider the cassette region.
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "cassette_exon_events",] %>% nrow != 0) {
    
  cassette_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "cassette_exon_events", c("Gene", "AS_event_ID")]
  cassette_subset <- dplyr::inner_join(cassette_exon_summary_table, cassette_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "upstream_exon_end_coor", "cassette_exon_start_coor", "cassette_exon_end_coor", "downstream_exon_start_coor")]
  cassette_subset <- cbind(cassette_subset, chr = gsub(x = cassette_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = cassette_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2"))
  cassette_subset <- cassette_subset[, c("Gene", "AS_event_ID", "chr", "strand", "cassette_exon_start_coor", "cassette_exon_end_coor")] %>% as_tibble
  names(cassette_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  cassette_subset[, "splicemode"] <- "cassette_exon_events"
  
  
  }

  # subset MXE events
  # for MXE, we consider the entire differential area.
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "MXE_events",] %>% nrow != 0) {
    
    MXE_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "MXE_events", c("Gene", "isoform_ID")]
  MXE_subset <- dplyr::inner_join(MXE_events_summary_table_split, MXE_subset, by = c("Gene", "isoform_ID")) %>% .[, c( "Gene", "AS_event_ID", "isoform_ID", "upstream_exon_end_coor", "MXE_exon_coordinates", "downstream_exon_start_coor")]
  MXE_subset <- cbind(MXE_subset, chr = gsub(x = MXE_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = MXE_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% cbind(., start = gsub(x = MXE_subset$MXE_exon_coordinates, pattern = "(.*)-(.*)", replacement = "\\1")) %>% cbind(., end = gsub(x = MXE_subset$MXE_exon_coordinates, pattern = "(.*)-(.*)", replacement = "\\2"))
  MXE_subset <- MXE_subset[, c("Gene", "isoform_ID", "chr", "strand", "start", "end")] %>% as_tibble
  names(MXE_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  MXE_subset[, "splicemode"] <- "MXE_events"
    
  }
  
  # subset IR events
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "intron_retention",] %>% nrow != 0) {
    
  IR_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "intron_retention", c("Gene", "AS_event_ID")]
  IR_subset <- dplyr::inner_join(intron_retention_summary_table, IR_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID", "retained_intron_start", "retained_intron_end")]
  IR_subset <- cbind(IR_subset, chr = gsub(x = IR_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% cbind(., strand = gsub(x = IR_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2"))
  IR_subset <- IR_subset[, c("Gene", "AS_event_ID", "chr", "strand", "retained_intron_start", "retained_intron_end")] %>% as_tibble
  colnames(IR_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  IR_subset[, "splicemode"] <- "intron_retention"
  
  }
  
  # subset composite events
  if (tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "composite_events",] %>% nrow != 0) {
    
  composite_subset <- tibble_of_isoforms_to_be_consequence_assessed[tibble_of_isoforms_to_be_consequence_assessed$splicemode == "composite_events", c("Gene", "AS_event_ID")]
  composite_subset <- dplyr::inner_join(composite_events_summary_table, composite_subset, by = c("Gene", "AS_event_ID")) %>% .[, c("Gene", "AS_event_ID")]
  composite_subset <- cbind(composite_subset, chr = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\1")) %>% 
    cbind(., strand = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\2")) %>% 
    cbind(., start = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10})", replacement = "\\3")) %>% 
    cbind(., end = gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10})", replacement = "\\5"))
  
  # generating intervals using the composite coordinate vertices provided
  
  # (deprecated) ##
  # list_of_composite_subset_coordinates <- gsub(x = composite_subset$AS_event_ID, pattern = "(.*)_(\\-|\\+|\\*)_(.*)", replacement = "\\3") %>% strsplit(split = "_")
  # list_of_composite_subset_coordinates <- purrr::map(.x = list_of_composite_subset_coordinates, .f = ~.x[1:(length(.x)-1)] %>% cbind(., end = .x[2:(length(.x))]) %>% as_tibble)
  # list_of_composite_subset_coordinates <- purrr::map(.x = list_of_composite_subset_coordinates, ~rename(.x, start = 1, end = 2))
  # 
  # composite_subset <- apply(X = composite_subset, MARGIN = 2, FUN = function(x){rep(x, times = purrr::map(list_of_composite_subset_coordinates, nrow) %>% unlist)}) %>% cbind(., start = purrr::map(list_of_composite_subset_coordinates, ~.x$start) %>% unlist) %>% cbind(., end = purrr::map(list_of_composite_subset_coordinates, ~.x$end) %>% unlist)
  
  composite_subset <- composite_subset[, c("Gene", "AS_event_ID", "chr", "strand", "start", "end")] %>% as_tibble
  
  colnames(composite_subset) <- c("Gene", "AS_event_ID", "chr", "strand", "start", "end")
  composite_subset[, "splicemode"] <- "composite_events"
  
  }
  
  ### CONCATENATE ALL THE SUBSET LISTS BACK INTO A SINGLE TABLE
  
  tibble_of_chr_strand_start_end <- bind_rows(if (exists("A3SS_subset") == TRUE) {A3SS_subset}, 
                                              if (exists("A5SS_subset") == TRUE) {A5SS_subset}, 
                                              if (exists("cassette_subset") == TRUE) {cassette_subset}, 
                                              if (exists("MXE_subset") == TRUE) {MXE_subset}, 
                                              if (exists("IR_subset") == TRUE) {IR_subset}, 
                                              if (exists("composite_subset") == TRUE) {composite_subset}) %>% type_convert %>% mutate_if(is.factor, as.character) %>% as_tibble %>% bind_cols(., "width" = .$end - .$start)
  
  return(tibble_of_chr_strand_start_end)
  
}

# END JUM_ASeventID_and_splicemode_to_chr_strand_start_end

```

```{r}

# this will take the result of genomic-to-protein mapping (i.e. ENSP ids) and feed it through biomart. The result is a list of protein domain accessions/ids that overlap (AT THE MOMENT FULL OVERLAP ONLY) with the query interval
# expected input: a list of lists. max level = 2.
# NOTE2: COLUMNS EXPECTED: $1 (ENSP) "names", $2 "start", $3 "width", $4 "end"

tibble_of_mapped_protein_positions_to_list_of_domains_PTMs <- function(list_of_mapped_proteinID, ensemblmart) {
  
  # DEBUG ###
  # list_of_mapped_proteinID <- mapped_aminoacid_positions
  ###########
  
  # extract all query ENSP ids
  vec_all_ENSP_ids <- list_of_mapped_proteinID %>% flatten %>% rbindlist %>% .$names
  
  # create a list of attributes to retrieve from biomart. we will loop thru this.
  list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                         "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                         "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                         "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                         "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                         "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                         "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))
  
  # search biomart
  list_biomart_result_per_attribute <- future_map(.x = list_of_attributes_to_retrieve, .f = ~getBM(filters = "ensembl_peptide_id", values =  vec_all_ENSP_ids %>% unique, attributes = .x, mart = ensemblmart), .progress = TRUE, .options = future_options(globals = c("vec_all_ENSP_ids", "getBM", "ensemblmart")))
  
  # remove na values from biomart result
  list_biomart_result_per_attribute_processed <- purrr::map(.x = list_biomart_result_per_attribute, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_biomart_result_per_attribute[[1]]
    ###########
    
    tibble_of_single_attribute <- .x %>% as_tibble
    
    # fetch na or blank row indices
    row.indices_na_values <- tibble_of_single_attribute %>% apply(MARGIN = 1, FUN = function(X) {any(is.na(X) == TRUE | X == "")}) %>% which
    tibble_of_single_attribute <- tibble_of_single_attribute[-row.indices_na_values, ]
    
    # rename columns start and end to be generic
    colnames(tibble_of_single_attribute)[grep(x = colnames(tibble_of_single_attribute), pattern = "start")] <- "start"
    colnames(tibble_of_single_attribute)[grep(x = colnames(tibble_of_single_attribute), pattern = "end")] <- "end"
    
    return(tibble_of_single_attribute)
    
  } )

  # ALL DOMAIN ANNOTATIONS FROM BIOMART ARE FINISHED HERE ######
  
  # get ENSP to uniprot entry mapping
  table_ENSP_to_uniprot_entry_mapping <- biomaRt::getBM(filters = "ensembl_peptide_id", values = vec_all_ENSP_ids, attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
  (# remove NA/blank rows
    function(x) {
      
      # debug ###
      # x <- table_ENSP_to_uniprot_entry_mapping
      ###########
      
      row.indices_na_or_blank_values <- x %>% apply(MARGIN = 1, FUN = function(X) {any(is.na(X) | X == "")} ) %>% which
      
      table <- x[-row.indices_na_or_blank_values, ]
      
      return(table)
      
    } )
  
  # for each query interval associated with an ENSP id, extract overlapping biomart result entries.
  list_extracted_overlapping_biomart_results <- future_map(.x = list_of_mapped_proteinID, .f = 
                                                             ~purrr::map(.x = .x, .f = 
                                                                           function(.x) {
                                                                             
                                                                             # DEBUG ###
                                                                             # .x <- list_of_mapped_proteinID[[1]][[1]]
                                                                             ###########
                                                                             
                                                                             query_ENSP <- .x$names
                                                                             query_start <- .x$start
                                                                             query_end <- .x$end
                                                                             list_of_mapped_proteinID
                                                                             matching_tibble_entries_biomart <- purrr::map(.x = list_biomart_result_per_attribute_processed, 
                                                                                                                   .f = ~.x[.x$ensembl_peptide_id == query_ENSP & 
                                                                                                                              .x$start < query_end &
                                                                                                                              .x$end > query_start, ])
                                                                             
                                                                             # retrieve equivalent UniProt entry name 
                                                                             vec_uniprot_entry_IDs <- table_ENSP_to_uniprot_entry_mapping[table_ENSP_to_uniprot_entry_mapping$ensembl_peptide_id == query_ENSP, ] %>% .$uniprotkb_entry %>% unique %>% tibble::enframe(name = NULL, value = "uniprotkb_entry")
                                                                             # get overlapping dbPTM entries ###
                                                                             tibble_matching_entries_dbPTM <- dplyr::semi_join(dbPTM_allhuman_annotations, vec_uniprot_entry_IDs, by = "uniprotkb_entry")
                                                                             tibble_matching_entries_dbPTM <- tibble_matching_entries_dbPTM[tibble_matching_entries_dbPTM$modified_residue_position %in% (query_start:query_end) %>% which, ]
                                                                             # get overlapping phosphositeplus entries ###
                                                                             tibble_matching_entries_phosphositeplus <- dplyr::semi_join(phosphosite_allhuman_phosphosites, vec_uniprot_entry_IDs, by = "uniprotkb_entry")
                                                                             tibble_matching_entries_phosphositeplus <- tibble_matching_entries_phosphositeplus[tibble_matching_entries_phosphositeplus$modified_residue_position %in% (query_start:query_end) %>% which, ]
                                                                             
                                                                             matching_tibble_entries_all <- purrr::splice(list("ensembl_peptide_id" = query_ENSP), 
                                                                                                                          matching_tibble_entries_biomart, 
                                                                                                                          "dbPTM" = tibble_matching_entries_dbPTM,
                                                                                                                          "phosphositeplus" = tibble_matching_entries_phosphositeplus)
                                                                             
                                                                             return(matching_tibble_entries_all)
                                                                             
                                                                           } ), .progress = TRUE, .options = future_options(globals = c("list_biomart_result_per_attribute_processed", "table_ENSP_to_uniprot_entry_mapping", "dbPTM_allhuman_annotations", "phosphosite_allhuman_phosphosites")))

return(list_extracted_overlapping_biomart_results)

}

# END tibble_of_mapped_protein_positions_to_list_of_domains_PTMs()

# FILTER THE GTF TABLE BY ANNOTATIONS OVERLAPPING WITH THE QUERY INTERVAL(S)

# possible modes that this function can operate in: 1. "AS region" and 2. "BED_file" 
# AS region mode is for finding all the overlapping gtf annotations of a given AS event
# BED file mode is for annotating a BED file (especially from CLIP-SEQ/RIP-seq/parclip) 
# target level is the filter for the "type" in gtf table. one of: "gene", "transcript", "exon", "CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr", "Selenocysteine"

map_genome_coordinate_to_transcriptandprotein <- function(chr_strand_start_end_tibble, gtf_table, mode, targetlevel = NULL) {
  
  # DEBUG ###
  # chr_strand_start_end_tibble <- tibble_queryisoforms_chr_strand_start_end
  # gtf_table <- tibble_ref_gtf_simplified
  # mode = "AS region"
  ###########
  
  if (mode == "AS region") {
  
  list_of_query_AS_event_ID <- chr_strand_start_end_tibble$AS_event_ID %>% array_tree

list_of_all_overlapping_annotations <- future_imap(.x = list_of_query_AS_event_ID, .f = function(.x, .y) {
  
  # message("Now processing entry number: ", .y)
  
  overlapping_gtf_entries <- gtf_table[(gtf_table$chr == chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "chr"] %>% unique %>% paste %>% as.character) &
    (gtf_table$strand == chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "strand"] %>% unique %>% paste %>% as.character), ] %>% 
    .[(.$start < chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "end"] %>% unique %>% paste %>% as.numeric) & 
        (.$end > chr_strand_start_end_tibble[chr_strand_start_end_tibble$AS_event_ID == .x, "start"] %>% unique %>% paste %>% as.numeric), ]
  
  return(overlapping_gtf_entries)
  
}, .progress = TRUE, .options = future_options(globals = c("gtf_table", "chr_strand_start_end_tibble")))

names(list_of_all_overlapping_annotations) <- chr_strand_start_end_tibble$Gene


  } else if (mode == "BED_file") {
  
    bed_chr_strand_start_end <- chr_strand_start_end_tibble
    
    colnames(bed_chr_strand_start_end) <- c("feature_chr", "feature_strand", "feature_start", "feature_end", "ClusterID", "ClusterSequence", "ReadCount", "ModeLocation", "ModeScore", "ConversionLocationCount", "ConversionEventCount", "NonConversionEventCount")

gtf_table_targetlevel <- gtf_table[gtf_table$type == targetlevel, ]

colnames(gtf_table_targetlevel) <- c("annotation_chr", "annotation_start", "annotation_end", "annotation_width", "annotation_strand", "annotation_type", "annotation_annotation_phase", "annotation_gene_id", "annotation_gene_name", "annotation_gene_biotype", "annotation_transcript_id", "annotation_transcript_name", "annotation_transcript_biotype", "annotation_exon_number", "annotation_exon_id", "annotation_protein_id")

gtf_entries_overlapping_with_bed <- purrr::pmap(.l = list(bed_chr_strand_start_end[["feature_chr"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_strand"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_start"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_end"]]) %>% as.list, 
                                                   .f = ~gtf_table_targetlevel %>%
                                                     .[.$annotation_chr == ..1 %>% lapply(as.character) %>% paste, ] %>% 
                                                       .[.$annotation_strand == ..2 %>% lapply(as.character) %>% paste, ] %>% 
                                                     .[(.$annotation_start < ..4 %>% as.numeric %>% paste) & 
                                                         (.$annotation_end > ..3 %>% as.numeric %>% paste), ]) %>% compact

unannotated_bed_file_arraytree <- bed_chr_strand_start_end %>% array_tree %>% purrr::map(~as_tibble(.x))

peaks_with_annotation <- which(purrr::map(gtf_entries_overlapping_with_bed, ~nrow(.x)) %>% unlist != 0)

annotated_bed_file <- purrr::map2(.x = unannotated_bed_file_arraytree[peaks_with_annotation], 
                                  .y = gtf_entries_overlapping_with_bed[peaks_with_annotation], 
                                  .f = ~cbind(.x, .y))

# not actually a list. actually a wide table.

list_of_all_overlapping_annotations <- annotated_bed_file %>% purrr::reduce(bind_rows)

}

return(list_of_all_overlapping_annotations)
  
}

# END map_genome_coordinate_to_transcriptandprotein

# sort lists of protein CDS positions by descending/ascending order depending if ORF is on + or - strand
##  function to look at a tibble containing the CDS positions and see whether you need to sort by increasing or decreasing order

sort_tibble_according_to_strand <- function(tibble_to_be_sorted) {
  
  if (data.class(tibble_to_be_sorted) != "tbl_df") {
    
    CDS_list_out <- tibble_to_be_sorted
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "+") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = FALSE)
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "-") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = TRUE)
    
  }
  
  return(CDS_list_out)
  
}

# END sort_according_to_strand

# THE MAIN FUNCTION TO CONVERT THE TIDIED CHR STRAND START END TIBBLE TO LISTS OF OVERLAPPING ANNOTATION AND PROTEIN DOMAINS
# inputs: 1. table containing regions to be queried. columns must be: Gene, AS event ID, chr, strand, start, end; 2. GTF table, preferably from rtracklayer::import, 3. ensembl mart of choice

tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain <- function(tibble_queryisoforms_chr_strand_start_end, gtf_table, ensemblmart) {
  
  # DEBUG ###
  # tibble_queryisoforms_chr_strand_start_end <- all_plausible_diff_junctions_chr_strand_start_end
  # gtf_table <- tibble_ref_gtf_simplified
  # ensemblmart <- ensembl_mart
  ###########
    
  message("Now mapping the specified AS coords to transcript- and protein-relative coords")
  
  gtf_table <- gtf_table
  list_queryisoforms_overlapping_annotations_tibbles <- tibble_queryisoforms_chr_strand_start_end %>% map_genome_coordinate_to_transcriptandprotein(., gtf_table = gtf_table, mode = "AS region") 
  
  # set level 1 list names as the AS_event_ID
  names(list_queryisoforms_overlapping_annotations_tibbles) <- tibble_queryisoforms_chr_strand_start_end$AS_event_ID
  
  message("Extract the individual CDS regions of each protein overlapping the AS regions")
  list_overlapping_protein_CDS_exons_tibbles <- future_map(.x = list_queryisoforms_overlapping_annotations_tibbles, .f = ~.x$protein_id %>% na.omit %>% unique %>% array_tree %>% purrr::map(.x = ., .f = ~gtf_table[gtf_table$protein_id == .x & gtf_table$type == "CDS", ] %>% .[apply(X = ., MARGIN = 1, FUN = function(X) {all(is.na(X)) == FALSE}), ]), .progress = TRUE, .options = future_options(globals = c("gtf_table")))
  
  message("Extract the individual genome-relative CDS nucleotide positions")
  list_overlapping_protein_CDS_positions_tibbles <- purrr::map_depth(.x = list_overlapping_protein_CDS_exons_tibbles, .depth = 2, .f = ~sort_tibble_according_to_strand(.x))
  
  message("Now generate a table of sorted protein relative coordinates for each genomic start and end associated with each unique AS region.")
  # provided functions: 
  # 1. list_overlapping_protein_CDS_positions_tibbles: list of genes corresponding to isoform enriched > list of vectors of genomic positions of CDS for each ENSP, 
  # 2. 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% as.list: level 1 indices, 
  # 3. list_overlapping_protein_CDS_exons_tibbles: list of genes corresponding to isoform enriched > list of subsets of GTF table for each unique ENSP caught by query range. used for ENSP id mapping 
  # NOTE: width < 0 if the ORF is on the - strand
  mapped_aminoacid_positions <- purrr::pmap(.l = list("A" = list_overlapping_protein_CDS_positions_tibbles, 
                                                      "B" = 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% array_tree,
                                                      "C" = list_overlapping_protein_CDS_exons_tibbles), .f = function(A, B, C) {
                                                        
                                                        level_one_index <- B
                                                        
                                                        message("now processing entry number: ", level_one_index)
                                                        
                                                        purrr::map2(.x = A, .y = C, .f = function(.x, .y) {
                                                          
                                                          # print(paste(".x = ", .x %>% head))
                                                          # print(paste(.y))
                                                          
                                                          match_query_startend_with_vectors_of_CDSpositions(vector_of_sorted_CDSpositions = .x,
                                                                                                            ENSP_id = paste(.y$protein_id %>% unique),
                                                                                                            input_query_start = paste(tibble_queryisoforms_chr_strand_start_end[level_one_index, "start"]) %>% as.numeric,
                                                                                                            input_query_end = paste(tibble_queryisoforms_chr_strand_start_end[level_one_index, "end"]) %>% as.numeric)
                                                          
                                                          } )
                                                        } )
  
  # FINALLY! PROTEIN DOMAIN MATCHING!
  
  # get rid of empty genes with no match
  mapped_aminoacid_positions <- purrr::discard(.x = mapped_aminoacid_positions, .p = ~length(.x) == 0)
  
  # retrieve all the domain and PTM annotations
  coinciding_domains_PTMs <- tibble_of_mapped_protein_positions_to_list_of_domains_PTMs(mapped_aminoacid_positions, ensemblmart)
  
  # summarise protein and transcript-level analyses
  ## for the transcript level, only extract the "type" and "transcript_biotype" columns
  list_of_tibbles_transcript_level_results <- list_queryisoforms_overlapping_annotations_tibbles %>% purrr::map(~.x[, c("type", "transcript_biotype")] %>% unique)
  ## add in the AS_event_ID from the level 1 list and rbind
  tibble_transcript_level_results <- purrr::map2(.x = list_of_tibbles_transcript_level_results, .y = names(list_of_tibbles_transcript_level_results), .f = ~add_column(.x, "AS_event_ID" = .y, .before = 1)) %>% rbindlist %>% as_tibble
  
  ## for the protein/domain etc. level, extract and collapse OR convert to logical indicating the presence/absence of a feature.
  list_of_tibbles_protein_level_results <- purrr::map2(.x = coinciding_domains_PTMs, .y = names(coinciding_domains_PTMs), .f = function(.x, .y) {
    
    # DEBUG ###
    # .x <- coinciding_domains_PTMs[[1]]
    # .y <- names(coinciding_domains_PTMs) %>% .[[1]]
    ###########
    
    list_L2 <- .x
    L1_id <- .y
    
    # convert ncoils, seg, signalp, tmhmm, mobidblite to logical.
    list_L2_processed <- purrr::map(.x = list_L2, .f = ~purrr::modify_at(.x = .x, .at = c("ncoils", "seg", "signalp", "tmhmm", "mobidblite"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(TRUE)
        
      }
      
      return(annotation_exists)
      
    } ))
    
    # collapse interpro annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("interpro"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(paste(.x$interpro, collapse = ";"))
        
      }
      
    } ))
    
    # collapse sifts annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("sifts"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(paste(.x$sifts_import, collapse = ";"))
        
      }
      
    } ))
    
    # collapse dbPTM annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("dbPTM"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(tibble("dbPTM_uniprotkb_entry" = NA,
                      "dbPTM_modified_residue_position" = NA,
                      "dbPTM_PTM_type" = NA))
        
      } else if (nrow(.x) != 0) {
        
        return(tibble("dbPTM_uniprotkb_entry" = paste(.x$uniprotkb_entry, collapse = ";"),
                      "dbPTM_modified_residue_position" = paste(.x$modified_residue_position, collapse = ";"),
                      "dbPTM_PTM_type" = paste(.x$PTM_type, collapse = ";")))
        
      }
      
    } ))
    
    # collapse phosphositeplus annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("phosphositeplus"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(tibble("phosphositeplus_uniprotkb_entry" = NA,
                      "phosphositeplus_modified_residue_position" = NA))
        
      } else if (nrow(.x) != 0) {
        
        return(tibble("phosphositeplus_uniprotkb_entry" = paste(.x$uniprotkb_entry, collapse = ";"),
                      "phosphositeplus_modified_residue_position" = paste(.x$modified_residue_position, collapse = ";")))
        
      }
      
    } ))
    
    # splice in the level 1 list name (in this case, it's AS_event_ID)
    list_L2_final <- purrr::map(.x = list_L2_processed, .f = ~purrr::splice(list("AS_event_ID" = L1_id), 
                                                                            .x))
    
    return(list_L2_final)
    
  })
  ## flatten, tibblise within each element then rbind. 
  tibble_protein_level_results <- list_of_tibbles_protein_level_results %>% flatten 
  names(tibble_protein_level_results) <- NULL
  tibble_protein_level_results <- tibble_protein_level_results %>% purrr::map(~flatten(.x) %>% as_tibble) %>% rbindlist %>% as_tibble
  
  return(list("transcript_level_results" = tibble_transcript_level_results,
              "protein_level_results" = tibble_protein_level_results))

}

# END tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain

```

# Match all separate junctions to the reference and recon annotation

We do this so that we can get NMD and and first/last exon info

## import union_junc_coor table

```{r eval=FALSE, include=FALSE}

UNION_junc_coor_table <- read.delim(paste(UNION_junc_coor_path), sep = "\t", stringsAsFactors = FALSE, col.names = c("chr", "start", "end", "strand", "junction_ID")) %>% as_tibble

```

## annotate with reference and recon GTF info

```{r eval=FALSE, include=FALSE}

# remove all whitespace
UNION_junc_coor_table_array.tree <- UNION_junc_coor_table %>% array_tree %>% future_map(~purrr::map(.x = .x, .depth = 2, .f = ~trimws(.x)), .progress = TRUE, .options = future_options(globals = FALSE))

# get entries of junction-flanking exon matches
list_gtf_matching_exon_entries <- future_map(.x = UNION_junc_coor_table_array.tree, .f = ~splice(.x, list(
  "reference_gtf_match" = extract_junction.flanking.exons_JUM(.x, tibble_ref_gtf) %>% rbindlist, 
  "reconstructed_gtf_match" =  extract_junction.flanking.exons_JUM(.x, tibble_recon_gtf) %>% rbindlist)), 
  .progress = TRUE, .options = future_options(globals = c("extract_junction.flanking.exons_JUM", "tibble_ref_gtf", "tibble_recon_gtf", "data.table")))

list_gtf_matching_exon_entries_extracted <- purrr::map2(.x = list_gtf_matching_exon_entries, .y = UNION_junc_coor_table_array.tree, .f = ~annotate_differential_exon(.x, .y) %>% as_tibble)

tibble_gtf_matching_exon_entries_extracted <- list_gtf_matching_exon_entries_extracted %>% rbindlist %>% as_tibble

# write table 
write.table(x = tibble_gtf_matching_exon_entries_extracted, file = paste(results_directory_figures, "wide_table_of_UNION_junc_with_NMD.first.last_info.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

```{r}

tibble_gtf_matching_exon_entries_extracted <- read.delim(paste(results_directory_figures, "wide_table_of_UNION_junc_with_NMD.first.last_info.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

```

## import the detailed tables and process them

only the detailed tables can link each AS_event_ID to their contributing junctions.

```{r eval=FALSE, include=FALSE}

list_of_timepoint_comparisons_final <- read.delim(paste(results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree %>% flatten

list_of_AS_events <- c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events") %>% array_tree %>% flatten

# read tables into environment

list_of_detailed_tables <- future_map(.x = list_of_timepoint_comparisons_final, .f = ~purrr::map2(.x = .x, .y = list_of_AS_events, .f = ~read.delim(file = paste(results_dir, "final_JUM_output_", .x, "/", list.files(path = paste(results_dir, "final_JUM_output_", .x, "/", sep = ""), pattern = paste("(.)", .y, "(.*)detailed.txt", sep = "")), sep = ""), na.strings = c("NONE", "NA", "INF", "Inf") , sep = "\t", stringsAsFactors = FALSE) %>% as_tibble %>% add_column(., "splicemode" = .y)) %>% 
                                        set_names(list_of_AS_events), .progress = TRUE, .options = future_options(globals = c("list_of_AS_events", "results_dir", "tibble"))) %>% set_names(list_of_timepoint_comparisons_final)

# bind rows for each comparison

list_of_detailed_tables_2 <- purrr::map(.x = list_of_detailed_tables, .f = ~rbindlist(.x))

# rename the colnames to be not comparison-specific - we will add a comparison column later on

list_of_detailed_tables_3 <- purrr::map2(.x = list_of_detailed_tables_2, .y = list_of_timepoint_comparisons_final, .f = ~setNames(., c("Gene", "AS_event_ID", "AS_structure_ID", "sub_junction_ID", "sub-junction_dispersion_estimate", "LRT_statistic-full_vs_reduced", "LRT_p_value-full_vs_reduced", "BH_adjusted_p-values", "logCPM_1", "logCPM_2", "fitting_parameter_log2fold_change_2_from_1", "sub_junction_chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand", "raw_count.1", "raw_count.2", "raw_count.3", "raw_count.4", "raw_count.5", "raw_count.6", "percentage_usage.1", "percentage_usage.2", "percentage_usage.3", "percentage_usage.4", "percentage_usage.5", "percentage_usage.6", "deltaPSI", "splicemode")) %>% add_column(., "comparison" = .y)) 

wide_tibble_of_all_detailed_tables_with_na <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble

# remove rows where gene = gene
wide_tibble_of_all_detailed_tables_with_na <- wide_tibble_of_all_detailed_tables_with_na[-which(wide_tibble_of_all_detailed_tables_with_na$Gene == "Gene"), ]

# add column of contributing junctions
## first remove the leading marker
vector_AS.structure.ID.processed <- gsub(wide_tibble_of_all_detailed_tables_with_na$AS_structure_ID, pattern = "^(5_|3_|.*-)(.*)", replacement = "\\2")
## then split the string by "Junction_"
list_AS.structure.ID.processed <- vector_AS.structure.ID.processed %>% gsub(x = ., pattern = "Junction_", replacement = "") %>% strsplit(., split = "_")
## then add the "Junction_" string back into the original table of all detailed tables
unlist_AS.structure.ID.processed <- future_map(.x = list_AS.structure.ID.processed, .f = ~paste("Junction_", .x, sep = "") %>% paste(collapse = ","), .progress = TRUE, .options = future_options(globals = FALSE)) %>% unlist
wide_tibble_of_all_detailed_tables_with_na <- wide_tibble_of_all_detailed_tables_with_na %>% add_column("contributing_junctions" = unlist_AS.structure.ID.processed, .after = "AS_structure_ID")

```

## match each AS_event_ID to the reference NMD/first_last annotation

```{r}{r eval=FALSE, include=FALSE}

# split the contributing junction column by comma
list_contributing_junctions <- strsplit(wide_tibble_of_all_detailed_tables_with_na$contributing_junctions, split = ",")

# match each disassembled junction structure against the reference annotation of junctions.
## set names for matching
list_of_tibblised_contributing_junctions <- future_map(.x = list_contributing_junctions, .f = ~tibble::enframe(.x, value = "junction_ID", name = NULL), .progress = TRUE, .options = future_options(globals = c("tibble")))
## do a dplyr left join on each disassembled junction with the annotation
list_of_contributing_junctions_joined_to_annotation <- future_map(.x = list_of_tibblised_contributing_junctions, .f = ~dplyr::left_join(.x, tibble_gtf_matching_exon_entries_extracted, by = "junction_ID"), .progress = TRUE, .options = future_options(globals = c("tibble_gtf_matching_exon_entries_extracted"), packages = "dplyr"))

# append the AS_event_id to each entry
list_of_AS.event.ID_joined_to_annotation <- future_map2(.x = list_of_contributing_junctions_joined_to_annotation, .y = wide_tibble_of_all_detailed_tables_with_na$AS_event_ID, .f = ~add_column(.x, "AS_event_ID" = .y, .before = 1), .progress = TRUE, .options = future_options(globals = c("tibble")))
# tibblise and save
tibble_of_AS.event.ID_joined_to_annotation <- list_of_AS.event.ID_joined_to_annotation %>% rbindlist %>% as_tibble

write.table(x = tibble_of_AS.event.ID_joined_to_annotation, file = paste(results_directory_figures, "tibble_of_AS.event.ID_joined_to_annotation.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# read all the simplified tables into environment

```{r}

vector_of_timepoint_comparisons_final <- read.delim(paste(results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL)

print(head(vector_of_timepoint_comparisons_final))

for (comparison in vector_of_timepoint_comparisons_final[, 1])
{
  
  for (AS_event in c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events"))
  {
    
    assign(x = paste(comparison, "_", AS_event, "_simplified", sep = ""), value = read.delim(file = paste(results_dir, "final_JUM_output_", comparison, "/", list.files(path = paste(results_dir, "final_JUM_output_", comparison, "/", sep = ""), pattern = paste("(.)", AS_event, "(.*)simplified.txt", sep = "")), sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf"), colClasses = "character"))
  
  }
  
}

# this must be equal to the total number of comparisons

length(ls(pattern = "BM_MSC_to_OB(.*)simplified")) / 6

```

# chopping files into a net summary table

note: the final simplified intron retention table outputted by JUM has two header rows. Remove those.

## A3SS_events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_A3SS_simplified_output_table_names <- ls(pattern = "(.*)(_)(A3SS_events)(_simplified$)")
print(paste("There are", length(list_of_A3SS_simplified_output_table_names), "output tables loaded for A3SS_events events:", sep = " "))  
## convert from column of names to column of dfs
list_of_A3SS_simplified_output_tables <- purrr::map(list_of_A3SS_simplified_output_table_names, get)
names(list_of_A3SS_simplified_output_tables) <- list_of_A3SS_simplified_output_table_names
## subset
list_of_A3SS_simplified_output_tables_simplified <- purrr::map(list_of_A3SS_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9))
## annotating the column names to be comparison name specific

A3SS_pvalue_column_names <- gsub(x = list_of_A3SS_simplified_output_table_names, pattern = "(.*)_A3SS_events_simplified", replacement = "pvalue_\\1") %>% as.list
A3SS_qvalue_column_names <- gsub(x = list_of_A3SS_simplified_output_table_names, pattern = "(.*)_A3SS_events_simplified", replacement = "qvalue_\\1") %>% as.list

list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_simplified, .y = A3SS_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_shuffled, .y = A3SS_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))


# list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_simplified, .y = A3SS_pvalue_column_names, ~rename(.x, !!.y := 5))
# list_of_A3SS_simplified_output_tables_shuffled <- purrr::map2(.x = list_of_A3SS_simplified_output_tables_shuffled, .y = A3SS_qvalue_column_names, ~rename(.x, !!.y := 6))

print(paste("Shuffled", length(list_of_A3SS_simplified_output_tables_shuffled), "output tables for A3SS_events events:", sep = " "))  

# conduct full join of all the shuffled tables

A3SS_summary_table <- list_of_A3SS_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("common_5_SS_coor", "Gene", "AS_event_ID", "A3SS_coordinates"))

# NOTEEEEEE: further column exclusion later on.

# A3SS_trimmed_table <- A3SS_summary_table[, c(1, 2, 5, 6, 7... to the end)]

```

## A5SS_events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_A5SS_simplified_output_table_names <- ls(pattern = "(.*)(_)(A5SS_events)(_simplified$)")
print(paste("There are", length(list_of_A5SS_simplified_output_table_names), "output tables loaded for A5SS_events events:", sep = " "))  
## convert from column of names to column of dfs
list_of_A5SS_simplified_output_tables <- purrr::map(list_of_A5SS_simplified_output_table_names, get)
names(list_of_A5SS_simplified_output_tables) <- list_of_A5SS_simplified_output_table_names

## subset
list_of_A5SS_simplified_output_tables_simplified <- purrr::map(list_of_A5SS_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9))
## annotating the column names to be comparison name specific

A5SS_pvalue_column_names <- gsub(x = list_of_A5SS_simplified_output_table_names, pattern = "(.*)_A5SS_events_simplified", replacement = "pvalue_\\1")
A5SS_qvalue_column_names <- gsub(x = list_of_A5SS_simplified_output_table_names, pattern = "(.*)_A5SS_events_simplified", replacement = "qvalue_\\1")

list_of_A5SS_simplified_output_tables_shuffled <- purrr::map2(list_of_A5SS_simplified_output_tables_simplified, A5SS_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_A5SS_simplified_output_tables_shuffled <- purrr::map2(list_of_A5SS_simplified_output_tables_shuffled, A5SS_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_A5SS_simplified_output_tables_shuffled), "output tables for A5SS_events events:", sep = " "))  

# conduct full join of all the shuffled tables

A5SS_summary_table <- list_of_A5SS_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("common_3_SS_coor", "Gene", "AS_event_ID", "A5SS_coordinates"))


```

## cassette exon

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_cassette_exon_simplified_output_table_names <- ls(pattern = "(.*)(_)(cassette_exon_events)(_simplified$)")
print(paste("There are", length(list_of_cassette_exon_simplified_output_table_names), "output tables loaded for cassette exon events:", sep = " "))  
## convert from column of names to column of dfs
list_of_cassette_exon_simplified_output_tables <- purrr::map(list_of_cassette_exon_simplified_output_table_names, get)
names(list_of_cassette_exon_simplified_output_tables) <- list_of_cassette_exon_simplified_output_table_names

## subset
list_of_cassette_exon_simplified_output_tables_simplified <- purrr::map(list_of_cassette_exon_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9, 10, 11))
## annotating the column names to be comparison name specific

cassette_exon_pvalue_column_names <- gsub(x = list_of_cassette_exon_simplified_output_table_names, pattern = "(.*)_cassette_exon_events_simplified", replacement = "pvalue_\\1")
cassette_exon_qvalue_column_names <- gsub(x = list_of_cassette_exon_simplified_output_table_names, pattern = "(.*)_cassette_exon_events_simplified", replacement = "qvalue_\\1")


list_of_cassette_exon_simplified_output_tables_shuffled <- purrr::map2(list_of_cassette_exon_simplified_output_tables_simplified, cassette_exon_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_cassette_exon_simplified_output_tables_shuffled <- purrr::map2(list_of_cassette_exon_simplified_output_tables_shuffled, cassette_exon_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_cassette_exon_simplified_output_tables_shuffled), "output tables for cassette exon events:", sep = " "))  

# conduct full join of all the shuffled tables

cassette_exon_summary_table <- list_of_cassette_exon_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("upstream_exon_end_coor", "downstream_exon_start_coor", "Gene", "AS_event_ID", "cassette_exon_start_coor", "cassette_exon_end_coor"))


```

## MXE events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_MXE_events_simplified_output_table_names <- ls(pattern = "(.*)(_)(MXE_events)(_simplified$)")
print(paste("There are", length(list_of_MXE_events_simplified_output_table_names), "output tables loaded for MXE events:", sep = " "))  
## convert from column of names to column of dfs
list_of_MXE_events_simplified_output_tables <- purrr::map(list_of_MXE_events_simplified_output_table_names, get)
names(list_of_MXE_events_simplified_output_tables) <- list_of_MXE_events_simplified_output_table_names

## subset
list_of_MXE_events_simplified_output_tables_simplified <- purrr::map(list_of_MXE_events_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9, 10))
## annotating the column names to be comparison name specific

MXE_events_pvalue_column_names <- gsub(x = list_of_MXE_events_simplified_output_table_names, pattern = "(.*)_MXE_events_simplified", replacement = "pvalue_\\1")
MXE_events_qvalue_column_names <- gsub(x = list_of_MXE_events_simplified_output_table_names, pattern = "(.*)_MXE_events_simplified", replacement = "qvalue_\\1")


list_of_MXE_events_simplified_output_tables_shuffled <- purrr::map2(list_of_MXE_events_simplified_output_tables_simplified, MXE_events_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_MXE_events_simplified_output_tables_shuffled <- purrr::map2(list_of_MXE_events_simplified_output_tables_shuffled, MXE_events_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_MXE_events_simplified_output_tables_shuffled), "output tables for MXE exon events:", sep = " "))  

# conduct full join of all the shuffled tables

MXE_events_summary_table <- list_of_MXE_events_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("upstream_exon_end_coor", "downstream_exon_start_coor", "Gene", "AS_event_ID", "MXE_exon_coordinates"))

MXE_events_summary_table_split <- split_JUM_output_table(MXE_events_summary_table, "MXE_exon_coordinates", "MXE_events")

```

## composite events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_composite_events_simplified_output_table_names <- ls(pattern = "(.*)(_)(composite_events)(_simplified$)")
print(paste("There are", length(list_of_composite_events_simplified_output_table_names), "output tables loaded for composite events:", sep = " "))  
## convert from column of names to column of dfs
list_of_composite_events_simplified_output_tables <- purrr::map(list_of_composite_events_simplified_output_table_names, get)
## subset
list_of_composite_events_simplified_output_tables_simplified <- purrr::map(list_of_composite_events_simplified_output_tables, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8))
## annotating the column names to be comparison name specific

composite_events_pvalue_column_names <- gsub(x = list_of_composite_events_simplified_output_table_names, pattern = "(.*)_composite_events_simplified", replacement = "pvalue_\\1")
composite_events_qvalue_column_names <- gsub(x = list_of_composite_events_simplified_output_table_names, pattern = "(.*)_composite_events_simplified", replacement = "qvalue_\\1")


list_of_composite_events_simplified_output_tables_shuffled <- purrr::map2(list_of_composite_events_simplified_output_tables_simplified, composite_events_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_composite_events_simplified_output_tables_shuffled <- purrr::map2(list_of_composite_events_simplified_output_tables_shuffled, composite_events_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_composite_events_simplified_output_tables_shuffled), "output tables for composite events:", sep = " "))  

# conduct full join of all the shuffled tables

composite_events_summary_table <- list_of_composite_events_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("Composite_coordinates", "Gene", "AS_event_ID"))

# composite_events_summary_table_split <- split_JUM_output_table(composite_events_summary_table, "Composite_coordinates", "composite_events")

```

## IR events

```{r}

# create column containing every simplified output table, subset only the rows of relevance and create summary tables with a full join
list_of_intron_retention_simplified_output_table_names <- ls(pattern = "(.*)(_)(intron_retention)(_simplified$)")
print(paste("There are", length(list_of_intron_retention_simplified_output_table_names), "output tables loaded for IR events:", sep = " "))  
## convert from column of names to column of dfs
list_of_intron_retention_simplified_output_tables <- purrr::map(list_of_intron_retention_simplified_output_table_names, get)
names(list_of_intron_retention_simplified_output_tables) <- list_of_intron_retention_simplified_output_table_names

## subset
list_of_intron_retention_simplified_output_tables_simplified <- list_of_intron_retention_simplified_output_tables %>% purrr::map(~dplyr::filter(.x, chromosome != "chromosome", Gene != "", pvalue != ""))

list_of_intron_retention_simplified_output_tables_simplified <- purrr::map(list_of_intron_retention_simplified_output_tables_simplified, ~dplyr::select(.x, 1, 2, 5, 6, 7, 8, 9))
## annotating the column names to be comparison name specific

intron_retention_pvalue_column_names <- gsub(x = list_of_intron_retention_simplified_output_table_names, pattern = "(.*)_intron_retention_simplified", replacement = "pvalue_\\1")
intron_retention_qvalue_column_names <- gsub(x = list_of_intron_retention_simplified_output_table_names, pattern = "(.*)_intron_retention_simplified", replacement = "qvalue_\\1")


list_of_intron_retention_simplified_output_tables_shuffled <- purrr::map2(list_of_intron_retention_simplified_output_tables_simplified, intron_retention_pvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "pvalue", replacement = paste(.y, sep = ""))))
list_of_intron_retention_simplified_output_tables_shuffled <- purrr::map2(list_of_intron_retention_simplified_output_tables_shuffled, intron_retention_qvalue_column_names, ~setNames(.x, gsub(x = colnames(.x), pattern = "qvalue", replacement = paste(.y, sep = ""))))

print(paste("Shuffled", length(list_of_intron_retention_simplified_output_tables_shuffled), "output tables for IR events:", sep = " "))  

# conduct full join of all the shuffled tables

intron_retention_summary_table <- list_of_intron_retention_simplified_output_tables_shuffled %>% purrr::reduce(full_join, by = c("retained_intron_start", "retained_intron_end", "Gene", "AS_event_ID"))

```

## discard the superfluous columns for each table containing each splice mode

```{r}

# generating the list of tables
list_of_summary_tables <- list(A3SS_summary_table, A5SS_summary_table, cassette_exon_summary_table, composite_events_summary_table, intron_retention_summary_table, MXE_events_summary_table)

# naming the list of tables
list_of_summary_table_names <- c("A3SS_events_summary_table", "A5SS_events_summary_table", "cassette_exon_events_summary_table", "composite_events_summary_table", "intron_retention_summary_table", "MXE_events_summary_table")
names(list_of_summary_tables) <- list_of_summary_table_names

# remove columns we don't want

list_of_summary_tables_reduced <- list_of_summary_tables

list_of_summary_tables_reduced[[1]] <- list_of_summary_tables_reduced[[1]] %>% dplyr::select(., -3, -4)
list_of_summary_tables_reduced[[2]] <- list_of_summary_tables_reduced[[2]] %>% dplyr::select(., -3, -4)
list_of_summary_tables_reduced[[3]] <- list_of_summary_tables_reduced[[3]] %>% dplyr::select(., -(3:6))
list_of_summary_tables_reduced[[4]] <- list_of_summary_tables_reduced[[4]] %>% dplyr::select(., -3)
list_of_summary_tables_reduced[[5]] <- list_of_summary_tables_reduced[[5]] %>% dplyr::select(., -3, -4)
list_of_summary_tables_reduced[[6]] <- list_of_summary_tables_reduced[[6]] %>% dplyr::select(., -(3:5))

```

## append the name of the splice mode to each data frame 

```{r}

splicemode_colname <- rep("splicemode", 6)

column_of_splicemode_names <- gsub(x = list_of_summary_table_names, pattern = "(.*)_summary_table", replacement = "\\1")

list_of_summary_tables_reduced_appendedwithsplicemode <- purrr::map2(.x = list_of_summary_tables_reduced, .y = column_of_splicemode_names, ~cbind(.x, splicemode=.y))

```

## combining the summary tables for each splice mode into a large table, split ; delimiting

NOTE: wide_table_all_splicemodes_split IS THE MAIN TABULAR OUTPUT THAT CONTAINS VALUES THAT EXIST IN *ALL* COMPARISONS. IT WILL BE USED FOR SOMS ANALYSIS AND OTHER ANALYSES THAT REQUIRE DATA FROM ALL COMPARISONS. 

NOTE2: wide_table_of_all_splicemodes(_with_na)/wide_table_all_splicemodes_split_with_na IS/ARE THE MAIN TABULAR OUTPUT(S) THAT CONTAIN(S) *EVERYTHING*, EVEN NA VALUES. USED FOR GENE ONTOLOGY

```{r}

wide_table_of_all_splicemodes_with_na <-  purrr::reduce(.x = list_of_summary_tables_reduced_appendedwithsplicemode, .f = bind_rows) %>% type_convert(trim_ws = TRUE)

# get the column numbers which have dpsi and qvalue info
vector_wide_table_of_all_splicemodes_with_na_dpsi.colnumbers <- grep(x = colnames(wide_table_of_all_splicemodes_with_na), pattern = "deltaPSI")
vector_wide_table_of_all_splicemodes_with_na_qvalue.colnumbers <- grep(x = colnames(wide_table_of_all_splicemodes_with_na), pattern = "qvalue")
vector_wide_table_of_all_splicemodes_with_na_pvalue.colnumbers <- grep(x = colnames(wide_table_of_all_splicemodes_with_na), pattern = "pvalue")
vector_wide_table_of_all_splicemodes_with_na_value.colnumbers <- c(vector_wide_table_of_all_splicemodes_with_na_dpsi.colnumbers, vector_wide_table_of_all_splicemodes_with_na_qvalue.colnumbers, vector_wide_table_of_all_splicemodes_with_na_pvalue.colnumbers)

# create array_tree for both column types so we can subset each row
# each set of 3 columns containing pvalue, qvalue and dpsi is a 3-cell
list_dpsi.and.qvalue.colnumbers <- tibble(vector_wide_table_of_all_splicemodes_with_na_dpsi.colnumbers, vector_wide_table_of_all_splicemodes_with_na_qvalue.colnumbers) %>% array_tree
# create array_tree for all column types (this time including pvalue) so we can filter each row
list_dpsi.pvalue.and.qvalue.colnumbers <- tibble(vector_wide_table_of_all_splicemodes_with_na_dpsi.colnumbers, vector_wide_table_of_all_splicemodes_with_na_pvalue.colnumbers, vector_wide_table_of_all_splicemodes_with_na_qvalue.colnumbers) %>% array_tree

# filter out columns which do not have BOTH a dpsi value and qvalue associated with it.
# return a vector of logicals indicating whether there a row has at least one dpsi/qvalue value.
# if a column is TRUE, it means there are no valid rows. (all 3-cells are incomplete)
# the end effect is that columns are removed 3 at a time
# debug: 
# is all na
# purrr::map(.x = list_dpsi.and.qvalue.colnumbers, .f = ~wide_table_of_all_splicemodes_with_na[13030, c(.x[[1]], .x[[2]])] %>% unlist %>% is.na(.) %>% all(. == TRUE)) %>% unlist %>% all(. == TRUE)
# contains infinite values: TRUE if there is inf - we chuck it away
# purrr::map(.x = list_dpsi.and.qvalue.colnumbers, .f = ~length(wide_table_of_all_splicemodes_with_na[244, c(.x[[1]], .x[[2]])] %>% unlist %>% grep(., pattern = "inf", ignore.case = TRUE)) > 0) %>% unlist %>% all(. == TRUE)

wide_table_of_all_splicemodes_with_na_2 <- apply(X = wide_table_of_all_splicemodes_with_na, MARGIN = 1, FUN = function(X) {
  
  # DEBUG
  # X <- wide_table_of_all_splicemodes_with_na[13030, ]
  
  na_test <- purrr::map(.x = list_dpsi.and.qvalue.colnumbers, .f = ~X[c(.x[[1]], .x[[2]])] %>% unlist %>% is.na(.) %>% all(. == TRUE)) %>% unlist
  inf_test <- purrr::map(.x = list_dpsi.and.qvalue.colnumbers, .f = ~length(X[c(.x[[1]], .x[[2]])] %>% unlist %>% grep(., pattern = "inf|nan", ignore.case = TRUE)) > 0) %>% unlist
  
  all_tests <- data.frame("na_test" = na_test, "inf_test" = inf_test)
  
  # per 3-cell: if TRUE for any test of invalidity, we chuck it out with NA. if FALSE for any test, we leave the values alone.
  merged_test <- apply(all_tests, 1, function(Y) {any(Y == TRUE)})
  
  invalid_columns <- list_dpsi.pvalue.and.qvalue.colnumbers[which(merged_test == TRUE)] %>% unlist
  valid_columns <- list_dpsi.pvalue.and.qvalue.colnumbers[which(merged_test == FALSE)] %>% unlist
  
  filtered_X <- X
  filtered_X[invalid_columns] <- NA
  
  return(filtered_X)
  
}) %>% t

# remove rows which have all NA values in the data columns
vector_wide_table_of_all_splicemodes_with_na_2_all.NA.rows <- apply(X = wide_table_of_all_splicemodes_with_na_2, MARGIN = 1, FUN = function(X) {all(is.na(X[list_dpsi.pvalue.and.qvalue.colnumbers %>% unlist]))})

wide_table_of_all_splicemodes_with_na_2 <- wide_table_of_all_splicemodes_with_na_2[-which(vector_wide_table_of_all_splicemodes_with_na_2_all.NA.rows == TRUE), ]

wide_table_of_all_splicemodes_with_na_2 <- type_convert(wide_table_of_all_splicemodes_with_na_2 %>% as.data.frame %>% dplyr::mutate_if(is.factor, as.character))

rownames(wide_table_of_all_splicemodes_with_na_2) <- NULL

# SPLITTING THE SEMICOLON DELIMITED VALUES INTO NEW ROWS

wide_table_of_all_splicemodes_with_na_2_column_names <- colnames(wide_table_of_all_splicemodes_with_na_2)

wide_table_of_all_splicemodes_with_na_2_dPSI_column_numbers <- wide_table_of_all_splicemodes_with_na_2_column_names %>% grep(., pattern = "deltaPSI(.*)")

# A. SPLITTING EACH CELL OF DELTAPSI INTO SEPARATE ROWS
# THIS OUTPUTS A LIST WITH EACH ELEMENT CONTAINING THE VALUES OF EACH ROW
list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split <- wide_table_of_all_splicemodes_with_na_2[, wide_table_of_all_splicemodes_with_na_2_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){strsplit(x, split = ";")})

# test <- wide_table_of_all_splicemodes_with_na_2[, c(5,8)] %>% t %>% array_tree %>% purrr::map(~.x[510:520] %>% unlist(.x) %>% strsplit(.x, split = ";") %>% unlist)
# 
# test0 <- wide_table_of_all_splicemodes_with_na_2[510:520, c(5,8)]

# WE MUST FIRST DEFINE THE FINAL TABLE THEN GO BACK TO FINISHING THE FINAL TABLE BECAUSE IT NEEDS TO SCAFFOLD BASED ON A PREDETERMINED NUMBER OF ROWS IN data.frame(matrix(...))

# B. USE SPLITTING LENGTH FOR EACH ROW TO DETERMINE THE AMOUNT OF TIMES ROWS ARE TO BE REPEATED.
# because there are a load of missing values, we need to take the maximum number of times each row needs to be repeated.
list_of_vectors_row.repetition.lengths_based.on.dpsi.columns <- purrr::imap(.x = list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split, .f = ~purrr::map(.x = .x, .f = ~length(.x)) %>% unlist %>% as.data.frame %>% setNames(.y))
df_row.repetition.lengths_based.on.dpsi.columns <- list_of_vectors_row.repetition.lengths_based.on.dpsi.columns %>% purrr::reduce(bind_cols)
vector_max_row.repetition.lengths_based.on.dpsi.columns <- apply(df_row.repetition.lengths_based.on.dpsi.columns, 1, max)

# go back to the dpsi only list and repeat the NA values according to this vector
list_non.na.elements <- purrr::map(.x = list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split, .f = ~which(purrr::map(.x = .x, .f = ~all(is.na(.x))) %>% unlist == FALSE))
list_max.repetition.lengths <- purrr::map(.x = list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split, .f = ~vector_max_row.repetition.lengths_based.on.dpsi.columns %>% array_tree)

replace_list_element <- function(target_list, vector_of_positions, replacement) {
  
  replacement_list <- target_list
  
  replacement_list[vector_of_positions] <- replacement
  
  return(replacement_list)
  
}

list_max.repetition.lengths.for.na.only <- purrr::map2(.x = list_max.repetition.lengths, .y = list_non.na.elements, .f = ~replace_list_element(.x, .y, 1))

list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split_2 <- purrr::map2(.x = list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split, .y = list_max.repetition.lengths.for.na.only, .f = ~map2(.x = .x, .y = .y, .f = ~rep(.x, times = .y)))

# the non-dPSI values part of the table is created here
wide_table_of_all_splicemodes_with_na_2_non_dPSI_values_only_split <- wide_table_of_all_splicemodes_with_na_2[, -wide_table_of_all_splicemodes_with_na_2_dPSI_column_numbers] %>% apply(., MARGIN = 2, FUN = function(x){rep(x, vector_max_row.repetition.lengths_based.on.dpsi.columns)}) %>% data.frame

vector_isoform_number <- purrr::map(.x = vector_max_row.repetition.lengths_based.on.dpsi.columns, ~c(1:.x)) %>% unlist

# DONE STEP B.

# BACK TO A.
wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split <- purrr::map2(.x = list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split_2, .y = names(list_of_subset_of_wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split_2), .f = ~unlist(.x) %>% as.data.frame %>% setNames(.y)) %>% purrr::reduce(dplyr::bind_cols)
  
# DONE STEP A.

# APPEND THE TWO TABLES TO RE-CREATE THE WIDE MASTER TABLE EXCEPT THE VALUES ARE ACTUALLY REOBABLE BY R NOW.
wide_table_all_splicemodes_split_with_na <- dplyr::bind_cols(wide_table_of_all_splicemodes_with_na_2_non_dPSI_values_only_split, wide_table_of_all_splicemodes_with_na_2_dPSI_values_only_split)

# rearrange the columns to preserve consistency with the rest of the wide_table s
wide_table_all_splicemodes_split_with_na <- wide_table_all_splicemodes_split_with_na[, colnames(wide_table_of_all_splicemodes_with_na)]

# append the list of isoform numbers
wide_table_all_splicemodes_split_with_na <- cbind(wide_table_all_splicemodes_split_with_na, isoform_number = vector_isoform_number)

# reconvert values, remove whitespace
wide_table_all_splicemodes_split_with_na <- type_convert(wide_table_all_splicemodes_split_with_na %>% dplyr::mutate_if(is.factor, as.character), trim_ws = TRUE)

# create isoform_ID
wide_table_all_splicemodes_split_with_na[, "isoform_ID"] <- paste(wide_table_all_splicemodes_split_with_na[, "splicemode"], wide_table_all_splicemodes_split_with_na[, "AS_event_ID"], wide_table_all_splicemodes_split_with_na[, "isoform_number"], sep = "_")

# write table 
write.table(x = wide_table_all_splicemodes_split_with_na, file = paste(results_directory_figures, "wide_table_of_all_JUM_results_", nrow(wide_table_all_splicemodes_split_with_na), "_entries_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# write all unique genes as background
vec_all_JUM_genes_genesymbol <- wide_table_all_splicemodes_split_with_na$Gene %>% unique
write.table(x = vec_all_JUM_genes_genesymbol, file = paste(results_dir, "table_of_all_JUM_genes_genesymbol.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
# convert to ENSG
vec_all_JUM_genes_ENSG <- getBM(filters = "external_gene_name", values = vec_all_JUM_genes_genesymbol, attributes = "ensembl_gene_id", mart = ensembl_mart)
write.table(x = vec_all_JUM_genes_ENSG, file = paste(results_dir, "table_of_all_JUM_genes_ENSG.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

```

## append the annotation information (NMD, first/last exon... etc)

```{r}

# read the table of annotation
tibble_of_AS.event.ID_joined_to_annotation <- read.delim(paste(results_directory_figures, "tibble_of_AS.event.ID_joined_to_annotation.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# extract the row indices of IR event entries from the wide_table_all_splicemodes_split_with_na - treatment is more complicated.
row.indices_IR_events <- which(wide_table_all_splicemodes_split_with_na$splicemode == "intron_retention")

```

### NON-IR ENTRIES

```{r}

# for non-IR event entries, treatment is simple. we just match with the annotation. if any contributing junction has an attribute, then we will say there is attribute for the whole AS_event_id.
## array tree-ify the AS_event_IDs for looping
as.event.id_array.tree_not.IR <- wide_table_all_splicemodes_split_with_na[-row.indices_IR_events, ] %>% .$AS_event_ID %>% unique %>% array_tree
## look up the annotation tibble for each AS_event_ID, summarise.
list_as.event.id_with_summarised_annotation_not.IR <- future_map(.x = as.event.id_array.tree_not.IR, .f = function(.x) {
  
  # DEBUG ###
  # .x <- as.event.id_array.tree_not.IR[[3]]
  ###########
  
  subset_tibble_annotation <- tibble_of_AS.event.ID_joined_to_annotation[tibble_of_AS.event.ID_joined_to_annotation$AS_event_ID == .x, ] %>% unique
  
  summarised_tibble_annotation <- tibble("AS_event_ID" = .x, 
                                         "contributing_junction_IDs" = subset_tibble_annotation$junction_ID %>% paste(collapse = ";"),
                                         "chr" = subset_tibble_annotation$chr %>% paste(collapse = ";"),
                                         "start" = subset_tibble_annotation$start %>% paste(collapse = ";"),
                                         "end" = subset_tibble_annotation$end %>% paste(collapse = ";"),
                                         "strand" = subset_tibble_annotation$strand %>% paste(collapse = ";"),
                                         "matched_gene_names" = subset_tibble_annotation$matched_gene_names %>% paste(collapse = ";"),
                                         "matched_ref_transcript_names" = subset_tibble_annotation$matched_ref_transcript_names %>% paste(collapse = ";"),
                                         "matched_recon_transcript_names" = subset_tibble_annotation$matched_recon_transcript_names %>% paste(collapse = ";"),
                                         "NMD_reference" = subset_tibble_annotation$NMD_reference %>% paste(collapse = ";"),
                                         "NMD_recon" = subset_tibble_annotation$NMD_recon %>% paste(collapse = ";"),
                                         "any_NMD" = any(c(grep(x = subset_tibble_annotation$NMD_reference, pattern = "TRUE") %>% na.omit,
                                                           grep(x = subset_tibble_annotation$NMD_recon, pattern = "TRUE") %>% na.omit)),
                                         "first_or_last_exon_reference" = subset_tibble_annotation$first_or_last_exon_reference %>% paste(collapse = ";"),
                                         "first_or_last_exon_recon" = subset_tibble_annotation$first_or_last_exon_recon %>% paste(collapse = ";"),
                                         "any_first_exon" = any(c(grep(x = subset_tibble_annotation$first_or_last_exon_reference, pattern = "first_exon") %>% na.omit, 
                                                                  grep(x = subset_tibble_annotation$first_or_last_exon_recon, pattern = "first_exon") %>% na.omit)),
                                         "any_last_exon" = any(c(grep(x = subset_tibble_annotation$first_or_last_exon_reference, pattern = "last_exon") %>% na.omit, 
                                                                  grep(x = subset_tibble_annotation$first_or_last_exon_recon, pattern = "last_exon") %>% na.omit))
                                         )
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_of_AS.event.ID_joined_to_annotation", "tibble")))

tibble_as.event.id_with_summarised_annotation_not.IR <- list_as.event.id_with_summarised_annotation_not.IR %>% rbindlist %>% as_tibble

```

### IR ENTRIES

```{r}

# for IR event entries, complicated. First retrieve the matched/recon transcripts. then find transcripts with overlapping exons.
# These IR-spanning transcripts must have at least ONE start/end coord/gene name in common with the junction-matched transcripts.
# return their corresponding annotations.
# NOTE: it seems like JUM only associates one junction ID with each IR event (which makes sense). However, my small sample size of 52 IR junctions isn't enough to fully conclude this is the case.
## array tree-ify the AS_event_IDs for looping
as.event.id_array.tree_IR <- wide_table_all_splicemodes_split_with_na[row.indices_IR_events, ] %>% .$AS_event_ID %>% unique %>% array_tree

## look up the annotation tibble for each AS_event_ID, summarise.
list_as.event.id_with_summarised_annotation_IR <- purrr::imap(.x = as.event.id_array.tree_IR, .f = function(.x, .y) {
  
  message("now processing entry number: ", .y)
  
  # DEBUG ###
  # .x <- as.event.id_array.tree_IR[[6]]
  # tibble_ref_gtf <- tibble_ref_gtf
  # tibble_recon_gtf <- tibble_recon_gtf
  ###########
  
  tibble_ref_gtf <<- tibble_ref_gtf
  tibble_recon_gtf <<- tibble_recon_gtf
  
  subset_tibble_annotation <- tibble_of_AS.event.ID_joined_to_annotation[tibble_of_AS.event.ID_joined_to_annotation$AS_event_ID == .x, ] %>% unique
  
  chr <- subset_tibble_annotation$chr %>% paste
  start <- subset_tibble_annotation$start %>% paste
  end <- subset_tibble_annotation$end %>% paste
  strand <- subset_tibble_annotation$strand %>% paste
  vec_ref_transcripts_matched_to_junction <- subset_tibble_annotation$matched_ref_transcript_names %>% strsplit(split = ",") %>% unlist %>% tibble::enframe(name = NULL, value = "transcript_id")
  vec_recon_transcripts_matched_to_junction <- subset_tibble_annotation$matched_recon_transcript_names %>% strsplit(split = ",") %>% unlist %>% tibble::enframe(name = NULL, value = "transcript_id")
  
  # check reference annotation - but only if the junction was matched to reference in the first place.
  tibble_all_confirmed_IR_entries_ref <- "uninit"
  
  if (all(is.na(vec_ref_transcripts_matched_to_junction)) != TRUE) {
    
    # match IR region to reference
    tibble_ref_gtf_subset_IR_overlap <- tibble_ref_gtf[tibble_ref_gtf$seqnames == chr %>% trimws, ] %>% .[.$strand == strand %>% trimws, ] %>% .[.$start <= ((start %>% as.numeric) - 2) & .$end >= ((end %>% as.numeric) + 2), ] %>% .[.$type == "exon", ]
  
    # get all the entries which matched to the junction
    tibble_ref_gtf_subset_junction_matching_entries <- dplyr::semi_join(tibble_ref_gtf[tibble_ref_gtf$type == "exon", ], vec_ref_transcripts_matched_to_junction, by = "transcript_id")
    
    # extract all the start coords of the junction-matched entries
    vector_junction_matched_start_coords <- tibble_ref_gtf_subset_junction_matching_entries[, "start"]
    # find which IR matched entry has any same start coord
    tibble_ref_gtf_subset_IR_overlap_start.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_start_coords)
    
    # extract all the end coords of the junction-matched entries
    vector_junction_matched_end_coords <- tibble_ref_gtf_subset_junction_matching_entries[, "end"]
    # find which IR matched entry has any same end coord
    tibble_ref_gtf_subset_IR_overlap_end.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_end_coords)
    
    # extract all the gene names of the junction-matched entries
    vector_junction_matched_gene_names <- tibble_ref_gtf_subset_junction_matching_entries[, "gene_name"]
    # find which IR matched entry has any same end coord
    tibble_ref_gtf_subset_IR_overlap_gene.name.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_gene_names)
    
    tibble_union_start.and.end.matched <- list(tibble_ref_gtf_subset_IR_overlap_start.matched, 
                                            tibble_ref_gtf_subset_IR_overlap_end.matched,
                                            tibble_ref_gtf_subset_IR_overlap_gene.name.matched) %>% purrr::reduce(dplyr::union)
    
    if (nrow(tibble_union_start.and.end.matched) == 0) {
      
      tibble_all_confirmed_IR_entries_ref <- "uninit"
      
    } else if (nrow(tibble_union_start.and.end.matched) > 0) {
      
      tibble_all_confirmed_IR_entries_ref <- tibble_union_start.and.end.matched
      
    }
    
  }
  
  # check recon annotation - but only if the junction was matched to recon in the first place.
  tibble_all_confirmed_IR_entries_recon <- "uninit"
  
  if (all(is.na(vec_recon_transcripts_matched_to_junction)) != TRUE) {
    
    # match IR region to recon GTF
    tibble_recon_gtf_subset_IR_overlap <- tibble_recon_gtf[tibble_recon_gtf$seqnames == chr %>% trimws, ] %>% .[.$strand == strand %>% trimws, ] %>% .[.$start <= ((start %>% as.numeric) - 2) & .$end >= ((end %>% as.numeric) + 2), ] %>% .[.$type == "exon", ]
  
    # get all the entries which matched to the junction
    tibble_recon_gtf_subset_junction_matching_entries <- dplyr::semi_join(tibble_recon_gtf[tibble_recon_gtf$type == "exon", ], vec_recon_transcripts_matched_to_junction, by = "transcript_id")
    
    # extract all the start coords of the junction-matched entries
    vector_junction_matched_start_coords <- tibble_recon_gtf_subset_junction_matching_entries[, "start"]
    # find which IR matched entry has any same start coord
    tibble_recon_gtf_subset_IR_overlap_start.matched <- dplyr::semi_join(tibble_recon_gtf_subset_IR_overlap, vector_junction_matched_start_coords)
    
    # extract all the end coords of the junction-matched entries
    vector_junction_matched_end_coords <- tibble_recon_gtf_subset_junction_matching_entries[, "end"]
    # find which IR matched entry has any same end coord
    tibble_recon_gtf_subset_IR_overlap_end.matched <- dplyr::semi_join(tibble_recon_gtf_subset_IR_overlap, vector_junction_matched_end_coords, by = "end")
    
    tibble_union_start.and.end.matched <- list(tibble_recon_gtf_subset_IR_overlap_start.matched, 
                                            tibble_recon_gtf_subset_IR_overlap_end.matched) %>% purrr::reduce(dplyr::union)
    
    if (nrow(tibble_union_start.and.end.matched) == 0) {
      
      tibble_all_confirmed_IR_entries_recon <- "uninit"
      
    } else if (nrow(tibble_union_start.and.end.matched) > 0) {
      
      tibble_all_confirmed_IR_entries_recon <- tibble_union_start.and.end.matched
      
    }
    
  }
  
  # we now have enough info. to write up the final summary
  summarised_tibble_annotation <- tibble("AS_event_ID" = .x, 
                                         "contributing_junction_IDs" = subset_tibble_annotation$junction_ID %>% paste(collapse = ";"),
                                         "chr" = subset_tibble_annotation$chr %>% paste(collapse = ";"),
                                         "start" = subset_tibble_annotation$start %>% paste(collapse = ";"),
                                         "end" = subset_tibble_annotation$end %>% paste(collapse = ";"),
                                         "strand" = subset_tibble_annotation$strand %>% paste(collapse = ";"),
                                         "matched_gene_names" = subset_tibble_annotation$matched_gene_names %>% paste(collapse = ";"),
                                         "matched_ref_transcript_names" = subset_tibble_annotation$matched_ref_transcript_names %>% paste(collapse = ";"),
                                         "matched_recon_transcript_names" = subset_tibble_annotation$matched_recon_transcript_names %>% paste(collapse = ";"),
                                         "NMD_reference" = if (tibble_all_confirmed_IR_entries_ref == "uninit") {
                                           FALSE
                                         } else {
                                           any(tibble_all_confirmed_IR_entries_ref$transcript_biotype == "nonsense_mediated_decay")
                                         },
                                         "NMD_recon" = if (tibble_all_confirmed_IR_entries_recon == "uninit") {
                                           FALSE
                                         } else {
                                           all(tibble_all_confirmed_IR_entries_recon$NMD_candidate == TRUE)
                                         },
                                         "first_or_last_exon_reference" = subset_tibble_annotation$first_or_last_exon_reference %>% paste(collapse = ";"),
                                         "first_or_last_exon_recon" = subset_tibble_annotation$first_or_last_exon_recon %>% paste(collapse = ";"),
                                         "any_first_exon" = any(c(grep(x = subset_tibble_annotation$first_or_last_exon_reference, pattern = "first_exon") %>% na.omit, 
                                                                  grep(x = subset_tibble_annotation$first_or_last_exon_recon, pattern = "first_exon") %>% na.omit)),
                                         "any_last_exon" = any(c(grep(x = subset_tibble_annotation$first_or_last_exon_reference, pattern = "last_exon") %>% na.omit, 
                                                                  grep(x = subset_tibble_annotation$first_or_last_exon_recon, pattern = "last_exon") %>% na.omit))
                                         ) %>% add_column("any_NMD" = any(c(grep(x = .$NMD_reference, pattern = "TRUE") %>% na.omit,
                                                           grep(x = .$NMD_recon, pattern = "TRUE") %>% na.omit)), .after = "NMD_recon")
  
  return(summarised_tibble_annotation)
  
})

tibble_as.event.id_with_summarised_annotation_IR <- list_as.event.id_with_summarised_annotation_IR %>% rbindlist %>% as_tibble

```

### combine non-IR and IR entries, append and save

```{r}

tibble_as.event.id_with_summarised_annotation_all <- rbind(tibble_as.event.id_with_summarised_annotation_not.IR, tibble_as.event.id_with_summarised_annotation_IR)

wide_table_all_splicemodes_split_with_na_with_ref_annot <- dplyr::left_join(wide_table_all_splicemodes_split_with_na, tibble_as.event.id_with_summarised_annotation_all, by = "AS_event_ID")

# write table 
write.table(x = wide_table_all_splicemodes_split_with_na_with_ref_annot, file = paste(results_directory_figures, "wide_table_of_all_JUM_results_", nrow(wide_table_all_splicemodes_split_with_na_with_ref_annot), "_entries_with_na_annotated.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# also write chr start end strand

```

# Filter for dPSI and q/pvalue

NOTE: P/QVALUE AND DPSI FILTERING OCCURS HERE

At this point, wide_table_all_splicemodes_split includes EVERYTHING. OB and OB, qvalue, pvalue and deltaPSI.

At the present time, we shall just cluster the OB time series separate to the OB time series.

Our trick is to use only the "deltaPSI_BM_MSC_to_OB_[something]d-BM_MSC_to_ud" column and use it as a proxy for the absolute inclusion levels. Setting the PSI at timepoint 0 (MSC) is inconsequential for our method of running SOMs, as it normalises the centroid of all PSI values of each isoforms' time series anyways.

**SETUP**

## prepare to filter table of values with na

```{r}

wide_table_all_splicemodes_split_with_na_with_ref_annot <- read.delim(paste(results_directory_figures, "wide_table_of_all_JUM_results_", 37264, "_entries_with_na_annotated.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE)

PSI_levels_timeseries_OB_wide_with_na <- wide_table_all_splicemodes_split_with_na_with_ref_annot %>% as.data.frame

```

## plot the pvalue, qvalue and dpsi distributions

### pvalue

```{r}

# set column indices
vector_PSI_levels_timeseries_OB_wide_pvalue.col.nums <- grep(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = "pvalue")

# plot the pvalue distribution - density
pdf(paste(results_directory_figures, "qualityplot_pvalue_density_distribution_OB_diff.pdf", sep = ""))

plot(density(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_pvalue.col.nums] %>% reshape2::melt(.) %>% .[, 2] %>% na.omit), main = paste("JUM pvalue density distribution"), xlab = "pvalue", ylab = "frequency density")

dev.off()

# plot the pvalue distribution - CDF
pdf(paste(results_directory_figures, "qualityplot_pvalue_CDF_distribution_OB_diff.pdf", sep = ""))

plot(ecdf(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_pvalue.col.nums] %>% reshape2::melt(.) %>% .[, 2] %>% na.omit), main = paste("JUM pvalue CDF distribution"), xlab = "pvalue", ylab = "cumulative frequency")

dev.off()

```

### qvalue

```{r}

# set column indices
vector_PSI_levels_timeseries_OB_wide_qvalue.col.nums <- grep(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = "qvalue")

# plot the qvalue distribution - density
pdf(paste(results_directory_figures, "qualityplot_qvalue_density_distribution_OB_diff.pdf", sep = ""))

plot(density(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_qvalue.col.nums] %>% reshape2::melt(.) %>% .[, 2] %>% na.omit), main = paste("JUM qvalue density distribution"), xlab = "qvalue", ylab = "frequency density")

dev.off()

# plot the qvalue distribution - CDF
pdf(paste(results_directory_figures, "qualityplot_qvalue_CDF_distribution_OB_diff.pdf", sep = ""))

plot(ecdf(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_qvalue.col.nums] %>% reshape2::melt(.) %>% .[, 2] %>% na.omit), main = paste("JUM qvalue CDF distribution"), xlab = "qvalue", ylab = "cumulative frequency")

dev.off()

```

### dpsi

```{r}

# set column indices
vector_PSI_levels_timeseries_OB_wide_dpsi.col.nums <- grep(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = "deltaPSI")

# plot the dpsi distribution - density
pdf(paste(results_directory_figures, "qualityplot_dpsi_density_distribution_OB_diff.pdf", sep = ""))

plot(density(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_dpsi.col.nums] %>% reshape2::melt(.) %>% .[, 2] %>% na.omit), xlim = c(-0.4, 0.4), main = paste("JUM dpsi density distribution"), xlab = "dpsi", ylab = "frequency density")

dev.off()

# plot the dpsi distribution - density
pdf(paste(results_directory_figures, "qualityplot_dpsi_CDF_distribution_OB_diff.pdf", sep = ""))

plot(ecdf(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_dpsi.col.nums] %>% reshape2::melt(.) %>% .[, 2] %>% na.omit), xlim = c(-0.4, 0.4), main = paste("JUM dpsi CDF distribution"), xlab = "dpsi", ylab = "cumulative frequency")
axis(side = 2, at = seq(0, 1, by = 0.1))

dev.off()

```

## filter tables for the specified cutoffs, both with and without NA.

### specify qpvalue, dpsi cutoff

```{r}

dPSI_cutoff <- 0.15

# choose either pvalue or qvalue
p_or_q_value <- "qvalue"

qpvalue_cutoff <- 0.01

```

### do the filtering of differential junctions

```{r}

vector_PSI_levels_timeseries_OB_wide_dpsi.col.nums <- grep(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = "deltaPSI")
vector_PSI_levels_timeseries_OB_wide_qpvalue.col.nums <- grep(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = p_or_q_value)

# filtering for FDR/pvalue
PSI_levels_timeseries_OB_wide_with_na <- PSI_levels_timeseries_OB_wide_with_na[apply(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_qpvalue.col.nums], 1, function(x){any(x %>% as.numeric <= qpvalue_cutoff)}) == TRUE, ]

# filtering for dPSI cutoff
PSI_levels_timeseries_OB_wide_with_na <- PSI_levels_timeseries_OB_wide_with_na[apply(PSI_levels_timeseries_OB_wide_with_na[, vector_PSI_levels_timeseries_OB_wide_dpsi.col.nums], 1, function(x){any(abs(x %>% as.numeric) >= dPSI_cutoff)}) == TRUE, ]

# also write table of differential information for 12d vs. ud.
PSI_levels_timeseries_OB_wide_with_na_ud.12d.only <- PSI_levels_timeseries_OB_wide_with_na[PSI_levels_timeseries_OB_wide_with_na$deltaPSI_BM_MSC_to_OB_12d.BM_MSC_to_OB_ud %>% as.numeric %>% abs >= dPSI_cutoff, ]
# write table
write.table(x = PSI_levels_timeseries_OB_wide_with_na_ud.12d.only, file = paste(results_directory_figures, "wide_table_of_", length(PSI_levels_timeseries_OB_wide_with_na_ud.12d.only$AS_event_ID %>% unique), "_junctions_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_with_na_ud.vs.12d.only.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# export associated gene set
write.table(x = PSI_levels_timeseries_OB_wide_with_na_ud.12d.only$Gene %>% unique %>% na.omit, file = paste(results_directory_figures, "geneset_", length(PSI_levels_timeseries_OB_wide_with_na_ud.12d.only$Gene %>% unique %>% na.omit), "_genes_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_with_na_ud.vs.12d.only.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

# further subsetting into ud-only comparisons

##  OB #####

PSI_levels_timeseries_OB_wide_with_na <- PSI_levels_timeseries_OB_wide_with_na[, c("Gene", "AS_event_ID", "splicemode", "isoform_number", "isoform_ID", "contributing_junction_IDs", "chr", "start", "end", "strand", "matched_gene_names", "matched_ref_transcript_names", "matched_recon_transcript_names", "any_NMD", "any_first_exon", "any_last_exon", colnames(PSI_levels_timeseries_OB_wide_with_na)[grep(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = "(deltaPSI_BM_MSC_to_)(OB)(_[0-9]{1,2}d|_[0-9]{1,2}h|)(.)(BM_MSC_to_OB_ud)")])]

colnames(PSI_levels_timeseries_OB_wide_with_na) <- gsub(x = colnames(PSI_levels_timeseries_OB_wide_with_na), pattern = "(deltaPSI_BM_MSC_to_)(OB_)([0-9]{1,2}d|[0-9]{1,2}h)(.BM_MSC_to_OB_ud)", replacement = "\\3")

# remove extra na
OBseries_timepoints <- c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

PSI_levels_timeseries_OB_wide_na.rows <- apply(PSI_levels_timeseries_OB_wide_with_na[, OBseries_timepoints[2:length(OBseries_timepoints)]], 1, function(X) {all(is.na(X))}) %>% which(. == TRUE)

PSI_levels_timeseries_OB_wide_with_na <- cbind(PSI_levels_timeseries_OB_wide_with_na, MSC = 0)

PSI_levels_timeseries_OB_wide_with_na <- PSI_levels_timeseries_OB_wide_with_na[-PSI_levels_timeseries_OB_wide_na.rows, ]

# reorder cols to match chronological order
PSI_levels_timeseries_OB_wide_with_na <- dplyr::bind_cols(PSI_levels_timeseries_OB_wide_with_na %>% dplyr::select(-OBseries_timepoints), PSI_levels_timeseries_OB_wide_with_na %>% dplyr::select(OBseries_timepoints))

print(paste("There are", length(PSI_levels_timeseries_OB_wide_with_na$AS_event_ID %>% unique), "unique junction structures with", p_or_q_value, "<", qpvalue_cutoff, " and dPSI cutoff of", dPSI_cutoff, "for OB series with missing values"))

write.table(x = PSI_levels_timeseries_OB_wide_with_na, file = paste(results_directory_figures, "wide_table_of_", length(PSI_levels_timeseries_OB_wide_with_na$AS_event_ID %>% unique), "_junctions_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# export associated gene set
write.table(x = PSI_levels_timeseries_OB_wide_with_na$Gene %>% unique %>% na.omit, file = paste(results_directory_figures, "geneset_", length( PSI_levels_timeseries_OB_wide_with_na$Gene %>% unique %>% na.omit), "_genes_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

# remove ALL na to produce the timeseries-ready table
PSI_levels_timeseries_OB_wide_with_na_na.rows <- apply(PSI_levels_timeseries_OB_wide_with_na[, OBseries_timepoints], 1, function(X) {any(is.na(X))}) %>% which(. == TRUE)

PSI_levels_timeseries_OB_wide <- PSI_levels_timeseries_OB_wide_with_na[-PSI_levels_timeseries_OB_wide_with_na_na.rows, ]

row.names(PSI_levels_timeseries_OB_wide) <- NULL

print(paste("There are", length(PSI_levels_timeseries_OB_wide$AS_event_ID %>% unique), "unique junction structures with", p_or_q_value, "<", qpvalue_cutoff, " and dPSI cutoff of", dPSI_cutoff, "for OB series with NO missing values (complete timeseries)"))

write.table(x = PSI_levels_timeseries_OB_wide, file = paste(results_directory_figures, "wide_table_of_", length(PSI_levels_timeseries_OB_wide$AS_event_ID %>% unique), "_junctions_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_no_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### create table of constitutive junctions as well

```{r}

PSI_levels_timeseries_constitutive_OB_wide_with_na <- wide_table_all_splicemodes_split_with_na_with_ref_annot %>% as.data.frame

# define col indices
vector_PSI_levels_timeseries_timeseries_OB_wide_dpsi.col.nums <- grep(x = colnames(PSI_levels_timeseries_constitutive_OB_wide_with_na), pattern = "deltaPSI")
vector_PSI_levels_timeseries_timeseries_OB_wide_qpvalue.col.nums <- grep(x = colnames(PSI_levels_timeseries_constitutive_OB_wide_with_na), pattern = p_or_q_value)

# filtering for dPSI cutoff
PSI_levels_timeseries_constitutive_OB_wide_with_na <- PSI_levels_timeseries_constitutive_OB_wide_with_na[apply(PSI_levels_timeseries_constitutive_OB_wide_with_na[, vector_PSI_levels_timeseries_timeseries_OB_wide_dpsi.col.nums], 1, function(x){all(abs(x %>% as.numeric) < dPSI_cutoff)}) == TRUE, ]

# filtering for FDR/pvalue
PSI_levels_timeseries_constitutive_OB_wide_with_na <- PSI_levels_timeseries_constitutive_OB_wide_with_na[apply(PSI_levels_timeseries_constitutive_OB_wide_with_na[, vector_PSI_levels_timeseries_timeseries_OB_wide_qpvalue.col.nums], 1, function(x){all(x %>% as.numeric > qpvalue_cutoff)}) == TRUE, ]

# further subsetting into ud-only comparisons

##  OB #####

PSI_levels_timeseries_constitutive_OB_wide_with_na <- PSI_levels_timeseries_constitutive_OB_wide_with_na[, c("Gene", "AS_event_ID", "splicemode", "isoform_number", "isoform_ID", "contributing_junction_IDs", "chr", "start", "end", "strand", "matched_gene_names", "matched_ref_transcript_names", "matched_recon_transcript_names", "any_NMD", "any_first_exon", "any_last_exon", colnames(PSI_levels_timeseries_constitutive_OB_wide_with_na)[grep(x = colnames(PSI_levels_timeseries_constitutive_OB_wide_with_na), pattern = "(deltaPSI_BM_MSC_to_)(OB)(_[0-9]{1,2}d|_[0-9]{1,2}h|)(.)(BM_MSC_to_OB_ud)")])]

colnames(PSI_levels_timeseries_constitutive_OB_wide_with_na) <- gsub(x = colnames(PSI_levels_timeseries_constitutive_OB_wide_with_na), pattern = "(deltaPSI_BM_MSC_to_)(OB_)([0-9]{1,2}d|[0-9]{1,2}h)(.BM_MSC_to_OB_ud)", replacement = "\\3")

# remove extra na
OBseries_timepoints <- c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

PSI_levels_timeseries_constitutive_OB_wide_na.rows <- apply(PSI_levels_timeseries_constitutive_OB_wide_with_na[, OBseries_timepoints[2:length(OBseries_timepoints)]], 1, function(X) {all(is.na(X))}) %>% which(. == TRUE)

PSI_levels_timeseries_constitutive_OB_wide_with_na <- cbind(PSI_levels_timeseries_constitutive_OB_wide_with_na, MSC = 0)

PSI_levels_timeseries_constitutive_OB_wide_with_na <- PSI_levels_timeseries_constitutive_OB_wide_with_na[-PSI_levels_timeseries_constitutive_OB_wide_na.rows, ]

# reorder cols to match chronological order
PSI_levels_timeseries_constitutive_OB_wide_with_na <- dplyr::bind_cols(PSI_levels_timeseries_constitutive_OB_wide_with_na %>% dplyr::select(-OBseries_timepoints), PSI_levels_timeseries_constitutive_OB_wide_with_na %>% dplyr::select(OBseries_timepoints))

print(paste("There are", length(PSI_levels_timeseries_constitutive_OB_wide_with_na$AS_event_ID %>% unique), "unique CONSTITUTIVE junction structures with", p_or_q_value, "<", qpvalue_cutoff, " and dPSI cutoff of", dPSI_cutoff, "for OB series with missing values"))

write.table(x = PSI_levels_timeseries_constitutive_OB_wide_with_na, file = paste(results_directory_figures, "wide_table_of_", nrow(PSI_levels_timeseries_constitutive_OB_wide_with_na), "_constitutive_junctions_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# remove ALL na to produce the timeseries-ready table

PSI_levels_timeseries_constitutive_OB_wide_with_na_na.rows <- apply(PSI_levels_timeseries_constitutive_OB_wide_with_na[, OBseries_timepoints], 1, function(X) {any(is.na(X))}) %>% which(. == TRUE)

PSI_levels_timeseries_constitutive_OB_wide <- PSI_levels_timeseries_constitutive_OB_wide_with_na[-PSI_levels_timeseries_OB_wide_with_na_na.rows, ]

row.names(PSI_levels_timeseries_constitutive_OB_wide) <- NULL

print(paste("There are", length(PSI_levels_timeseries_constitutive_OB_wide$AS_event_ID %>% unique), "unique CONSTITUTIVE junction structures with", p_or_q_value, "<", qpvalue_cutoff, " and dPSI cutoff of", dPSI_cutoff, "for OB series with NO missing values (complete timeseries)"))

write.table(x = PSI_levels_timeseries_constitutive_OB_wide, file = paste(results_directory_figures, "wide_table_of_", length(PSI_levels_timeseries_constitutive_OB_wide$AS_event_ID %>% unique), "_constitutive_junctions_dPSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_dPSI_greaterthan_", dPSI_cutoff, "_no_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# DRAWING SOMS TO ANALYSE TIME SERIES DATA

## construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# OB series #####

som_5_by_5_OBseries_table  <- PSI_levels_timeseries_OB_wide[, OBseries_timepoints]

som_5_by_5_OBseries_table <- som_5_by_5_OBseries_table %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_OBseries <- som(som_5_by_5_OBseries_table, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries <- cbind(PSI_levels_timeseries_OB_wide[, c("Gene", "AS_event_ID", "splicemode", "isoform_ID")], som_5_by_5_OBseries_table, cluster = somdata_5_by_5_OBseries[["unit.classif"]])

```

### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("Gene", "AS_event_ID", "splicemode", "isoform_ID", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5


```

### THE GGPLOT

all the genes

```{r}

# OB series

ggplot(long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries), "isoforms' PSI values during OB diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# GENE ONTOLOGY

## anysig with na

use gene ontology to analyse all the genes which had at least one differential splicing event over all timepoint comparisons

### p value and FDR (q value) cutoff filtering

In this step: we will use the wide_table_of_all_splicemodes_with_na and filter it for isoforms with least one qvalue < 0.01 and dPSI > 0.15

```{r}

OBseries_qvalue_0.05_GO_genelist <- PSI_levels_timeseries_OB_wide_with_na$Gene %>% unique

numberofgenes_anysig_OBseries <- OBseries_qvalue_0.05_GO_genelist %>% length

numberofgenes_anysig_OBseries %>% paste(., "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation with FDR <", qpvalue_cutoff) %>% print

```

### running hyperGO in GOstats

#### preparation of GO catalog for the gene background

This gene background shall contain all ensembl protein coding, long noncoding and transcribed genes.

```{r}

# ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# # GOTERM
# polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "go_id", "namespace_1003"), mart = ensembl_mart) %>% .[.$namespace_1003 != "",]
# 
# polyA_RNAseq_GO_background[, "namespace_1003"] <- as.character(polyA_RNAseq_GO_background[, "namespace_1003"])
# 
# write.table(x = polyA_RNAseq_GO_background, file = paste(results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

## Create catDB instance (takes a while but needs to be done only once)
# note: you had to save the GO annotation file to disk in the previous steps above
catdb <- makeCATdb(myfile = paste(results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), lib = NULL, org = "", colno = c(2, 1, 3), idconv = NULL)

```

#### hypergeometric test for GO terms

```{r}

# OB series

OB_anysig_GOtest_MF <- GOHyperGAll(catdb = catdb, gocat = "MF", sample = OBseries_qvalue_0.05_GO_genelist, Nannot = 2) %>% GOHyperGAll_benjamini_correction

OB_anysig_GOtest_BP <- GOHyperGAll(catdb = catdb, gocat = "BP", sample = OBseries_qvalue_0.05_GO_genelist, Nannot = 2) %>% GOHyperGAll_benjamini_correction

OB_anysig_GOtest_CC <- GOHyperGAll(catdb = catdb, gocat = "CC", sample = OBseries_qvalue_0.05_GO_genelist, Nannot = 2) %>% GOHyperGAll_benjamini_correction

OB_anysig_GOtest_MF %>% head(n = 15L) %>% print
OB_anysig_GOtest_BP %>% head(n = 15L) %>% print
OB_anysig_GOtest_CC %>% head(n = 15L) %>% print

# filter out the top ten most significant GO terms for each node

OB_anysig_GOtest_MF_topten <- OB_anysig_GOtest_MF[order(OB_anysig_GOtest_MF$Padj, decreasing = FALSE), ] %>% head(n = 30)
OB_anysig_GOtest_BP_topten <- OB_anysig_GOtest_BP[order(OB_anysig_GOtest_BP$Padj, decreasing = FALSE), ] %>% head(n = 30)
OB_anysig_GOtest_CC_topten <- OB_anysig_GOtest_CC[order(OB_anysig_GOtest_CC$Padj, decreasing = FALSE), ] %>% head(n = 30)

# table with only the top ten most significant GO terms

OB_anysig_GOtest_all_topten <- bind_rows(OB_anysig_GOtest_MF_topten, OB_anysig_GOtest_BP_topten, OB_anysig_GOtest_CC_topten)

OB_anysig_GOtest_all_topten <- type_convert(OB_anysig_GOtest_all_topten)

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(OB_anysig_GOtest_all_topten, aes(x = reorder(Term, Padj), y = SampleMatch)) +
  geom_col(aes(fill = log(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(Ont ~ ., scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented GO terms for OB series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_OBseries, "genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 

# write the top 30 enrichment table
write.table(x = OB_anysig_GOtest_all_topten, file = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# write the top everything enrichment table
write.table(x = bind_rows(OB_anysig_GOtest_MF_topten, OB_anysig_GOtest_BP_topten, OB_anysig_GOtest_CC_topten %>% dplyr::arrange(desc(Padj))), file = paste(results_directory_figures, "Top inf significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Gene ontology of each SOM cluster

### preparation of separate data frames containing genes belonging to each cluster

at the end of this, we will get list_of_OB/OBseries_gene_tables_by_SOM_cluster which are lists containing 25 nested data frames

```{r}

# OB series #####

##  separating the wide SOMs table into a list by cluster

list_of_OBseries_gene_tables_by_SOM_cluster <- list()

for (clusternumber in 1:number_of_som_clusters)
  
{
  
  list_of_OBseries_gene_tables_by_SOM_cluster[[clusternumber]] <- wide_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::filter(cluster == clusternumber) %>% dplyr::select(Gene) %>% unique %>% lapply(as.character)
  
}


```

### GO enrichment

1. make a list of 25 nested data frames which are the results of GO term enrichment every cluster

2. sort by increasing adjusted P value

3. filter out the top 10 GO terms each cluster

4. append the cluster number to each data frame

5. Unlist(i.e. bind rows)

6. calculate the facet coordinates for GGPLOT

The result: One 5 x 5 GGPLOT of each GOTERM node(3) for OB and OBseries(2) = 6 plots altogether

```{r}

list_of_OBseries_gene_tables_by_SOM_cluster_flattened <- list_of_OBseries_gene_tables_by_SOM_cluster %>% flatten

names(list_of_OBseries_gene_tables_by_SOM_cluster_flattened) <- 1:number_of_som_clusters

# let's try to do all enrichment at once using purrr

list_of_combinations_of_som_genes_and_GOterms <- cross2(.x = list_of_OBseries_gene_tables_by_SOM_cluster_flattened, .y = list("MF", "BP", "CC"))

# note: each element will be [[1]]: gene set, [[2]]: GO term to query

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables <- purrr::map(.x = list_of_combinations_of_som_genes_and_GOterms, .f = ~GOHyperGAll(catdb = catdb, gocat = .x[[2]], Nannot = 2, sample = .x[[1]]) %>% GOHyperGAll_benjamini_correction)

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map2(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten, .y = 1:number_of_som_clusters %>% rep(., times = 3) %>% as.list, .f = ~cbind(.x, "cluster" = .y) %>% as_tibble)

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2 <- list(
  "MF" = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten[1:number_of_som_clusters] %>% purrr::reduce(bind_rows), 
  "BP" = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten[(number_of_som_clusters + 1):(number_of_som_clusters*2)] %>% purrr::reduce(bind_rows),
  "CC" = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten[((2*number_of_som_clusters) + 1):(number_of_som_clusters*3)] %>% purrr::reduce(bind_rows)) %>% purrr::map(~type_convert(.x))

# cheeky ggplot

purrr::map2(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented", .y, "GO terms for each cluster in OB series")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~write.table(x = .x, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Gene Ontology for the isoforms/genes with highest PSIs at every time point

Plan: 

1. for each OB/OB series, for each time point, filter separately for the isoforms with the top ... 10%? (depends on total no. of isoforms) PSI
2. Generate all 3 GO nodes for each timepoint
3. Append timepoint to their respective GO output tables
4. Bind rows for a total of three massive tables (one for each GO node)
5. GGPLOT

### creation of lists of NORMALISED(SCALED) PSI values of isoforms per time point

```{r}

# OB series ###

list_of_scaled_PSI_OBseries <- wide_table_of_final_SOM_summary_5_by_5_OBseries[, OBseries_timepoints] %>% as.list

list_of_scaled_PSI_OBseries <- purrr::map(.x = list_of_scaled_PSI_OBseries, .f = ~cbind(.x, Gene = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries[, "Gene"])) %>% cbind(., AS_event_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries[, "AS_event_ID"])) %>% cbind(., isoform_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries[, "isoform_ID"])) %>% cbind(splicemode = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries[, "splicemode"])))

```

### filtering for top 10% of isoforms with highest inclusion level

```{r}

high_scaledPSIcutoff <- 0.1

list_of_highest_PSI_isoforms_per_timepoint_OBseries <- purrr::map(.x = list_of_scaled_PSI_OBseries, .f = ~.x[order(.x[, 1], decreasing = TRUE), ])
list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries, .f = ~head(.x, n = floor(nrow(.x) * high_scaledPSIcutoff)))
list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID, .f = ~unique(.x[, "Gene"]))

# write geneset of each timepoint
purrr::map2(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered, .y = names(list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered), 
            .f = ~write.table(x = .x,
                             file = paste(results_directory_figures, "geneset_top10percent_highestPSI_timepointwise_OBseries_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, "_", .y, ".txt", sep = ""),
                             row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t"))

```

### filtering for top 10% of isoforms with LOWEST inclusion level

```{r}

low_scaledPSIcutoff <- 0.1

list_of_lowest_PSI_isoforms_per_timepoint_OBseries <- purrr::map(.x = list_of_scaled_PSI_OBseries, .f = ~.x[order(.x[, 1], decreasing = FALSE), ])
list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries, .f = ~head(.x, n = floor(nrow(.x) * low_scaledPSIcutoff)))
list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID, .f = ~unique(.x[, "Gene"]))

# write geneset of each timepoint
purrr::map2(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered, .y = names(list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered), 
            .f = ~write.table(x = .x,
                             file = paste(results_directory_figures, "geneset_top10percent_lowestPSI_timepointwise_OBseries_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, "_", .y, ".txt", sep = ""),
                             row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t"))

```

### GENE ONTOLOGY

```{r}

# OB series #####

# MF highestPSI

list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_MF_OBseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_MF_OBseries <- type_convert(wide_table_of_timepointwise_highestPSI_results_MF_OBseries)

# BP highestPSI

list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_BP_OBseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_BP_OBseries <- type_convert(wide_table_of_timepointwise_highestPSI_results_BP_OBseries)

# CC highestPSI

list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_CC_OBseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_CC_OBseries <- type_convert(wide_table_of_timepointwise_highestPSI_results_CC_OBseries)

# MF lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_MF_OBseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_MF_OBseries <- type_convert(wide_table_of_timepointwise_lowestPSI_results_MF_OBseries)

# BP lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_BP_OBseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_BP_OBseries <- type_convert(wide_table_of_timepointwise_lowestPSI_results_BP_OBseries)

# CC lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_CC_OBseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_CC_OBseries <- type_convert(wide_table_of_timepointwise_lowestPSI_results_CC_OBseries)


#  highestPSI

wide_tables_of_timepointwise_highestPSI_results <- c("wide_table_of_timepointwise_highestPSI_results_MF_OBseries", "wide_table_of_timepointwise_highestPSI_results_BP_OBseries", "wide_table_of_timepointwise_highestPSI_results_CC_OBseries")

# , "wide_table_of_timepointwise_highestPSI_results_MF_OBseries", "wide_table_of_timepointwise_highestPSI_results_BP_OBseries", "wide_table_of_timepointwise_highestPSI_results_CC_OBseries"

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_highestPSI_results[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_highestPSI_results[i], "_processed", sep = ""), value = temp)
  
}

# lowestPSI

wide_tables_of_timepointwise_lowestPSI_results <- c("wide_table_of_timepointwise_lowestPSI_results_MF_OBseries", "wide_table_of_timepointwise_lowestPSI_results_BP_OBseries", "wide_table_of_timepointwise_lowestPSI_results_CC_OBseries")

# , "wide_table_of_timepointwise_highestPSI_results_MF_OBseries", "wide_table_of_timepointwise_highestPSI_results_BP_OBseries", "wide_table_of_timepointwise_highestPSI_results_CC_OBseries"

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_lowestPSI_results[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_lowestPSI_results[i], "_processed", sep = ""), value = temp)
  
}

```

### GGPLOT

```{r}

# OB series ######

# MF highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_MF_OBseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_MF_OBseries_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_BP_OBseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_BP_OBseries_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_CC_OBseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_CC_OBseries_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# MF lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# protein family enrichment

goal: to conduct hypergeometric tests of overrepresentation for gene subsets in protein families

## generating the gene background for PFAM protein families

```{r}

# PROTEINFAMILY
polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "pfam"), mart = ensembl_mart) %>% .[.$pfam != "",]

# obtain description(definition, DE) for each PFAM ID

PFAM_all_descriptions <- as.data.frame(PFAMDE[mappedkeys(PFAMDE)]) %>% setNames(., c("pfam", "family_description"))

polyA_RNAseq_GO_background <- dplyr::left_join(polyA_RNAseq_GO_background, PFAM_all_descriptions, by = "pfam")

polyA_RNAseq_GO_background[, "family_description"] <- as.character(polyA_RNAseq_GO_background[, "family_description"])

write.table(x = polyA_RNAseq_GO_background, file = paste(results_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

# create list of gene UNIVERSE

reference_geneset <- polyA_RNAseq_GO_background$external_gene_name

# create list containing collections of genes under their according family descriptions

polyA_RNAseq_GO_background_2 <- polyA_RNAseq_GO_background

polyA_RNAseq_GO_background_2 <- polyA_RNAseq_GO_background_2[, names(polyA_RNAseq_GO_background_2) != "pfam"]

list_of_pfam_descriptions <- polyA_RNAseq_GO_background_2$family_description %>% unique %>% as.list

list_of_pfam_gene_family_categories <- purrr::map(.x = list_of_pfam_descriptions, .f = ~as.list(polyA_RNAseq_GO_background[polyA_RNAseq_GO_background$family_description == .x, "external_gene_name"]))

names(list_of_pfam_gene_family_categories) <- list_of_pfam_descriptions

list_of_pfam_gene_family_categories <- list_of_pfam_gene_family_categories %>% purrr::map(~unlist(.x))

```

## ENRICHMENT TEST

### anysig with na

hypergeometric test, filtering for top 30 overrepresented families
```{r}

# OB

# OB_anysig_family_enrichment <- enrichment(genes = OBseries_qvalue_0.05_GO_genelist, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction; rownames(OB_anysig_family_enrichment) <- NULL
# 
# OB_anysig_family_enrichment %>% head(n = 15L) %>% print

# table with only the top ten most significant enrichments

# OB_anysig_family_enrichment_topten <- OB_anysig_family_enrichment[order(OB_anysig_family_enrichment$padj, decreasing = FALSE), ] %>% head(n = 10)
# 
# OB_anysig_family_enrichment_topten <- type_convert(OB_anysig_family_enrichment_topten)

# OB

OB_anysig_family_enrichment <- enrichment(genes = OBseries_qvalue_0.05_GO_genelist, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], OBseries_qvalue_0.05_GO_genelist) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert; rownames(OB_anysig_family_enrichment) <- NULL

# OB_anysig_family_enrichment %>% head(n = 30L) %>% print

# table with only the top ten most significant enrichments

OB_anysig_family_enrichment_topten <- OB_anysig_family_enrichment[order(OB_anysig_family_enrichment$padj, decreasing = FALSE), ] %>% head(n = 30)

OB_anysig_family_enrichment_topten <- type_convert(OB_anysig_family_enrichment_topten)

```

bar graph of GO terms
```{r}

# OB series

ggplot(OB_anysig_family_enrichment_topten, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  # facet_grid(~ Ont, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for OB series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_OBseries, "genes")) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# write result of top 30
write.table(x = OB_anysig_family_enrichment_topten, file = paste(results_directory_figures, "Top 10 significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# write result of everything
write.table(x = OB_anysig_family_enrichment %>% dplyr::arrange(desc(padj)), file = paste(results_directory_figures, "Top inf significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### anytimepoint

#### anysig, highest PSI

hypergeometric test, filtering for top 10 overrepresented families
```{r}

# OB ###

list_of_highest_PSI_per_timepoint_familyenrichment_OBseries <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_highest_PSI_per_timepoint_familyenrichment_OBseries_topten <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_familyenrichment_OBseries, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_families_OBseries <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_familyenrichment_OBseries_topten, .f = bind_rows)

wide_table_of_timepointwise_highestPSI_families_OBseries <- type_convert(wide_table_of_timepointwise_highestPSI_families_OBseries)

wide_table_of_timepointwise_highestPSI_families_OBseries <- arrange(transform(wide_table_of_timepointwise_highestPSI_families_OBseries, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_families_OBseries$timepoint))), timepoint)

```

#### anysig, lowest PSI

hypergeometric test, filtering for top 10 overrepresented families
```{r}

# OB ###

list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries_topten <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_families_OBseries <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries_topten, .f = bind_rows)

wide_table_of_timepointwise_lowestPSI_families_OBseries <- type_convert(wide_table_of_timepointwise_lowestPSI_families_OBseries)

wide_table_of_timepointwise_lowestPSI_families_OBseries <- arrange(transform(wide_table_of_timepointwise_lowestPSI_families_OBseries, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_families_OBseries$timepoint))), timepoint)

```

bar graph of GO terms

```{r}

# OB series ######

# highest PSI

ggplot(wide_table_of_timepointwise_highestPSI_families_OBseries, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% highest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_families_OBseries, file = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# lowest PSI

ggplot(wide_table_of_timepointwise_lowestPSI_families_OBseries, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% lowest PSI isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_families_OBseries, file = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### family enrichment of each cluster

```{r}

# OB ###

list_of_familyenrichment_by_SOM_cluster_OBseries <- purrr::map(.x = list_of_OBseries_gene_tables_by_SOM_cluster_flattened, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_familyenrichment_by_SOM_cluster_OBseries) <- 1:number_of_som_clusters

list_of_familyenrichment_by_SOM_cluster_OBseries_topten <- purrr::map2(.x = list_of_familyenrichment_by_SOM_cluster_OBseries, .y = 1:number_of_som_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_familyenrichment_by_SOM_cluster_OBseries_topten <- purrr::reduce(.x = list_of_familyenrichment_by_SOM_cluster_OBseries_topten, .f = bind_rows) %>% type_convert %>% cbind(., cluster_minus_1 = .$cluster - 1) %>% cbind(., remainder_facet.x = .$cluster_minus_1 %% 5) %>% cbind(., quotient_facet.y = .$cluster_minus_1 %/% 5)


```

GGPLOT

```{r}

ggplot(wide_table_of_familyenrichment_by_SOM_cluster_OBseries_topten, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle("Top 10 significantly over-represented PFAM families for each cluster in OB series") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("PFAM family") +
  ylab("Number of genes enriched in PFAM family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = wide_table_of_familyenrichment_by_SOM_cluster_OBseries_topten, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# JUNCTION ONTOLOGY

## retrieve whole biomart domain annotations from server and save

```{r}

# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

```

```{r eval=FALSE, include=FALSE}

# query biomart
list_of_tibbles_biomart_domain_annotation <- future_map(.x = list_of_attributes_to_retrieve, .f = ~getBM(attributes = .x, mart = ensembl_mart) %>% as_tibble %>% na.omit, .progress = TRUE, .options = future_options(globals = c("getBM", "ensembl_mart")))

# write tables
future_map2(.x = list_of_tibbles_biomart_domain_annotation, .y = names(list_of_tibbles_biomart_domain_annotation), .f = ~write.table(.x, file = paste(shared_dir, "table_biomart_ENSP_to_", .y, ".txt", sep = ""), row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t"), .progress = TRUE, .options = future_options(globals = FALSE))

```

```{r}

# read tables
list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(shared_dir, "table_biomart_ENSP_to_", .x, ".txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

```

## retrieve whole biomart ENSP to uniprotkb entry ID mapping

```{r}

tibble_ENSP_to_uniprotkb <- biomaRt::getBM(attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
  type_convert %>% 
  as_tibble %>%
  na.omit

```

## import GTF and process it into a nice table containing only character and numeric types

```{r eval=FALSE, include=FALSE}

# IMPORT GTF ANNOTATION OF TRANSCRIPT/EXON/PROTEIN CODING REGIONS ETC...

library(rtracklayer)

tibble_ref_gtf_original <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(tibble_ref_gtf_original) <- c("chr", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/media/Ubuntu/sharedfolder/dbPTM_download/extract/allPTM_human.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/media/Ubuntu/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES
tibble_PTM_combined <- dplyr::bind_rows(tibble_dbPTM_allhuman_annotations, tibble_phosphositeplus_allhuman_phosphosites)

```

## transcript and domain analyses! :)

NEW METHOD - USING CONSTITUENT JUNCTIONS

```{r message=FALSE, warning=FALSE}

query_name <- "all_differential"

# all plausible differential junctions
## extract the contributing junctions for each AS_event_ID
tibble_constituent_junctions_for_query <- PSI_levels_timeseries_OB_wide_with_na %>% (function(input_table) {
  
  output_tibble <- input_table[, c("AS_event_ID", "splicemode", "contributing_junction_IDs", "chr", "start", "end", "strand")] %>% as_tibble %>% unique
  
  return(output_tibble)
  
} )

## list-ify
list_constituent_junctions_for_query <- tibble_constituent_junctions_for_query %>% (function(input_tibble) {
  
  output_list <- input_tibble %>% 
    dplyr::mutate_at(c("contributing_junction_IDs", "chr", "start", "end", "strand"), .funs = function(x) {x %>% strsplit(split = ";")} ) %>% 
    array_tree
  
  return(output_list)
  
} )

## for each element in list, nest by contributing_junction_IDs
list_constituent_junctions_for_query_sorted <- list_constituent_junctions_for_query %>% purrr::map(~list(
  
  "AS_event_ID" = .x$AS_event_ID,
  "splicemode" = .x$splicemode,
  "contributing_junctions" = .x[c("contributing_junction_IDs", "chr", "start", "end", "strand")] %>% as_tibble %>% array_tree %>% set_names(purrr::map(.x = ., .f = ~.x$contributing_junction_IDs) %>% unlist)
  
) )

## match contributing junctions to reference annotation
## NOTE: there will be contributing junctions which do not have any flanking exons. In those cases, they will be excluded from analysis and the total sample space should comprise of matched junctions only.
list_ref_entries_matched_to_constituent_junctions <- list_constituent_junctions_for_query_sorted %>% (function(input_list) {
  
  # WARNING!! FIX THIS IF NAMING THE FUNCTION!
  ref_tibble_with_first.last <<- tibble_ref_gtf
  ############################################
  
  # match to reference GTF. these wil be the important exon pairs.
  output_list <- future_map(.x = input_list, 
                            .f = ~purrr::splice(.x,
                                                
                                                # DEBUG ###
                                                # .x <- list_constituent_junctions_for_query_sorted[[1]]
                                                ###########
                                                
                                                "ref_matched_CDS_pairs" = list(.x$contributing_junctions %>% purrr::map(.f = ~extract_junction.flanking.CDS_JUM(.x, ref_tibble_with_first.last, match_consecutive = FALSE)) %>% purrr::discard(.x = ., .p = ~length(.x) == 0)),
                                                
                                                "ref_matched_exon_pairs" = list(.x$contributing_junctions %>% purrr::map(.f = ~extract_junction.flanking.exons_JUM(.x, ref_tibble_with_first.last, match_consecutive = FALSE)) %>% purrr::discard(.x = ., .p = ~length(.x) == 0))
                                                
                                                ) , 
                            .progress = TRUE, 
                            .options = future_options(globals = c("ref_tibble_with_first.last", "extract_junction.flanking.CDS_JUM", "extract_junction.flanking.exons_JUM"))) %>% 
    purrr::discard(.x = ., .p = ~length(.x$ref_matched_CDS_pairs) <= 1 & length(.x$ref_matched_exon_pairs) <= 1)
  
  return(output_list)
  
  } )

# CRYPTIC FUNCTION TO EXTRACT ALL DIFFERENTIAL COORDS FROM A LIST OF JUNCTIONS OF MATCHED TRANSCRIPTS ENTRY PAIRS

extract_diff_coord_from_entry_pairs <- function(list_of_junctions_of_transcripts_entry_pairs) {
  
  # DEBUG ###
  # list_of_junctions_of_transcripts_entry_pairs <- list_ref_entries_matched_to_constituent_junctions[[1]] %>% .$ref_matched_exon_pairs
  ###########
   
  # for each contributing junction, collapse all the matched reference entries by rbind then separate into left and right exons.
  # this will be done by taking the odd and then even row entries of the collapsed table.
  # NOTE: THIS IS ONLY POSSIBLE BECAUSE THE FUNCTION extract_junction.flanking.CDS_JUM() SORTED ENTRY PAIRS IN INCREASING START ORDER.
  
  # THEN check for overlapping left/right exons.
  # if there are no more than one distinct overlapping exons at the ends, then that is a constitutive end exon which SHOULD be removed.
  # if there are more than one distinct overlapping exons at the ends, then take the regions which do not appear in all overlapping end exons.
  
  # for junctions on the ends involving first/last exons, include ALL exon positions on the end. as well as all middle ones that do not overlap.
  
  # add LEFT or RIGHT exon in a column and collapse for each junction
  list_collapsed_tibbles_per_junction <- list_of_junctions_of_transcripts_entry_pairs %>% purrr::map_depth(.depth = 2, .f = ~add_column(.x, "left_or_right_exon" = c("left_exon", "right_exon"))) %>% purrr::map(~rbindlist(.x) %>% as_tibble %>% dplyr::distinct(start, end, .keep_all = TRUE))
  
  collapsed_tibble <- list_collapsed_tibbles_per_junction %>% rbindlist %>% as_tibble
  
  # take the highest and lowest exon entries and make unique versions
  tibble_left_exon_entries <- collapsed_tibble[collapsed_tibble$left_or_right_exon == "left_exon", ]
  tibble_left_exon_entries_unique <- tibble_left_exon_entries %>% dplyr::distinct(start, end, .keep_all = TRUE)
  
  tibble_right_exon_entries <- collapsed_tibble[collapsed_tibble$left_or_right_exon == "right_exon", ] 
  tibble_right_exon_entries_unique <- tibble_right_exon_entries %>% dplyr::distinct(start, end, .keep_all = TRUE)
  
  # DEAL WITH THE LEFT EXON ENTRIES
  leftmost.end_of_left.exon <- min(tibble_left_exon_entries_unique$end)
  number_of_start_coords_of_left_exon_overlapping <- length(which(tibble_left_exon_entries_unique$start <= leftmost.end_of_left.exon))
  
  # get each genomic coord or position of the overlapping left exons
  list_genomic_coords_of_all_left_exon_positions <- purrr::map2(.x = tibble_left_exon_entries$start, 
                                                               .y = tibble_left_exon_entries$end,
                                                               .f = ~.x:.y)
  
  # create tally, keep only the positions which are not all in common
  vector_genomic_coords_of_all_left_exon_positions <- list_genomic_coords_of_all_left_exon_positions %>% 
   unlist %>% 
   tibble::enframe(name = NULL, value = "genome_coord") %>%
   dplyr::group_by(genome_coord) %>% 
   dplyr::summarise("tally" = n()) %>%
   dplyr::filter(tally == 1 | tally < number_of_start_coords_of_left_exon_overlapping, .preserve = TRUE) %>% 
   .$genome_coord
  
  # LEFT-SIDE MIDDLE EXONS
  # black-list the overlapping left-side ends. 
  # require that "middle" exons must have start coord greater than the leftmost end of all left exons.
  tibble_left_exon_entries_middle.only <- tibble_left_exon_entries_unique %>% 
   dplyr::filter(start > leftmost.end_of_left.exon)
  
  # get each genomic coord or position of the middle left exons
  list_genomic_coords_of_all_left.middle_exon_positions <- purrr::map2(.x = tibble_left_exon_entries_middle.only$start, 
                                                               .y = tibble_left_exon_entries_middle.only$end,
                                                               .f = ~.x:.y)
  
  # create tally, keep only the positions which are not all in common
  vector_genomic_coords_of_all_left.middle_exon_positions <- list_genomic_coords_of_all_left.middle_exon_positions %>% 
   unlist %>% 
   tibble::enframe(name = NULL, value = "genome_coord") %>%
   dplyr::group_by(genome_coord) %>% 
   dplyr::summarise("tally" = n()) %>%
   dplyr::filter(tally == 1 | tally < nrow(tibble_left_exon_entries_middle.only), .preserve = TRUE) %>% 
   .$genome_coord
   
  # DEAL WITH THE RIGHT EXON ENTRIES
  rightmost.start_of_right.exon <- max(tibble_right_exon_entries_unique$start)
  number_of_end_coords_of_right_exon_overlapping <- length(which(tibble_right_exon_entries_unique$end >= rightmost.start_of_right.exon))
  
  # get each genomic coord or position of the overlapping left exons
  list_genomic_coords_of_all_right_exon_positions <- purrr::map2(.x = tibble_right_exon_entries$start, 
                                                                .y = tibble_right_exon_entries$end,
                                                                .f = ~.x:.y)
  
  # create tally, keep only the positions which are not all in common
  vector_genomic_coords_of_all_right_exon_positions <- list_genomic_coords_of_all_right_exon_positions %>% 
   unlist %>% 
   tibble::enframe(name = NULL, value = "genome_coord") %>%
   dplyr::group_by(genome_coord) %>% 
   dplyr::summarise("tally" = n()) %>%
   dplyr::filter(tally == 1 | tally < number_of_end_coords_of_right_exon_overlapping, .preserve = TRUE) %>% 
   .$genome_coord
  
  # RIGHT-SIDE MIDDLE EXONS
  # black-list the overlapping right-side ends. 
  # require that "middle" exons must have end coord smaller than the rightmost start of all left exons.
  tibble_right_exon_entries_middle.only <- tibble_right_exon_entries_unique %>% 
   dplyr::filter(end < rightmost.start_of_right.exon)
  
  # get each genomic coord or position of the middle right exons
  list_genomic_coords_of_all_right.middle_exon_positions <- purrr::map2(.x = tibble_right_exon_entries_middle.only$start, 
                                                               .y = tibble_right_exon_entries_middle.only$end,
                                                               .f = ~.x:.y)
  
  # create tally, keep only the positions which are not all in common
  vector_genomic_coords_of_all_right.middle_exon_positions <- list_genomic_coords_of_all_right.middle_exon_positions %>% 
   unlist %>% 
   tibble::enframe(name = NULL, value = "genome_coord") %>%
   dplyr::group_by(genome_coord) %>% 
   dplyr::summarise("tally" = n()) %>%
   dplyr::filter(tally == 1 | tally < nrow(tibble_right_exon_entries_middle.only), .preserve = TRUE) %>% 
   .$genome_coord
   
  # MIX ALL 4 VECTORS OF COORDS TOGETHER
  vector_genomic_coords_all_differential <- c(vector_genomic_coords_of_all_left_exon_positions,
                                              vector_genomic_coords_of_all_left.middle_exon_positions,
                                              vector_genomic_coords_of_all_right_exon_positions,
                                              vector_genomic_coords_of_all_right.middle_exon_positions) %>% unique
  
  return(vector_genomic_coords_all_differential)
  
  }

# GENERATE GENOME-RELATIVE COORDS FOR EVERY DIFFERENTIAL POSITION.
## remove any overlapping regions on the left and right ends of the AS structure.
## we do this because analysing each junction separately will result in constitutive flanking exons to be falsely called as differential (e.g. in the case of cassette exons)

# differential CDS positions for domain/PTM analyses, differential exon positions for transcript feature analysis.
list_genome_relative_differential_coords <- future_map(.x = list_ref_entries_matched_to_constituent_junctions, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_ref_entries_matched_to_constituent_junctions[[1]]
  ###########
  
  ref_gtf_table <<- tibble_ref_gtf
  input_list <- .x
  
  output_list <- purrr::splice(
  
    input_list,
    
    "vector_genomic_coords_of_all_differential_exon_positions" = extract_diff_coord_from_entry_pairs(input_list$ref_matched_exon_pairs),
    
    "vector_genomic_coords_of_all_differential_CDS_positions" = extract_diff_coord_from_entry_pairs(input_list$ref_matched_CDS_pairs),
    
    "genomic_coords_of_all_CDS_positions_per_protein_id" = list(input_list$ref_matched_CDS_pairs %>% (function(x) {
      
      # DEBUG ###
      # x <- input_list[["ref_matched_CDS_pairs"]]
      ###########
      
      collapsed_tibble <- x %>% flatten %>% rbindlist %>% as_tibble
      
      list_genome_relative_coords_of_CDS_positions_per_protein_id <- collapsed_tibble$protein_id %>% na.omit %>% unique %>% array_tree %>% 
        purrr::map(.x = ., .f = ~ref_gtf_table[ref_gtf_table$protein_id == .x & ref_gtf_table$type == "CDS", ] %>% 
        .[apply(X = ., MARGIN = 1, FUN = function(X) {all(is.na(X)) == FALSE}), ]) %>% 
        purrr::map(~sort_tibble_according_to_strand(.x))
      
      names(list_genome_relative_coords_of_CDS_positions_per_protein_id) <- collapsed_tibble$protein_id %>% na.omit %>% unique
      
      return(list_genome_relative_coords_of_CDS_positions_per_protein_id)
      
    } ) ),
    
    "vector_matched_transcript_ids" = list(input_list$ref_matched_exon_pairs %>% (function(.x) {
      
      # DEBUG ###
      # .x <- input_list$ref_matched_exon_pairs
      ###########
      
      collapsed_tibble <- .x %>% flatten %>% rbindlist %>% as_tibble
      
      vector_matched_transcript_ids <- collapsed_tibble$transcript_id %>% na.omit %>% unique
      
      return(vector_matched_transcript_ids)
      
    } ) )
    
    )
  
  return(output_list)
    
    }, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "sort_tibble_according_to_strand", "as_tibble", "tibble::enframe", "extract_diff_coord_from_entry_pairs")) ) %>%
    
    # drop AS junction structures that don't have any differential regions.
    purrr::discard(.x = ., .p = ~length(.x$vector_genomic_coords_of_all_differential_exon_positions) == 0 & length(.x$vector_genomic_coords_of_all_differential_CDS_positions) == 0)

# MATCH DIFFERENTIAL GENOME-RELATIVE COORDS TO EACH CDS REGION CORRESPONDING TO PROTEIN ID
# THEN EXTRACT THE PROTEIN-RELATIVE COORDS
list_transcript_and_protein_relative_differential_coords <- future_imap(.x = list_genome_relative_differential_coords, .f = function(.x, .y) {
  
  # message("now processing junction number: ", .y)
  
  # DEBUG ###
  # .x <- list_genome_relative_differential_coords[[2]]
  ###########
  
  input_list <- .x
  
  output_list <- purrr::splice(
    
    input_list,
    
    "CDS_relative_differential_coords" = list(purrr::map(.x = input_list$genomic_coords_of_all_CDS_positions_per_protein_id, 
                                              .f = ~which(.x %in% input_list$vector_genomic_coords_of_all_differential_CDS_positions) %>% sort(decreasing = FALSE)
                                              ) %>% 
                                   purrr::discard(.p = ~length(.x) == 0)
                                 )
    ) %>%
    
    # protein-relative coords are simply the ceiling of a third of the transcript-relative coords
    purrr::splice(
      
      "protein_relative_differential_coords" = list(.$CDS_relative_differential_coords %>% 
                                         purrr::map(~ceiling(.x / 3) %>% unlist %>% unique))
      
    )
    
    }, .progress = TRUE, .options = future_options(globals = FALSE))

# MATCH THE DIFFERENTIAL TRANSCRIPT-RELATIVE COORDS TO THE ENSEMBL GTF
# MATCH THE DIFFERENTIAL PROTEIN-RELATIVE COORDS TO THE FETCHED BIOMART LIST AS WELL AS THE PTMS
list_matched_annotation <- future_map(.x = list_transcript_and_protein_relative_differential_coords, .f = function(.x) {
  
  # WARNING!! FIX THIS WHEN NAMING THE FUNCTION!
  # list_of_tibbles_biomart_domain_annotation <<- list_of_tibbles_biomart_domain_annotation
  
  # tibble_ENSP_to_uniprotkb <<- tibble_ENSP_to_uniprotkb
  # tibble_PTM_combined <<- tibble_PTM_combined
  # tibble_ref_gtf_original <<- tibble_ref_gtf_original
  ############################################
  
  # DEBUG ###
  # .x <- list_transcript_and_protein_relative_differential_coords[[74]]
  ###########
  
  input_list <- .x
  
  output_list <- purrr::splice(
    
    input_list,
    
    "transcript_features" = purrr::map(.x = input_list$vector_matched_transcript_ids, .f = function(.x) {
      
      # subset the reference GTF by transcript_id
      tibble_ref_gtf_subset_by_transcript_id <- tibble_ref_gtf_original[tibble_ref_gtf_original$transcript_id == .x, ] %>% .[-which(is.na(.$chr)), ]
      
      # test for which differential positions lie between a feature
      row.indices_of_overlaps_with_differential_positions <- which(purrr::map2(.x = tibble_ref_gtf_subset_by_transcript_id$start, 
                           .y = tibble_ref_gtf_subset_by_transcript_id$end, 
                           .f = ~any(.x < input_list$vector_genomic_coords_of_all_differential_exon_positions &
                                       .y > input_list$vector_genomic_coords_of_all_differential_exon_positions)) %>% unlist)
      
      # extract matched GTF entries
      matched_GTF_entries <- tibble_ref_gtf_subset_by_transcript_id[row.indices_of_overlaps_with_differential_positions, ]
      
      return(matched_GTF_entries)
      
    } ) %>% 
      # rbind and spit out unique transcript feature types.
      rbindlist %>% .[, c("type", "transcript_biotype")] %>% unlist %>% unique,
    
    "biomart_annotations" = list(purrr::map2(.x = input_list$CDS_relative_differential_coords, .y = names(input_list$CDS_relative_differential_coords), .f = function(.x, .y) {
      
      # DEBUG ###
      # .x <- input_list$CDS_relative_differential_coords %>% .[[1]]
      # .y <- names(input_list$CDS_relative_differential_coords) %>% .[1]
      ###########
      
      CDS.relative.coords <- .x
      protein.id <- .y
      
      # find domains which overlapped with the differential positions.
      list_matched_biomart_annotations <- purrr::map2(.x = list_of_tibbles_biomart_domain_annotation, 
                                                      .y = names(list_of_tibbles_biomart_domain_annotation),
                                                      .f = function(.x, .y) {
                                                        
                                                        # DEBUG ###
                                                        # .x <- list_of_tibbles_biomart_domain_annotation[[2]]
                                                        ###########
                                                        
                                                        tibble_domain_subset <- .x[.x$ensembl_peptide_id == protein.id, ]
                                                        
                                                        if (nrow(tibble_domain_subset) != 0) {
                                                          
                                                          # test matched_domain_entriesfor which differential positions lie between a domain
                                                          
                                                          row.indices_of_overlaps_with_differential_positions <- which(purrr::map2(
                                                            .x = tibble_domain_subset$start, 
                                                            .y = tibble_domain_subset$end, 
                                                            .f = ~any(.x < CDS.relative.coords &
                                                                        .y > CDS.relative.coords)) %>% unlist)
                                                          
                                                          # extract matched GTF entries
                                                          tibble_matched_domain_entries <- tibble_domain_subset[row.indices_of_overlaps_with_differential_positions, ]
                                                          
                                                          } else if (nrow(tibble_domain_subset) == 0) {
                                                            
                                                            tibble_matched_domain_entries <- tibble_domain_subset
                                                            
                                                            }
                                                        
                                                        # rename the columns back to being domain-type specific
                                                        
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "start", replacement = paste(.y, "_", "start", sep = ""))
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "end", replacement = paste(.y, "_", "end", sep = ""))
                                                        
                                                        return(tibble_matched_domain_entries)
                                                        
                                                        } )
      
      # reduce into tibble by full join
      tibble_matched_biomart_annotations <- list_matched_biomart_annotations %>% purrr::reduce(dplyr::full_join)
      
      return(tibble_matched_biomart_annotations)
      
      } ) %>% rbindlist %>% as_tibble ),
    
    "PTMs" =  list(
      
      purrr::map2(.x = input_list$CDS_relative_differential_coords, .y = names(input_list$CDS_relative_differential_coords), .f = function(.x, .y) {
        
      # DEBUG ###
      # .x <- input_list$CDS_relative_differential_coords %>% .[[6]]
      # .y <- names(input_list$CDS_relative_differential_coords) %>% .[6]
      ###########
        
      tibble_uniprotkb_entries_from_ENSP <- tibble_ENSP_to_uniprotkb[tibble_ENSP_to_uniprotkb$ensembl_peptide_id == .y, ]
      
      tibble_combined_PTM_matching_entries <- tibble_uniprotkb_entries_from_ENSP %>% dplyr::left_join(., tibble_PTM_combined, by = "uniprotkb_entry") %>%
        
        .[.$modified_residue_position %in% .x, ]
      
      return(tibble_combined_PTM_matching_entries)
        
      } ) %>% rbindlist %>% as_tibble
      
    )
    
  )
    
}, .progress = TRUE, .options = future_options(globals = c("rbindlist", "list_of_tibbles_biomart_domain_annotation", "tibble_ENSP_to_uniprotkb", "tibble_PTM_combined", "tibble_ref_gtf_original", "as_tibble")))

# TIDY AND WRAP UP ALL THE ANNOTATIONS.
# prepare for export
list_tidied_annotation <- list_matched_annotation %>% 
  future_map(.f = ~
               # collapse all the matched exon pair annotations into a single tibble
               modify_at(.x, .at = "ref_matched_CDS_pairs", .f = ~map2(.x = .x, .y = names(.x), .f = ~.x %>% rbindlist %>% add_column("junction_ID" = .y)) %>% rbindlist %>% as_tibble) %>% 
               modify_at(.x, .at = "ref_matched_exon_pairs", .f = ~map2(.x = .x, .y = names(.x), .f = ~.x %>% rbindlist %>% add_column("junction_ID" = .y)) %>% rbindlist %>% as_tibble) %>%
               # concatenate all bare vectors 
               modify_at(.x, .at = "vector_genomic_coords_of_all_differential_exon_positions", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = "vector_genomic_coords_of_all_differential_CDS_positions", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = "vector_matched_transcript_ids", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = "transcript_features", .f = ~.x %>% paste(collapse = ",")), .progress = TRUE, .options = future_options(globals = c("rbindlist", "as_tibble")))

# extract the transcript features and tibblise 
tibble_final_transcript_feature_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("AS_event_ID", "splicemode", "vector_matched_transcript_ids", "transcript_features")] %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble %>%
  setNames(c("AS_event_ID", "splicemode", "transcript_ids_with_annotation", "transcript_features"))
# write table
write.table(x = tibble_final_transcript_feature_annotation, file = paste(results_dir, "table_junction_ontology_matched_transcript_features_", query_name, ".txt", sep = ""))

# extract the biomart results and tibblise 
tibble_final_biomart_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("AS_event_ID", "splicemode", "biomart_annotations")] ) %>%
  purrr::discard(.p = ~.x$biomart_annotations %>% nrow == 0) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "biomart_annotations", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble
# write table
write.table(x = tibble_final_biomart_annotation, file = paste(results_dir, "table_junction_ontology_matched_biomart_domains_", query_name, ".txt", sep = ""))

# extract the PTM results and tibblise 
tibble_final_PTM_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("AS_event_ID", "splicemode", "PTMs")] ) %>%
  purrr::discard(.p = ~.x$PTMs %>% nrow == 0) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "PTMs", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble
# write table
write.table(x = tibble_final_PTM_annotation, file = paste(results_dir, "table_junction_ontology_matched_PTMs_", query_name, ".txt", sep = ""))

# extract the other supporting information and tibblise
tibble_final_annotation_supp <- list_tidied_annotation %>% 
  purrr::map(~.x[c("AS_event_ID", "splicemode", "vector_genomic_coords_of_all_differential_exon_positions", "vector_genomic_coords_of_all_differential_CDS_positions", "vector_matched_transcript_ids", "protein_relative_differential_coords")]) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "protein_relative_differential_coords", .f = ~.x %>% purrr::map(~paste(.x, collapse = ",")) %>% as_tibble %>% t %>% as_tibble(rownames = "ensembl_peptide_id") %>% setNames(c("ensembl_peptide_id", "protein_relative_differential_coords"))) %>% flatten %>% as_tibble) %>%
  purrr::discard(.p = ~.x %>% nrow == 0) %>% rbindlist %>% as_tibble
# write table
write.table(x = tibble_final_annotation_supp, file = paste(results_dir, "table_junction_ontology_supporting_info_", query_name, ".txt", sep = ""))
  
```

## stats summary of junction ontology

```{r}

# transcript-level
message("total number of unique differential LSVs with any sort of transcript-level annotation: ", tibble_final_transcript_feature_annotation$AS_event_ID %>% length)

message("percent of differential regions matched to protein coding transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "protein_coding") %>% length/(tibble_final_transcript_feature_annotation$AS_event_ID %>% length))
message("percent of differential regions matched to an lncRNA transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "lncRNA") %>% length/(tibble_final_transcript_feature_annotation$AS_event_ID %>% length))
message("percent of differential regions matched to a miRNA transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "miRNA") %>% length/(tibble_final_transcript_feature_annotation$AS_event_ID %>% length))

message("percent of differential regions matched to a 3' UTR region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "three_prime_utr") %>% length/(tibble_final_transcript_feature_annotation$AS_event_ID %>% length))
message("percent of differential regions matched to a 5' UTR region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "five_prime_utr") %>% length/(tibble_final_transcript_feature_annotation$AS_event_ID %>% length))
message("percent of differential regions matched to a CDS region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "CDS") %>% length/(tibble_final_transcript_feature_annotation$AS_event_ID %>% length))

# PROTEIN-LEVEL
vector_unique_interpro_ids <- tibble_final_biomart_annotation$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_final_biomart_annotation %>% dplyr::group_by(AS_event_ID) %>% 
  dplyr::summarise(overlaps_interpro_domain = all(is.na(interpro)) == FALSE,
                   unique_interpro_ids = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   overlaps_LCR = all(is.na(seg_start)) == FALSE,
                   overlaps_disordered_region = all(is.na(mobidblite)) == FALSE,
                   overlaps_ncoils = all(is.na(ncoils_start)) == FALSE,
                   overlaps_signalp = all(is.na(signalp_start)) == FALSE,
                   overlaps_tmhmm = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort

# create tally of each unique instance of interpro ID per AS_event_ID
tibble_interpro_id_tally_per_ASeventID <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% .[order(.$tally), ] %>% dplyr::arrange(desc(tally))
# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- getBM(filters = "interpro", values = tibble_interpro_id_tally_per_ASeventID$interpro_id, attributes = c("interpro", "interpro_description"), mart = ensembl_mart) %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble join
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
# plot
ggplot(tibble_interpro_id_tally_per_ASeventID %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "dodgerblue2") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of differential junctions", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", nrow(tibble_protein_level_summary_count), "LSVs")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "tally_overlapping_interpro_domains_differential_junctions_", dPSI_cutoff,  "_", p_or_q_value, qpvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_junctions_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "tally_overlapping_interpro_domains_differential_junctions_", dPSI_cutoff,  "_", p_or_q_value, qpvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_junctions_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_ASeventID, file = paste(results_directory_figures, "tally_overlapping_interpro_domains_differential_junctions_", dPSI_cutoff,  "_", p_or_q_value, qpvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_junctions_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique LSVs with any sort of protein-level annotation: ", tibble_final_biomart_annotation$AS_event_ID %>% unique %>% length, " (", tibble_final_biomart_annotation$AS_event_ID %>% unique %>% length *100/nrow(tibble_final_transcript_feature_annotation), "% of those which have any transcript annotation)")

message("total percent of unique LSVs overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique LSVs overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique LSVs overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique LSVs overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique LSVs overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique LSVs overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

```

# REPEAT OF ANAYSES WITH PLAUSIBLE AS EVENTS ONLY

## filtering out all the implausible AS events

```{r}

# function to fetch maximum AA length of each protein coding gene. AS regions cant be longer than this. very difficult to filter. in my experience, most exons are at most 200 nt but ok
filtering_chr_strand_start_end_tibble_for_plausible_AS_events <- function(tibble_chr_strand_start_end) {
  
a <- getBM(filters = "external_gene_name", values = tibble_chr_strand_start_end$Gene, attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart)
b <- a %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length))
colnames(b) <- c("Gene", "transcript_length")
c <- dplyr::left_join(tibble_chr_strand_start_end, b, by = "Gene")
d <- c[-which(c$width >= c$transcript_length), ]
# retained introns and entire composite structures can be long. the other 4 have no excuse. the longest exon known in existence is 11555 bp long.
e <- d[-which(d$width > 11555 & (d$splicemode == "A3SS_events" | d$splicemode == "A5SS_events" | d$splicemode == "cassette_exon_events" | d$splicemode == "MXE_events")), ]
# e contains the final list of isoforms which have plausible AS length.
print(paste(nrow(e), "unique genes with plausible AS length after filtering"))

return(e)
  
}

## END filtering_chr_strand_start_end_tibble_for_plausible_AS_events

```

## filter for plausible AS events only, constitutive

```{r}

# filter for plausible anysig table

all_filtered_isoforms <- PSI_levels_timeseries_constitutive_OB_wide_with_na %>% as_tibble %>% mutate_if(is.factor, as.character)

all_filtered_isoforms_chr_strand_start_end <- all_filtered_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

all_filtered_isoforms_chr_strand_start_end_AS_plausible <- all_filtered_isoforms_chr_strand_start_end %>% filtering_chr_strand_start_end_tibble_for_plausible_AS_events

wide_table_of_all_splicemodes_constitutive_with_na_OBseries_filtered_qvalue_0.05_AS_plausible <- dplyr::semi_join(PSI_levels_timeseries_constitutive_OB_wide_with_na, all_filtered_isoforms_chr_strand_start_end_AS_plausible, by = "Gene")

numberofgenes_constitutive_anysig_OBseries_AS_plausible <- wide_table_of_all_splicemodes_constitutive_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique %>% length

print(paste("There are", numberofgenes_constitutive_anysig_OBseries_AS_plausible, "genes with constitutive junctions anysig with na with plausible AS length"))

```

## filter for plausible AS events only, differential

```{r}

# filter for plausible anysig table

all_filtered_isoforms <- PSI_levels_timeseries_OB_wide_with_na %>% as_tibble %>% mutate_if(is.factor, as.character)

all_filtered_isoforms_chr_strand_start_end <- all_filtered_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

all_filtered_isoforms_chr_strand_start_end_AS_plausible <- all_filtered_isoforms_chr_strand_start_end %>% filtering_chr_strand_start_end_tibble_for_plausible_AS_events

wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible <- dplyr::semi_join(PSI_levels_timeseries_OB_wide_with_na, all_filtered_isoforms_chr_strand_start_end_AS_plausible, by = "Gene")

numberofgenes_anysig_OBseries_AS_plausible <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique %>% length

print(paste("There are", numberofgenes_anysig_OBseries_AS_plausible, "genes anysig with na with plausible AS length"))

```

## repeat GO analysis with na

preprocessing 

```{r}

# GO analysis, OB series

OB_anysig_GOtest_MF_AS_plausible <- GOHyperGAll(catdb = catdb, gocat = "MF", sample = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, Nannot = 2) %>% GOHyperGAll_benjamini_correction

OB_anysig_GOtest_BP_AS_plausible <- GOHyperGAll(catdb = catdb, gocat = "BP", sample = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, Nannot = 2) %>% GOHyperGAll_benjamini_correction

OB_anysig_GOtest_CC_AS_plausible <- GOHyperGAll(catdb = catdb, gocat = "CC", sample = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, Nannot = 2) %>% GOHyperGAll_benjamini_correction

OB_anysig_GOtest_MF_AS_plausible %>% head(n = 15L) %>% print
OB_anysig_GOtest_BP_AS_plausible %>% head(n = 15L) %>% print
OB_anysig_GOtest_CC_AS_plausible %>% head(n = 15L) %>% print

# filter out the top ten most significant GO terms for each node

OB_anysig_GOtest_MF_topten_AS_plausible <- OB_anysig_GOtest_MF_AS_plausible[order(OB_anysig_GOtest_MF_AS_plausible$Padj, decreasing = FALSE), ] %>% head(n = 30)
OB_anysig_GOtest_BP_topten_AS_plausible <- OB_anysig_GOtest_BP_AS_plausible[order(OB_anysig_GOtest_BP_AS_plausible$Padj, decreasing = FALSE), ] %>% head(n = 30)
OB_anysig_GOtest_CC_topten_AS_plausible <- OB_anysig_GOtest_CC_AS_plausible[order(OB_anysig_GOtest_CC_AS_plausible$Padj, decreasing = FALSE), ] %>% head(n = 30)

# table with only the top ten most significant GO terms

OB_anysig_GOtest_all_topten_AS_plausible <- bind_rows(OB_anysig_GOtest_MF_topten_AS_plausible, OB_anysig_GOtest_BP_topten_AS_plausible, OB_anysig_GOtest_CC_topten_AS_plausible)

OB_anysig_GOtest_all_topten_AS_plausible <- type_convert(OB_anysig_GOtest_all_topten_AS_plausible)

```

GGPLOT

```{r}

# OB series

ggplot(OB_anysig_GOtest_all_topten_AS_plausible, aes(x = reorder(Term, Padj), y = SampleMatch)) +
  geom_col(aes(fill = log(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(Ont ~ ., scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented GO terms for OB series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_OBseries_AS_plausible, " PLAUSIBLE genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries_AS_plausible, "_genes_anysig_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries_AS_plausible, "_genes_anysig_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 


write.table(x = OB_anysig_GOtest_all_topten_AS_plausible, file = paste(results_directory_figures, "Top 10 significantly over-represented GO terms for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries_AS_plausible, "_genes_anysig_with_na_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## repeat family enrichment using anysig with na

preprocessing 

```{r}

OB_anysig_family_enrichment_AS_plausible <- enrichment(genes = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert

rownames(OB_anysig_family_enrichment_AS_plausible) <- NULL

# table with only the top ten most significant enrichments

OB_anysig_family_enrichment_topten_AS_plausible <- OB_anysig_family_enrichment_AS_plausible[order(OB_anysig_family_enrichment_AS_plausible$padj, decreasing = FALSE), ] %>% head(n = 30)

OB_anysig_family_enrichment_topten_AS_plausible <- type_convert(OB_anysig_family_enrichment_topten_AS_plausible)

```

bar graph of GO terms

```{r}

# OB series

ggplot(OB_anysig_family_enrichment_topten_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  # facet_grid(~ Ont, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for OB series for dPSI cutoff of", dPSI_cutoff, "and any sig", p_or_q_value, qpvalue_cutoff, "encompassing", numberofgenes_anysig_OBseries_AS_plausible, "PLAUSIBLE genes")) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries_AS_plausible, "_genes_anysig_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Top 10 significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries_AS_plausible, "_genes_anysig_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = OB_anysig_family_enrichment_topten_AS_plausible, file = paste(results_directory_figures, "Top 10 significantly over-represented families for OB series dPSI_", dPSI_cutoff,  "_any", p_or_q_value, qpvalue_cutoff, "_", numberofgenes_anysig_OBseries_AS_plausible, "_genes_anysig_with_na_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

## re-cluster the SOM using plausible genes only

### plausible filtering

```{r}

# generate table of plausible SOM isoforms that feeds into kohonen

all_SOM_isoforms <- PSI_levels_timeseries_OB_wide %>% as_tibble %>% mutate_if(is.factor, as.character)

all_SOM_isoforms_chr_strand_start_end <- all_SOM_isoforms %>% JUM_ASeventID_and_splicemode_to_chr_strand_start_end %>% unique

all_SOM_isoforms_chr_strand_start_end_AS_plausible <- all_SOM_isoforms_chr_strand_start_end %>% filtering_chr_strand_start_end_tibble_for_plausible_AS_events

PSI_levels_timeseries_OB_wide_AS_plausible <- dplyr::semi_join(PSI_levels_timeseries_OB_wide, all_SOM_isoforms_chr_strand_start_end_AS_plausible, by = "Gene")

```

### re-execution of kohonen

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# OB_xdim <- 5
# OB_ydim <- 5

# OB series #####

som_5_by_5_OBseries_table_AS_plausible  <- PSI_levels_timeseries_OB_wide_AS_plausible[, c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d")]

som_5_by_5_OBseries_table_AS_plausible <- som_5_by_5_OBseries_table_AS_plausible %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_OBseries_AS_plausible <- som(som_5_by_5_OBseries_table_AS_plausible, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible <- cbind(PSI_levels_timeseries_OB_wide_AS_plausible[, c("Gene", "AS_event_ID", "splicemode", "isoform_ID")], som_5_by_5_OBseries_table_AS_plausible, cluster = somdata_5_by_5_OBseries_AS_plausible[["unit.classif"]])

```

### convert the som table to a long form interprable by ggplot

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, id.vars = c("Gene", "AS_event_ID", "splicemode", "isoform_ID", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$cluster_minus_1 %/% 5

```

### ggplot of SOM

```{r}

ggplot(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible), "PLAUSIBLE isoforms' PSI values during OB diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

kinases only

```{r}

vector_protein_kinases <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "protein kinase activity"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID), "PLAUSIBLE KINASE isoforms' PSI values during OB diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_kinases.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_kinases.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_kinases.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

speckles only

```{r}

vector_nuclear_speck_proteins <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "nuclear speck"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_nuclear_speck_proteins, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "PLAUSIBLE nuclear speck isoforms' PSI values during OB diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_nuclear_speck_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_nuclear_speck_proteins.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_nuclear_speck_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_nuclear_speck_proteins.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_protein_kinases, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_nuclear_speck_proteins.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

transcription factor complex/interactors only

```{r}

vector_transcription_factor_complex_proteins <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "transcription factor complex"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "PLAUSIBLE transcription factor complex isoforms' PSI values during OB diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_transcription_factor_complex_proteins.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_transcription_factor_complex_proteins.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene"), file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_transcription_factor_complex_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_transcription_factor_complex_proteins.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

chromatin remodellers only

```{r}

vector_chromatin_remodeling_proteins <- getBM(filters = c("biotype", "go_parent_name"), values = list("protein_coding", "chromatin remodeling"), attributes = "external_gene_name", mart = ensembl_mart) %>% setNames("Gene")

ggplot(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene"), aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "PLAUSIBLE chromatin remodellers isoforms' PSI values during OB diff (any", p_or_q_value, 
               " < ", qpvalue_cutoff, "any deltaPSI >", dPSI_cutoff, ")")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_chromatin_remodeling_proteins.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_chromatin_remodeling_proteins.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(dplyr::semi_join(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible, vector_chromatin_remodeling_proteins, by = "Gene") %>% .$isoform_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength_chromatin_remodeling_proteins.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## repeat cluster-wise enrichment

### GO term

preprocessing

```{r}

list_of_OBseries_gene_tables_by_SOM_cluster_AS_plausible <- list()

for (clusternumber in 1:number_of_som_clusters)
  
{
  
  list_of_OBseries_gene_tables_by_SOM_cluster_AS_plausible[[clusternumber]] <- wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible %>% dplyr::filter(cluster == clusternumber) %>% dplyr::select(Gene) %>% unique %>% lapply(as.character)
  
}

# OB series #####

list_of_OBseries_gene_tables_by_SOM_cluster_flattened_AS_plausible <- list_of_OBseries_gene_tables_by_SOM_cluster_AS_plausible %>% flatten

# let's try to do all enrichment at once using purrr

list_of_combinations_of_som_genes_and_GOterms_AS_plausible <- cross2(.x = list_of_OBseries_gene_tables_by_SOM_cluster_flattened_AS_plausible, .y = list("MF", "BP", "CC"))

# note: each element will be [[1]]: gene set, [[2]]: GO term to query

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible <- purrr::map(.x = list_of_combinations_of_som_genes_and_GOterms_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = .x[[2]], Nannot = 2, sample = .x[[1]]) %>% GOHyperGAll_benjamini_correction)

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten <- purrr::map(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten <- purrr::map2(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten, .y = 1:number_of_som_clusters %>% rep(., times = 3) %>% as.list, .f = ~cbind(.x, "cluster" = .y) %>% as_tibble)

list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2 <- list(
  "MF" = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten[1:number_of_som_clusters] %>% purrr::reduce(bind_rows), 
  "BP" = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten[(number_of_som_clusters + 1):(number_of_som_clusters*2)] %>% purrr::reduce(bind_rows),
  "CC" = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten[((2*number_of_som_clusters) + 1):(number_of_som_clusters*3)] %>% purrr::reduce(bind_rows)) %>% purrr::map(~type_convert(.x))

# cheeky ggplot

purrr::map2(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2, .y = names(list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2), .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented", .y, "GO terms for each cluster in OB series")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2, .y = names(list_of_OBseries_som_hyperGOresult_allGO_clusterwise_tables_AS_plausible_topten_2), .f = ~write.table(x = .x, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_", .y, "_GO_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### family enrichment

preprocessing

```{r}

list_of_familyenrichment_by_SOM_cluster_OBseries_AS_plausible <- purrr::map(.x = list_of_OBseries_gene_tables_by_SOM_cluster_flattened_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_familyenrichment_by_SOM_cluster_OBseries_AS_plausible) <- 1:number_of_som_clusters

list_of_familyenrichment_by_SOM_cluster_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_familyenrichment_by_SOM_cluster_OBseries_AS_plausible, .y = 1:number_of_som_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_familyenrichment_by_SOM_cluster_OBseries_topten_AS_plausible <- purrr::reduce(.x = list_of_familyenrichment_by_SOM_cluster_OBseries_topten_AS_plausible, .f = bind_rows) %>% type_convert %>% cbind(., cluster_minus_1 = .$cluster - 1) %>% cbind(., remainder_facet.x = .$cluster_minus_1 %% 5) %>% cbind(., quotient_facet.y = .$cluster_minus_1 %/% 5)


```

GGPLOT

```{r}

ggplot(wide_table_of_familyenrichment_by_SOM_cluster_OBseries_topten_AS_plausible, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle("Top 10 significantly over-represented PFAM families for each PLAUSIBLE cluster in OB series") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("PFAM family") +
  ylab("Number of genes enriched in PFAM family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = wide_table_of_familyenrichment_by_SOM_cluster_OBseries_topten_AS_plausible, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_families_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## repeat timepoint-wise enrichment

generate list with each element as a single time point of the SOM table

```{r}
# OB series ###

list_of_scaled_PSI_OBseries_AS_plausible <- wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, OBseries_timepoints] %>% as.list

list_of_scaled_PSI_OBseries_AS_plausible <- purrr::map(.x = list_of_scaled_PSI_OBseries_AS_plausible, .f = ~cbind(.x, Gene = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "Gene"])) %>% cbind(., AS_event_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "AS_event_ID"])) %>% cbind(., isoform_ID = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "isoform_ID"])) %>% cbind(splicemode = as.character(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible[, "splicemode"])))

```

filtering for top 10% of isoforms with highest inclusion level

```{r}

high_scaledPSIcutoff <- 0.1

list_of_highest_PSI_isoforms_per_timepoint_OBseries_AS_plausible <- purrr::map(.x = list_of_scaled_PSI_OBseries_AS_plausible, .f = ~.x[order(.x[, 1], decreasing = TRUE), ])
list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_AS_plausible, .f = ~head(.x, n = floor(nrow(.x) * high_scaledPSIcutoff)))
list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID_AS_plausible, .f = ~unique(.x[, "Gene"]))

```

filtering for top 10% of isoforms with LOWEST inclusion level

```{r}

low_scaledPSIcutoff <- 0.1

list_of_lowest_PSI_isoforms_per_timepoint_OBseries_AS_plausible <- purrr::map(.x = list_of_scaled_PSI_OBseries_AS_plausible, .f = ~.x[order(.x[, 1], decreasing = FALSE), ])
list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_AS_plausible, .f = ~head(.x, n = floor(nrow(.x) * low_scaledPSIcutoff)))
list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_with_isoformID_AS_plausible, .f = ~unique(.x[, "Gene"]))

```

### GENE ONTOLOGY and family enrichment

GO term processing

```{r}

# OB series #####

# MF highestPSI

list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_MF_OBseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_MF_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_results_MF_OBseries_AS_plausible)

# BP highestPSI

list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_BP_OBseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_BP_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_results_BP_OBseries_AS_plausible)

# CC highestPSI

list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible <- purrr::map(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible, .y = as.list(names(list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_results_CC_OBseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_highestPSI_results_CC_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_results_CC_OBseries_AS_plausible)

# MF lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "MF", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_MF_OBseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_AS_plausible)

# BP lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "BP", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_BP_OBseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_AS_plausible)

# CC lowestPSI

list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~GOHyperGAll(catdb = catdb, gocat = "CC", Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction)
list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_AS_plausible, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))
list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible, .y = as.list(names(list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible)), .f = ~cbind(.x, timepoint = .y)) 
# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_GOresult_CC_OBseries_topten_AS_plausible, .f = bind_rows)
wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_AS_plausible)

# reordering the "timepoint" factor to give correct facet order

#  highestPSI

wide_tables_of_timepointwise_highestPSI_results_AS_plausible <- c("wide_table_of_timepointwise_highestPSI_results_MF_OBseries_AS_plausible", "wide_table_of_timepointwise_highestPSI_results_BP_OBseries_AS_plausible", "wide_table_of_timepointwise_highestPSI_results_CC_OBseries_AS_plausible")

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_highestPSI_results_AS_plausible[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_highestPSI_results_AS_plausible[i], "_processed", sep = ""), value = temp)
  
}

# lowestPSI

wide_tables_of_timepointwise_lowestPSI_results_AS_plausible <- c("wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_AS_plausible", "wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_AS_plausible", "wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_AS_plausible")

# , "wide_table_of_timepointwise_highestPSI_results_MF_OBseries", "wide_table_of_timepointwise_highestPSI_results_BP_OBseries", "wide_table_of_timepointwise_highestPSI_results_CC_OBseries"

for (i in 1:3)
  
{
  
  temp <- get(wide_tables_of_timepointwise_lowestPSI_results_AS_plausible[[i]]) %>% type_convert
  
  # reordering the "timepoint" factor to give correct facet order
  
  temp <- arrange(transform(temp, timepoint = factor(timepoint, levels = unique(temp$timepoint))), timepoint)
  
  assign(x = paste(wide_tables_of_timepointwise_lowestPSI_results_AS_plausible[i], "_processed", sep = ""), value = temp)
  
}

```

family processing

```{r}

### highest PSI 

list_of_highest_PSI_per_timepoint_familyenrichment_OBseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_highest_PSI_per_timepoint_familyenrichment_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_familyenrichment_OBseries_AS_plausible, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_familyenrichment_OBseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible)

wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible$timepoint))), timepoint)

### lowest PSI

list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries_AS_plausible, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_familyenrichment_OBseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible)

wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible$timepoint))), timepoint)

```

### GGPLOT

```{r}

# GO enrichment ######

# MF highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_MF_OBseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_MF_OBseries_AS_plausible_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_BP_OBseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_BP_OBseries_AS_plausible_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC highestPSI

ggplot(wide_table_of_timepointwise_highestPSI_results_CC_OBseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_results_CC_OBseries_AS_plausible_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# MF lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented MF GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_MF_OBseries_AS_plausible_processed, file = paste(results_directory_figures, "MF_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# BP lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented BP GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_BP_OBseries_AS_plausible_processed, file = paste(results_directory_figures, "BP_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# CC lowestPSI

ggplot(wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_AS_plausible_processed, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented CC GO terms for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_results_CC_OBseries_AS_plausible_processed, file = paste(results_directory_figures, "CC_GOterms_top10_", high_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# family enrichment ######

# highest PSI

ggplot(wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_families_OBseries_AS_plausible, file = paste(results_directory_figures, "Enrichedfamilies_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# lowest PSI

ggplot(wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented families for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Family description (PFAM)") +
  ylab("Number of genes captured in family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_families_OBseries_AS_plausible, file = paste(results_directory_figures, "Enrichedfamilies_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# ENRICHMENT OF SPLICING FACTORS - didnt work

## Generate table of all the mRNA sequences of all annotated transcripts

- mRNA sequences: UNSPLICED, for,
- Genes: ANYSIG

```{r eval=FALSE, include=FALSE}

anysig_all_mrna_seqs <- getBM(filters = "external_gene_name", values = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene, attributes = c("external_gene_name", "ensembl_transcript_id", "transcript_exon_intron"), mart = ensembl_mart) %>% as_tibble

```

## generate lists of target genes containing motifs of splicing factors

use regex lmao

```{r eval=FALSE, include=FALSE}

RBM41_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "(A|T)TAC(A|T)TT")), "external_gene_name"] %>% unique

print(nrow(RBM41_binding_motif_containing_genes))

SRSF2_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "AGGAG(A|T)(G|A|T)")), "external_gene_name"] %>% unique

print(nrow(SRSF2_binding_motif_containing_genes))

wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$Gene %>% unique %>% length %>% print

print("rip")

```

## import MBNL (HiTS-CLiP) and SRSF (FLASH-Seq) data and match with GTF information

### set directories

```{r}

clipseq_dir <- "Z:/isoform_usage_project/CLIPseq_files/"

FLASHseq_dir <- "Y:/2019_FLASHseq/results/R_processing_results/"

```

## enrichment of upstream RBPs - clusterwise

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  # "SRSF1 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR1-SRSF1.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF2 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR5-SRSF2.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF3 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR8-SRSF3.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF4 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR9-SRSF4.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF5 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR10-SRSF5.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF6 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR11-SRSF6.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF7 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR12-SRSF7.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF9 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR13-SRSF9.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF11 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR14-SRSF11.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)

## gene enrichment in each cluster
 
list_of_RBP_target_enrichment_by_SOM_cluster_OBseries_AS_plausible <- purrr::map(.x = list_of_OBseries_gene_tables_by_SOM_cluster_flattened_AS_plausible, .f = ~enrichment(genes = ., reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_RBP_target_enrichment_by_SOM_cluster_OBseries_AS_plausible) <- 1:number_of_som_clusters

list_of_RBP_target_enrichment_by_SOM_cluster_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_RBP_target_enrichment_by_SOM_cluster_OBseries_AS_plausible, .y = 1:number_of_som_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_RBP_target_enrichment_by_SOM_cluster_OBseries_topten_AS_plausible <- purrr::reduce(.x = list_of_RBP_target_enrichment_by_SOM_cluster_OBseries_topten_AS_plausible, .f = bind_rows) %>% type_convert %>% cbind(., cluster_minus_1 = .$cluster - 1) %>% cbind(., remainder_facet.x = .$cluster_minus_1 %% 5) %>% cbind(., quotient_facet.y = .$cluster_minus_1 %/% 5)

## GGPLOT

ggplot(wide_table_of_RBP_target_enrichment_by_SOM_cluster_OBseries_topten_AS_plausible, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(pval))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle("Top 10 significantly over-represented UPSTREAM RBP CANDIDATES for each PLAUSIBLE cluster in OB series") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 15)) +
  xlab("Upstream RBP with literature reference") +
  ylab("Number of genes enriched amongst RBP target genes") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 60)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_upstreamRBP_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
 ggsave(filename = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_upstreamRBP_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

write.table(x = wide_table_of_RBP_target_enrichment_by_SOM_cluster_OBseries_topten_AS_plausible, file = paste(results_directory_figures, OB_xdim, "x", OB_ydim, "_SOM_", length(long_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$AS_event_ID %>% unique), "_junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_upstreamRBP_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)


```

## enrichment of upstream RBPs - timepointwise

```{r}

### highest PSI 

list_of_highest_PSI_per_timepoint_RBPenrichment_OBseries_AS_plausible <- purrr::map(.x = list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_highest_PSI_per_timepoint_RBPenrichment_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_highest_PSI_per_timepoint_RBPenrichment_OBseries_AS_plausible, .y = as.list(names(list_of_highest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible <- purrr::reduce(.x = list_of_highest_PSI_per_timepoint_RBPenrichment_OBseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible)

wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible$timepoint))), timepoint)

### lowest PSI

list_of_lowest_PSI_per_timepoint_RBPenrichment_OBseries_AS_plausible <- purrr::map(.x = list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert)

list_of_lowest_PSI_per_timepoint_RBPenrichment_OBseries_topten_AS_plausible <- purrr::map2(.x = list_of_lowest_PSI_per_timepoint_RBPenrichment_OBseries_AS_plausible, .y = as.list(names(list_of_lowest_PSI_isoforms_per_timepoint_OBseries_filtered_AS_plausible)), .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., timepoint = .y))

# un-nest by binding rows
wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible <- purrr::reduce(.x = list_of_lowest_PSI_per_timepoint_RBPenrichment_OBseries_topten_AS_plausible, .f = bind_rows)

wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible <- type_convert(wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible)

wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible <- arrange(transform(wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible, timepoint = factor(timepoint, levels = unique(wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible$timepoint))), timepoint)

## GGPLOT

# highest PSI

ggplot(wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for the", high_scaledPSIcutoff * 100, "% highest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP") +
  ylab("Number of gene targets in cluster") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_highestPSI_upstreamRBP_OBseries_AS_plausible, file = paste(results_directory_figures, "UpstreamRBPs_top10_", high_scaledPSIcutoff * 100, "_percent_highestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# lowest PSI

ggplot(wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for the", high_scaledPSIcutoff * 100, "% lowest PSI PLAUSIBLE isoforms in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP") +
  ylab("Number of gene targets in cluster") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "UpstreamRBPs_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm")

write.table(x = wide_table_of_timepointwise_lowestPSI_upstreamRBP_OBseries_AS_plausible, file = paste(results_directory_figures, "UpstreamRBPs_top10_", low_scaledPSIcutoff * 100, "_percent_lowestPSI_eachtimepoint_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)


```

# QUALITY CHECK

## create quality check results directory

```{r}

qualitycheck_results_dir <-  paste(results_dir, "qualitycheck/", sep = "")

if(! dir.exists(qualitycheck_results_dir) ) {
     dir.create(qualitycheck_results_dir, recursive = TRUE)}

JUM_diff_dir <- "Y:/PGNEXUS_OBseries/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/JUM_diff/"

```

## check for stringency of timepointwise top/bottom cutoff

```{r}

for (OBtimepoint in OBseries_timepoints) {
  
  ggplot(list_of_highest_PSI_isoforms_per_timepoint_OBseries[[OBtimepoint]] %>% as.data.frame %>% mutate_if(is.factor, as.character) %>% type_convert, aes(x = .x)) + 
  geom_density() +
  ggtitle(paste("density_distribution_of_scaled_PSI_for_", OBtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  xlab("scaled PSI") +
  ylab("proportion of isoforms") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "density_distribution_of_scaled_PSI_for_", OBtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "density_distribution_of_scaled_PSI_for_", OBtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 
 
  ggplot(list_of_highest_PSI_isoforms_per_timepoint_OBseries[[OBtimepoint]] %>% as.data.frame %>% mutate_if(is.factor, as.character) %>% type_convert, aes(x = .x)) + 
  stat_ecdf(geom = "smooth", colour = "black") +
  geom_hline(aes(yintercept = 0.1), color = "red", linetype = "dashed", size = 1) +
  ggtitle(paste("CDF_distribution_of_scaled_PSI_for_", OBtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  xlab("scaled PSI") +
  ylab("proportion of isoforms") +
  scale_y_continuous(breaks = c(0.0, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0)) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "CDF_distribution_of_scaled_PSI_for_", OBtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "CDF_distribution_of_scaled_PSI_for_", OBtimepoint, "_timepoint_any_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")
  
}

```

## check for whether there is any dependence of number of junctions detected vs. coverage

```{r}

number_of_junctions_detected_per_sample <- read.delim(paste(qualitycheck_results_dir, "number_of_junctions_detected_per_sample.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE) %>% as_tibble

coveragedata <- read.delim(paste(qualitycheck_results_dir, "coveragedata.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

num_junctions_vs_coverage <- dplyr::inner_join(number_of_junctions_detected_per_sample, coveragedata, by = "timepoint_name")

num_junctions_vs_coverage_pearson <- cor(num_junctions_vs_coverage[, 2], num_junctions_vs_coverage[, 3], method = "pearson") %>% signif(4)

num_junctions_vs_coverage_gradient <- lm(formula = junction_counts ~ read_count, num_junctions_vs_coverage) %>% .[[1]] %>% .[2] %>% signif(digits = 4)

num_junctions_vs_coverage_intercept <- lm(formula = junction_counts ~ read_count, num_junctions_vs_coverage) %>% .[[1]] %>% .[1] %>% signif(4)

ggplot(num_junctions_vs_coverage, aes(y = junction_counts, x = read_count)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y~x, colour = "blue") +
  annotate(geom = "text", label = bquote("R"^2 ~ "=" ~ .(num_junctions_vs_coverage_pearson)), x = 3.75e7, y = 244000, color = "blue") +
  annotate(geom = "text", label = bquote("y =" ~ .(num_junctions_vs_coverage_gradient) ~ "x +" ~ .(num_junctions_vs_coverage_intercept)), x = 3.75e7, y = 240000, color = "blue") +
  ggtitle(paste("plot_of_number_of_junctions_per_sample_vs_coverage_OBseries", sep = "")) +
  xlab("Sequencing Depth") +
  ylab("Number of splice junctions detected") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "plot_of_number_of_junctions_per_sample_vs_coverage_OBseries", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 15, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "plot_of_number_of_junctions_per_sample_vs_coverage_OBseries", ".svg", sep = ""), device = "svg", dpi = 600, width = 15, height = 15, units = "cm")


```

## k-sweep and consensus matrix validation of som

```{r}

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range <- 5
ydim_range <- 4:8

som_seed_number <- 7

# OB series #####

set.seed(som_seed_number)

wide_table_som_sweep_clusters <- purrr::map2(.x = xdim_range, .y = ydim_range, .f = ~som(som_5_by_5_OBseries_table_AS_plausible, grid = somgrid(xdim = .x, ydim = .y, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)) %>% purrr::reduce(bind_cols)

wide_table_som_sweep_clusters <- wide_table_som_sweep_clusters %>% as.data.frame

rownames(wide_table_som_sweep_clusters) <- paste(PSI_levels_timeseries_OB_wide_AS_plausible$Gene, "_", PSI_levels_timeseries_OB_wide_AS_plausible$isoform_ID, sep = "")

# wide_table_som_sweep_clusters <- bind_cols(wide_table_som_sweep_clusters, gene_isoform_ID = paste(PSI_levels_timeseries_OB_wide_AS_plausible$Gene, "_", PSI_levels_timeseries_OB_wide_AS_plausible$isoform_ID, sep = ""))

list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% purrr::map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}))

list_percentage_consensus_byisoform <- purrr::map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble)

tibble_consensus_matrix <- purrr::reduce(list_percentage_consensus_byisoform, bind_rows)

matrix_consensus_matrix <- tibble_consensus_matrix %>% as.matrix

rownames(matrix_consensus_matrix) <- names(list_percentage_consensus_byisoform)

# reorder rows of consensus matrix

dist_result <- matrix_consensus_matrix %>% dist(method = "euclidean")
hclust_result <- hclust(dist_result, method = "ward.D2")
consensus_dendrogram <- as.dendrogram(hclust_result)
# cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

consensus_dendrogram_reordered <- reorder(consensus_dendrogram, matrix_consensus_matrix_rowmeans)

ggdendrogram(consensus_dendrogram_reordered) +
  ggsave(filename = paste(qualitycheck_results_dir, "dendrogram_som_consensus_matrix_", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_junctions_sweep_from_", min(xdim_range), "x", min(ydim_range), "_to_", max(xdim_range), "x", max(ydim_range), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 400, width = 200, height = 150, units = "cm", limitsize = FALSE)

dendrogram_order <- consensus_dendrogram_reordered %>% unlist
 
matrix_consensus_matrix_reordered <- matrix_consensus_matrix[dendrogram_order, dendrogram_order] %>% as_tibble(rownames = "gene_isoform_ID")
 
tibble_consensus_matrix_long <- reshape2::melt(matrix_consensus_matrix_reordered, id = c("gene_isoform_ID"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_if(is.factor, as.character)

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("Consensus matrix for som of ", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible), "isoforms OBseries (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), sweep from ", min(xdim_range), "x", min(ydim_range), " to ", max(xdim_range), "x", max(ydim_range), sep = "")) +
  scale_x_discrete(breaks = matrix_consensus_matrix_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_reordered$gene_isoform_ID) +
  scale_y_discrete(breaks = matrix_consensus_matrix_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_reordered$gene_isoform_ID) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black"), values = c(0, 0.33, 0.67, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 5, lineheight = 0.75, colour = "black", margin = margin(r = 1200)), legend.title.align = 0.5, axis.text.y = element_text(size = 5, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "heatmap_som_consensus_matrix_", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_junctions_sweep_from_", min(xdim_range), "x", min(ydim_range), "_to_", max(xdim_range), "x", max(ydim_range), "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 400, width = 200, height = 150, units = "cm", limitsize = FALSE)

```

## frequency distribution of no. junctions structures detected/gene

### all junctions

```{r}

avg_junctions_per_gene_all <- (wide_table_all_splicemodes_split_with_na$AS_event_ID %>% unique %>% length)/(wide_table_all_splicemodes_split_with_na$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_all, "unique junction structures overall without considering plausible AS length"))

junctions_per_gene_all_freq <- wide_table_all_splicemodes_split_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_all_freq_2 <- junctions_per_gene_all_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_all_freq_2) + 
  geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
  geom_text(data = junctions_per_gene_all_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 20, x = no_junctions), position = position_nudge(y = 50)) +
  ggtitle(paste("frequency distribution of ALL junctions per gene 
                ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  xlim(c(0, 20)) +
  xlab("number of junctions/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_all_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_all.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_all_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_all.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_all_freq_2[1, 2]/junctions_per_gene_all_freq_2[2, 2]))

```

### all constitutive junctions

```{r}

avg_junctions_per_gene_all <- (PSI_levels_timeseries_constitutive_OB_wide_with_na$AS_event_ID %>% unique %>% length)/(PSI_levels_timeseries_constitutive_OB_wide_with_na$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_all, "unique constitutive junction structures detected without considering plausible AS length"))

junctions_per_gene_all_freq <- PSI_levels_timeseries_constitutive_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_all_freq_2 <- junctions_per_gene_all_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_all_freq_2) + 
  geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
  geom_text(data = junctions_per_gene_all_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 20, x = no_junctions), position = position_nudge(y = 50)) +
  ggtitle(paste("frequency distribution of constitutive junctions per gene for all genes 
                ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  xlim(c(0, 20)) +
  xlab("number of junctions/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_constitutive_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_all.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_constitutive_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_all.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_all_freq_2[1, 2]/junctions_per_gene_all_freq_2[2, 2]))

```

### all differential junctions

```{r}

avg_junctions_per_gene_all <- (PSI_levels_timeseries_OB_wide_with_na$AS_event_ID %>% unique %>% length)/(PSI_levels_timeseries_OB_wide_with_na$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_all, "unique differentially spliced junction structures detected without considering plausible AS length"))

junctions_per_gene_all_freq <- PSI_levels_timeseries_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_all_freq_2 <- junctions_per_gene_all_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_all_freq_2) + 
  geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
  geom_text(data = junctions_per_gene_all_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 20, x = no_junctions)) +
  ggtitle(paste("frequency distribution of differentially spliced junctions per gene for all genes 
                ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  xlim(c(0, 20)) +
  xlab("number of junctions/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_all.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_all.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_all_freq_2[1, 2]/junctions_per_gene_all_freq_2[2, 2]))

```

### plausible junctions only

```{r}

avg_junctions_per_gene_AS_plausible <- (wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$AS_event_ID %>% unique %>% length)/(wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene %>% unique %>% length)

print(paste("There are", avg_junctions_per_gene_AS_plausible, "unique differentially spliced junction structures with a plausible AS length"))

junctions_per_gene_AS_plausible_freq <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_AS_plausible_freq_2 <- junctions_per_gene_AS_plausible_freq %>% group_by(no_junctions) %>% summarise(numberofgeneswithjunctionnumber = n())

# ggplot

ggplot(junctions_per_gene_AS_plausible_freq_2) + 
  geom_col(aes(y = numberofgeneswithjunctionnumber, x = no_junctions)) +
  geom_text(data = junctions_per_gene_AS_plausible_freq_2, aes(label = numberofgeneswithjunctionnumber, y = numberofgeneswithjunctionnumber + 10, x = no_junctions)) +
  ggtitle(paste("frequency distribution of differentially spliced junctions per gene for plausible genes 
                ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
  xlim(c(0, 20)) +
  xlab("number of junctions/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_gene_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, "_plausibleASlength.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 isoform genes : 2 isoform genes =", junctions_per_gene_AS_plausible_freq_2[1, 2]/junctions_per_gene_AS_plausible_freq_2[2, 2]))

```

## frequency distribution of no. events detected per category

```{r}

junctions_per_category_all_freq <- PSI_levels_timeseries_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode) %>% summarise(no_junctions_all = n())

junctions_per_category_AS_plausible_freq <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode) %>% summarise(no_junctions_AS_plausible = n())

junctions_per_category_summary <- dplyr::full_join(junctions_per_category_all_freq, junctions_per_category_AS_plausible_freq, by = "splicemode")

junctions_per_category_summary_2 <- add_column(junctions_per_category_summary, "percentage_change_after_AS_plausible_filtering" = paste(signif((junctions_per_category_summary$no_junctions_AS_plausible - junctions_per_category_summary$no_junctions_all) * 100 / junctions_per_category_summary$no_junctions_all, 2), "%"))

long_junctions_per_category_summary_2 <- reshape2::melt(junctions_per_category_summary_2, id.vars = "splicemode")

long_junctions_per_category_summary_3 <- add_column(long_junctions_per_category_summary_2, "value_numeric" = gsub(x = long_junctions_per_category_summary_2$value, pattern = " %", replacement = "") %>% as.numeric)

# ggplot

ggplot(long_junctions_per_category_summary_3) + 
geom_col(aes(y = value_numeric, x = splicemode)) +
facet_wrap(~variable, scales = "free") +
geom_label(data = long_junctions_per_category_summary_3, aes(label = value, y = value_numeric, x = splicemode)) +
ggtitle(paste("frequency distribution of differentially spliced junctions per category 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("AS category") +
ylab("Number of differential junctions") +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family ="Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_category_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_category_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

## frequency distribution of no. junctions detected with NMD/first exon/last exon

incl. NMD, first/last junction.

```{r}

# ALL JUNCTIONS
# category means splicemode + NMD status + first/last junction
# also clean up the splicemode column
tibble_junctions_per_category_all <- wide_table_all_splicemodes_split_with_na_with_ref_annot %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_junctions_all = n())

all_junctions_count <- tibble_junctions_per_category_all$no_junctions_all %>% sum(na.rm = TRUE)
number_NMD_all_junctions <- tibble_junctions_per_category_all[tibble_junctions_per_category_all$any_NMD == TRUE, ] %>% .$no_junctions_all %>% sum(na.rm = TRUE)
number_first_junction_all_junctions <- tibble_junctions_per_category_all[tibble_junctions_per_category_all$any_first_exon == TRUE, ] %>% .$no_junctions_all %>% sum(na.rm = TRUE)
number_last_junction_all_junctions <- tibble_junctions_per_category_all[tibble_junctions_per_category_all$any_last_exon == TRUE, ] %>% .$no_junctions_all %>% sum(na.rm = TRUE)

message("There are ", number_NMD_all_junctions*100/all_junctions_count, "% NMD junctions overall.")
message("There are ", number_first_junction_all_junctions*100/all_junctions_count, "% first junctions overall.")
message("There are ", number_last_junction_all_junctions*100/all_junctions_count, "% last junctions overall.")

# CONSTITUTIVE JUNCTIONS
tibble_junctions_per_category_constitutive <- PSI_levels_timeseries_constitutive_OB_wide %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_junctions_constitutive = n())

constitutive_junctions_count <- tibble_junctions_per_category_constitutive$no_junctions_constitutive %>% sum(na.rm = TRUE)
number_NMD_constitutive_junctions <- tibble_junctions_per_category_constitutive[tibble_junctions_per_category_constitutive$any_NMD == TRUE, ] %>% .$no_junctions_constitutive %>% sum(na.rm = TRUE)
number_first_junction_constitutive_junctions <- tibble_junctions_per_category_constitutive[tibble_junctions_per_category_constitutive$any_first_exon == TRUE, ] %>% .$no_junctions_constitutive %>% sum(na.rm = TRUE)
number_last_junction_constitutive_junctions <- tibble_junctions_per_category_constitutive[tibble_junctions_per_category_constitutive$any_last_exon == TRUE, ] %>% .$no_junctions_constitutive %>% sum(na.rm = TRUE)

message("There are ", number_NMD_constitutive_junctions*100/constitutive_junctions_count, "% NMD junctions constitutive.")
message("There are ", number_first_junction_constitutive_junctions*100/constitutive_junctions_count, "% first junctions constitutive.")
message("There are ", number_last_junction_constitutive_junctions*100/constitutive_junctions_count, "% last junctions constitutive.")

# DIFFERENTIAL JUNCTIONS
tibble_junctions_per_category_differential <- PSI_levels_timeseries_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_junctions_differential = n())

differential_junctions_count <- tibble_junctions_per_category_differential$no_junctions_differential %>% sum(na.rm = TRUE)
number_NMD_differential_junctions <- tibble_junctions_per_category_differential[tibble_junctions_per_category_differential$any_NMD == TRUE, ] %>% .$no_junctions_differential %>% sum(na.rm = TRUE)
number_first_exon_differential_junctions <- tibble_junctions_per_category_differential[tibble_junctions_per_category_differential$any_first_exon == TRUE, ] %>% .$no_junctions_differential %>% sum(na.rm = TRUE)
number_last_exon_differential_junctions <- tibble_junctions_per_category_differential[tibble_junctions_per_category_differential$any_last_exon == TRUE, ] %>% .$no_junctions_differential %>% sum(na.rm = TRUE)

message("There are ", number_NMD_differential_junctions*100/differential_junctions_count, "% NMD junctions differential.")
message("There are ", number_first_exon_differential_junctions*100/differential_junctions_count, "% first junctions differential.")
message("There are ", number_last_exon_differential_junctions*100/differential_junctions_count, "% last junctions differential.")

# DIFFERENTIAL JUNCTIONS (PLAUSIBLE)
tibble_junctions_per_category_differential_plausible <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_junctions_differential_plausible = n())

differential_plausible_junctions_count <- tibble_junctions_per_category_differential_plausible$no_junctions_differential_plausible %>% sum(na.rm = TRUE)
number_NMD_differential_plausible_junctions <- tibble_junctions_per_category_differential_plausible[tibble_junctions_per_category_differential_plausible$any_NMD == TRUE, ] %>% .$no_junctions_differential_plausible %>% sum(na.rm = TRUE)
number_first_exon_differential_plausible_junctions <- tibble_junctions_per_category_differential_plausible[tibble_junctions_per_category_differential_plausible$any_first_exon == TRUE, ] %>% .$no_junctions_differential_plausible %>% sum(na.rm = TRUE)
number_last_exon_differential_plausible_junctions <- tibble_junctions_per_category_differential_plausible[tibble_junctions_per_category_differential_plausible$any_last_exon == TRUE, ] %>% .$no_junctions_differential_plausible %>% sum(na.rm = TRUE)

message("There are ", number_NMD_differential_plausible_junctions*100/differential_plausible_junctions_count, "% NMD junctions differential (plausible).")
message("There are ", number_first_exon_differential_plausible_junctions*100/differential_plausible_junctions_count, "% first junctions differential (plausible).")
message("There are ", number_last_exon_differential_plausible_junctions*100/differential_plausible_junctions_count, "% last junctions differential (plausible).")

# COMBINE ALL THE TABLES FOR PLOTTING
tibble_junctions_per_category_summary <- list(tibble_junctions_per_category_all, tibble_junctions_per_category_constitutive, tibble_junctions_per_category_differential, tibble_junctions_per_category_differential_plausible) %>% purrr::reduce(dplyr::full_join)

# melt the sample
long_tibble_junctions_per_category_summary <- reshape2::melt(tibble_junctions_per_category_summary, id.vars = c("splicemode", "any_NMD", "any_first_exon", "any_last_exon"), variable.name = "sample", value.name = "number_of_junctions_per_category") %>% as_tibble %>% 
  # add the overall counts for each splicemode
  dplyr::group_by(splicemode, sample) %>% dplyr::mutate("number_of_junctions_per_splicemode" = sum(number_of_junctions_per_category %>% na.omit))

# melt the category (splicemode + NMD+ first + last exon)
long_tibble_junctions_per_category_summary_2 <- reshape2::melt(long_tibble_junctions_per_category_summary, id.vars = c("splicemode", "sample", "number_of_junctions_per_category", "number_of_junctions_per_splicemode"), variable.name = "NMD_first_last_exon", value.name = "NMD_first_last_exon_value") %>% as_tibble %>% 
  # add the overall counts for each unique category
  dplyr::group_by(splicemode, sample, NMD_first_last_exon, NMD_first_last_exon_value) %>% dplyr::mutate("number_of_junctions_per_category" = sum(number_of_junctions_per_category %>% na.omit)) %>% unique %>%
  # add the percentage for each category/splicemode
  dplyr::mutate("percentage_junctions_per_category" = number_of_junctions_per_category*100/number_of_junctions_per_splicemode)

max_number_of_junctions_per_splicemode <- max(long_tibble_junctions_per_category_summary_2$number_of_junctions_per_splicemode)
max_percentage_junctions_per_category <- max(long_tibble_junctions_per_category_summary_2[long_tibble_junctions_per_category_summary_2$NMD_first_last_exon_value == TRUE, ] %>% .$percentage_junctions_per_category %>% na.omit)
max_number_of_junctions_per_splicemode_for_plot <- max_number_of_junctions_per_splicemode

# ggplot
ggplot() + 
  geom_col(data = long_tibble_junctions_per_category_summary_2[, c("splicemode", "sample", "number_of_junctions_per_splicemode")]  %>% dplyr::distinct(splicemode, sample, .keep_all = TRUE), aes(y = number_of_junctions_per_splicemode, x = splicemode)) +
  facet_wrap(~sample, scales = "free", labeller = labeller(sample = c(no_junctions_all = "All junctions", no_junctions_constitutive = "Constitutive", no_junctions_differential = "Differential", no_junctions_differential_plausible = "Differential (plausible)"))) +
  geom_label(data = long_tibble_junctions_per_category_summary_2[, c("splicemode", "sample", "number_of_junctions_per_splicemode")]  %>% dplyr::distinct(splicemode, sample, .keep_all = TRUE), aes(label = number_of_junctions_per_splicemode, y = number_of_junctions_per_splicemode, x = splicemode), position = position_identity()) +
  geom_jitter(data = long_tibble_junctions_per_category_summary_2[long_tibble_junctions_per_category_summary_2$NMD_first_last_exon_value == TRUE, ], aes(x = splicemode, y = percentage_junctions_per_category * max_number_of_junctions_per_splicemode_for_plot / max_percentage_junctions_per_category, shape = NMD_first_last_exon), width = 0.1, height = 0) +
  ggtitle(paste("Frequency distribution of junctions per category 
                ", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, sep = "")) +
  xlab("Splicemode") +
  scale_y_continuous(name = "Number of junctions", limits = c(0, max_number_of_junctions_per_splicemode_for_plot), sec.axis = sec_axis(trans = ~. * max_percentage_junctions_per_category/max_number_of_junctions_per_splicemode, (name = "Percentage NMD/first/last exon per splicemode"))) +
  scale_shape_manual(name = "Category", limits = c("any_NMD", "any_first_exon", "any_last_exon"), labels = c("NMD candidate", "First exon", "Last exon"), values = c(1, 4, 19)) + 
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "frequency_distribution_of_junctions_per_NMD.first.last.exon_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 30, units = "cm") +
  ggsave(filename = paste(results_directory_figures, "frequency_distribution_of_junctions_per_NMD.first.last.exon_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 30, units = "cm") 

# upset plot
message("all junctions")
df <- wide_table_all_splicemodes_split_with_na_with_ref_annot %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% .[, c("AS_event_ID", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = AS_event_ID + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -AS_event_ID), row.names = df$AS_event_ID) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(results_directory_figures, "upset_plot_of_intersections_junctions_per_NMD.first.last.exon_per_splicemode_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, "_alljunctions.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Junction ontology",
                                                                     "any_first_exon" = "Junction ontology",
                                                                     "any_last_exon" = "Junction ontology",
                                                                     "A3SS_events" = "Splicemode",
                                                                     "A5SS_events" = "Splicemode",
                                                                     "cassette_exon_events" = "Splicemode",
                                                                     "composite_events" = "Splicemode",
                                                                     "intron_retention" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Junction ontology" = "tomato1", "Splicemode" = "blue2"))
                                                      ))

dev.off()

message("all constitutive")
df <- PSI_levels_timeseries_constitutive_OB_wide %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% .[, c("AS_event_ID", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = AS_event_ID + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -AS_event_ID), row.names = df$AS_event_ID) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(results_directory_figures, "upset_plot_of_intersections_junctions_per_NMD.first.last.exon_per_splicemode_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, "_constitutive.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Junction ontology",
                                                                     "any_first_exon" = "Junction ontology",
                                                                     "any_last_exon" = "Junction ontology",
                                                                     "A3SS_events" = "Splicemode",
                                                                     "A5SS_events" = "Splicemode",
                                                                     "cassette_exon_events" = "Splicemode",
                                                                     "composite_events" = "Splicemode",
                                                                     "intron_retention" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Junction ontology" = "tomato1", "Splicemode" = "blue2"))
                                                      ))

dev.off()

message("all differential")
df <- PSI_levels_timeseries_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% .[, c("AS_event_ID", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = AS_event_ID + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -AS_event_ID), row.names = df$AS_event_ID) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(results_directory_figures, "upset_plot_of_intersections_junctions_per_NMD.first.last.exon_per_splicemode_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, "_differential.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Junction ontology",
                                                                     "any_first_exon" = "Junction ontology",
                                                                     "any_last_exon" = "Junction ontology",
                                                                     "A3SS_events" = "Splicemode",
                                                                     "A5SS_events" = "Splicemode",
                                                                     "cassette_exon_events" = "Splicemode",
                                                                     "composite_events" = "Splicemode",
                                                                     "intron_retention" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Junction ontology" = "tomato1", "Splicemode" = "blue2"))
                                                      ))

dev.off()

message("differential (plausible)")
df <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% .[, c("AS_event_ID", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = AS_event_ID + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -AS_event_ID), row.names = df$AS_event_ID) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(results_directory_figures, "upset_plot_of_intersections_junctions_per_NMD.first.last.exon_per_splicemode_", p_or_q_value, qpvalue_cutoff, "_dpsi", dPSI_cutoff, "_differential_plausible.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Junction ontology",
                                                                     "any_first_exon" = "Junction ontology",
                                                                     "any_last_exon" = "Junction ontology",
                                                                     "A3SS_events" = "Splicemode",
                                                                     "A5SS_events" = "Splicemode",
                                                                     "cassette_exon_events" = "Splicemode",
                                                                     "composite_events" = "Splicemode",
                                                                     "intron_retention" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Junction ontology" = "tomato1", "Splicemode" = "blue2"))
                                                      ))

dev.off()

```

## check the concordance between the ref and recon gtf first/last exon and NMD

```{r}

# get row indices of first/last exon and NMD annotations.
## first exon
row.indices_first_exon_ref <- grep(x = wide_table_all_splicemodes_split_with_na_with_ref_annot$first_or_last_exon_reference, pattern = "first_exon")
row.indices_first_exon_recon <- grep(x = wide_table_all_splicemodes_split_with_na_with_ref_annot$first_or_last_exon_recon, pattern = "first_exon")

row.indices_first_exon_ref.recon.intersection <- intersect(row.indices_first_exon_ref, row.indices_first_exon_recon)
row.indices_first_exon_ref.recon.union <- union(row.indices_first_exon_ref, row.indices_first_exon_recon)

message("number of first exons in the reference: ", row.indices_first_exon_ref %>% length)
message("number of first exons in the recon: ", row.indices_first_exon_recon %>% length)
message("number of first exons in BOTH recon and reference: ", row.indices_first_exon_ref.recon.intersection %>% length)
message("first exons jaccard similarity: ", (row.indices_first_exon_ref.recon.intersection %>% length)/(row.indices_first_exon_ref.recon.union %>% length))

## last exon
row.indices_last_exon_ref <- grep(x = wide_table_all_splicemodes_split_with_na_with_ref_annot$first_or_last_exon_reference, pattern = "last_exon")
row.indices_last_exon_recon <- grep(x = wide_table_all_splicemodes_split_with_na_with_ref_annot$first_or_last_exon_recon, pattern = "last_exon")

row.indices_last_exon_ref.recon.intersection <- intersect(row.indices_last_exon_ref, row.indices_last_exon_recon)
row.indices_last_exon_ref.recon.union <- union(row.indices_last_exon_ref, row.indices_last_exon_recon)

message("number of last exons in the reference: ", row.indices_last_exon_ref %>% length)
message("number of last exons in the recon: ", row.indices_last_exon_recon %>% length)
message("number of last exons in BOTH recon and reference: ", row.indices_last_exon_ref.recon.intersection %>% length)
message("last exons jaccard similarity: ", (row.indices_last_exon_ref.recon.intersection %>% length)/(row.indices_last_exon_ref.recon.union %>% length))

## NMD
row.indices_NMD_ref <- grep(x = wide_table_all_splicemodes_split_with_na_with_ref_annot$NMD_reference, pattern = "TRUE")
row.indices_NMD_recon <- grep(x = wide_table_all_splicemodes_split_with_na_with_ref_annot$NMD_recon, pattern = "TRUE")

row.indices_NMD_ref.recon.intersection <- intersect(row.indices_NMD_ref, row.indices_NMD_recon)
row.indices_NMD_ref.recon.union <- union(row.indices_NMD_ref, row.indices_NMD_recon)

message("number of NMD in the reference: ", row.indices_NMD_ref %>% length)
message("number of NMD in the recon: ", row.indices_NMD_recon %>% length)
message("number of NMD in BOTH recon and reference: ", row.indices_NMD_ref.recon.intersection %>% length)
message("NMD jaccard similarity: ", (row.indices_NMD_ref.recon.intersection %>% length)/(row.indices_NMD_ref.recon.union %>% length))

```


## Recording absolute PSI values for reporting junction switching

### Import the detailed tables into the environment

```{r message=FALSE, warning=FALSE}

list_of_timepoint_comparisons_final <- read.delim(paste(results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree %>% flatten

list_of_AS_events <- c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events") %>% array_tree %>% flatten

# read tables into environment

list_of_detailed_tables <- purrr::map(.x = list_of_timepoint_comparisons_final, .f = ~purrr::map2(.x = .x, .y = list_of_AS_events, .f = ~read.delim(file = paste(results_dir, "final_JUM_output_", .x, "/", list.files(path = paste(results_dir, "final_JUM_output_", .x, "/", sep = ""), pattern = paste("(.)", .y, "(.*)detailed.txt", sep = "")), sep = ""), na.strings = c("NONE", "NA", "INF", "Inf") , sep = "\t", stringsAsFactors = FALSE) %>% as_tibble %>% add_column(., "splicemode" = .y)) %>% set_names(list_of_AS_events)) %>% set_names(list_of_timepoint_comparisons_final)

# bind rows for each comparison

list_of_detailed_tables_2 <- purrr::map(.x = list_of_detailed_tables, .f = ~rbindlist(.x))

# rename the colnames to be not comparison-specific - we will add a comparison column later on

list_of_detailed_tables_3 <- purrr::map2(.x = list_of_detailed_tables_2, .y = list_of_timepoint_comparisons_final, .f = ~setNames(., c("Gene", "AS_event_ID", "AS_structure_ID", "sub_junction_ID", "sub-junction_dispersion_estimate", "LRT_statistic-full_vs_reduced", "LRT_p_value-full_vs_reduced", "BH_adjusted_p-values", "logCPM_1", "logCPM_2", "fitting_parameter_log2fold_change_2_from_1", "sub_junction_chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand", "raw_count.1", "raw_count.2", "raw_count.3", "raw_count.4", "raw_count.5", "raw_count.6", "percentage_usage.1", "percentage_usage.2", "percentage_usage.3", "percentage_usage.4", "percentage_usage.5", "percentage_usage.6", "deltaPSI", "splicemode")) %>% add_column(., "comparison" = .y)) 

wide_tibble_of_all_detailed_tables <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble

# remove all the rows which have an NA except for in the dpsi because that's cassette exon.
wide_tibble_of_all_detailed_tables <- wide_tibble_of_all_detailed_tables[-which(is.na(wide_tibble_of_all_detailed_tables[, -29])), ]

wide_tibble_of_all_detailed_tables <- wide_tibble_of_all_detailed_tables[wide_tibble_of_all_detailed_tables$Gene != "Gene", ]

```

### extract only the MSC timepoint (ud)

we can take any comparison involving ud. I just happened to take the 12d - ud table.

```{r}

wide_tibble_of_all_detailed_tables_12d.ud.only <- wide_tibble_of_all_detailed_tables[wide_tibble_of_all_detailed_tables$comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_ud", ]

colnames(wide_tibble_of_all_detailed_tables_12d.ud.only)[29] <- "12d"

```

### calculate PSI by taking average of all 3 ud replicates

```{r}

wide_tibble_of_all_detailed_tables_12d.ud.only_2 <- wide_tibble_of_all_detailed_tables_12d.ud.only

wide_tibble_of_all_detailed_tables_12d.ud.only_2[, c(23:28)] <- wide_tibble_of_all_detailed_tables_12d.ud.only[, c(23:28)] %>% as.data.frame %>% apply(., 2, FUN = function(X){strsplit(X, split = "\\%") %>% unlist})

wide_tibble_of_all_detailed_tables_12d.ud.only_2 <- wide_tibble_of_all_detailed_tables_12d.ud.only_2[-which(is.na(wide_tibble_of_all_detailed_tables_12d.ud.only_2[, -29])), ]
  
wide_tibble_of_all_detailed_tables_12d.ud.only_3 <- wide_tibble_of_all_detailed_tables_12d.ud.only_2 %>% 
  add_column("avg_PSI_12d" = apply(X = .[, c("percentage_usage.1", "percentage_usage.2", "percentage_usage.3")], MARGIN = 1, FUN = function(X){mean(X %>% as.numeric)/100})) %>%
  add_column("avg_PSI_ud" = apply(X = .[, c("percentage_usage.4", "percentage_usage.5", "percentage_usage.6")], MARGIN = 1, FUN = function(X){mean(X %>% as.numeric)/100})) %>%
  add_column("dpsi_12d.minus.ud_1" = .$avg_PSI_12d - .$avg_PSI_ud)

```

### apply special averaging treatment for cassette exons

```{r}

list_detailed_cassette.exon_AS.event.IDs <- wide_tibble_of_all_detailed_tables_12d.ud.only_3[wide_tibble_of_all_detailed_tables_12d.ud.only_3$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unique %>% array_tree

# subset 12d.ud table by AS event ID for cassette exons only

list_of_12d.ud_detailed_tibble_subset_by_AS.event.ID <- purrr::map(.x = list_detailed_cassette.exon_AS.event.IDs, .f = ~wide_tibble_of_all_detailed_tables_12d.ud.only_3[wide_tibble_of_all_detailed_tables_12d.ud.only_3$AS_event_ID == (.x %>% paste) & wide_tibble_of_all_detailed_tables_12d.ud.only_3$splicemode == "cassette_exon_events", ])

# append the cassette dpsi as dpsi_12d.minus.ud_2

list_of_12d.ud_detailed_tibble_subset_by_AS.event.ID_2 <- purrr::map(.x = list_of_12d.ud_detailed_tibble_subset_by_AS.event.ID, 
                                                                     .f = ~add_column(.x, "dpsi_12d.minus.ud_2" = .x[c(2, 3), "dpsi_12d.minus.ud_1"] %>% unlist %>% mean) %>%
                                                                       add_column(., "avg.psi_ud_final" = c(.x[c(1, 4), "avg_PSI_ud"] %>% unlist %>% mean,
                                                                                                      .x[c(2, 3), "avg_PSI_ud"] %>% unlist %>% mean,
                                                                                                      .x[c(2, 3), "avg_PSI_ud"] %>% unlist %>% mean,
                                                                                                      .x[c(1, 4), "avg_PSI_ud"] %>% unlist %>% mean)) %>%
                                                                       dplyr::mutate("12d" = c(NA, NA, -(.x[4, "12d"] %>% as.numeric), paste(.x[4, "12d"]))))

wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset <- list_of_12d.ud_detailed_tibble_subset_by_AS.event.ID_2 %>% rbindlist %>% type_convert

# # we also need -PSI for 12d
# 
# wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset_negative.12d <- wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset_positive.12d
# wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset_negative.12d[, "12d"] <- -(wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset_negative.12d$`12d` %>% as.numeric)
# 
# wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset <- dplyr::bind_rows(wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset_positive.12d, wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset_negative.12d)

```

### append cassette exon averages to the detailed table along with all the other average psi's

```{r}

wide_tibble_of_all_detailed_tables_12d.ud.only_4 <- dplyr::full_join(wide_tibble_of_all_detailed_tables_12d.ud.only_3 %>% type_convert, wide_tibble_of_all_detailed_tables_12d.ud.only_cassette.exon_subset)

wide_tibble_of_all_detailed_tables_12d.ud.only_4 <- wide_tibble_of_all_detailed_tables_12d.ud.only_4[-which(is.na(wide_tibble_of_all_detailed_tables_12d.ud.only_4$logCPM_1)), ]

wide_tibble_of_all_detailed_tables_12d.ud.only_4[wide_tibble_of_all_detailed_tables_12d.ud.only_4$splicemode != "cassette_exon_events", "avg.psi_ud_final"] <- wide_tibble_of_all_detailed_tables_12d.ud.only_4[wide_tibble_of_all_detailed_tables_12d.ud.only_4$splicemode != "cassette_exon_events", "avg_PSI_ud"]

wide_tibble_absolute.ud.PSI <- wide_tibble_of_all_detailed_tables_12d.ud.only_4[, c("AS_event_ID", "splicemode", "12d", "avg.psi_ud_final")]

```

### filtering join of the detailed tables by the timeseries PSI data

```{r}

# append the absolute PSI at timepoint ud
wide_tibble_of_absolute.ud.PSI_matched_to_PSI_table <- dplyr::left_join(PSI_levels_timeseries_OB_wide_with_na %>% type_convert, wide_tibble_absolute.ud.PSI %>% type_convert, by = c("AS_event_ID", "splicemode", "12d")) %>% as_tibble

tibble_OBseries_absolute_PSI_levels_timeseries <- wide_tibble_of_absolute.ud.PSI_matched_to_PSI_table

# add back the absolute PSI at ud timepoint
tibble_OBseries_absolute_PSI_levels_timeseries[, OBseries_timepoints] <- tibble_OBseries_absolute_PSI_levels_timeseries[, OBseries_timepoints] + tibble_OBseries_absolute_PSI_levels_timeseries$avg.psi_ud_final

# remove the absolute PSI column
tibble_OBseries_absolute_PSI_levels_timeseries <- tibble_OBseries_absolute_PSI_levels_timeseries %>% dplyr::select(., -"avg.psi_ud_final")

# reorder the columns to be in chronological order
tibble_OBseries_absolute_PSI_levels_timeseries <- tibble_OBseries_absolute_PSI_levels_timeseries[, c("Gene", "AS_event_ID", "splicemode", "isoform_number", OBseries_timepoints)] %>% dplyr::mutate_if(is.factor, as.character)

```

### analysis of junction switching

#### create subset list for every AS_event_ID (every unique junction)

```{r}

list_unique_AS.event.IDs_OBseries_absolute_PSI_levels_timeseries <- tibble_OBseries_absolute_PSI_levels_timeseries[, c("AS_event_ID", "splicemode")] %>% unique %>% array_tree

list_of_tibbles_OBseries_absolute_PSI_levels_timeseries <- purrr::map(.x = list_unique_AS.event.IDs_OBseries_absolute_PSI_levels_timeseries, .f = ~tibble_OBseries_absolute_PSI_levels_timeseries[tibble_OBseries_absolute_PSI_levels_timeseries$AS_event_ID == (.x[[1]] %>% paste) & tibble_OBseries_absolute_PSI_levels_timeseries$splicemode == (.x[[2]] %>% paste), ])

```

#### calculate the ranks for every AS_event_ID with more than one junction recorded

```{r}

# calculate ranks
list_of_tibbles_OBseries_absolute_PSI_levels_ranks.per.timepoint <- purrr::map_if(.x = list_of_tibbles_OBseries_absolute_PSI_levels_timeseries, .p = ~nrow(.x) > 1, .f = ~apply(X = .x[, OBseries_timepoints], MARGIN = 2, FUN = function(X){rank(X %>% as.numeric)}))

remove_consecutive_duplicates_from_data.frame <- function(df) {
  
  # turn dataframe into list
  a <- df %>% array_tree
  # test if each term starting from 2nd element is identical to previous
  b <- purrr::map2(.x = a[1:(length(a) - 1)], .y = a[2:(length(a))], .f = ~identical(.x, .y))
  # get the elements (minus 1) which are not identical to previous
  c <- which(b == FALSE)
  # return filtered list
  d <- a[c(1, c + 1)]
  # re-make into dataframe
  e <- d %>% rbindlist %>% as.data.frame
  row.names(e) <- names(d)
  
  # return filtered dataframe
  return(e %>% t)
  
}

# unique consecutive ranks only
list_of_tibbles_OBseries_absolute_PSI_levels_ranks.per.timepoint_unique <- purrr::map_if(.x = list_of_tibbles_OBseries_absolute_PSI_levels_ranks.per.timepoint, .p = ~nrow(.x) > 1, .f = ~.x %>% t %>% remove_consecutive_duplicates_from_data.frame)

```

#### which elements have more than one column?

```{r}

list_of_logical_junction_switched_or_not <- purrr::map_if(.x = list_of_tibbles_OBseries_absolute_PSI_levels_ranks.per.timepoint_unique, .p = ~nrow(.x) > 1, .f = ~ncol(.x) > 1)

```

#### for those junctions with only one entry, is PSI going back and forth between 0.5?

```{r}

list_of_logical_junction_switched_or_not <- purrr::map_if(.x = list_of_logical_junction_switched_or_not, .p = ~is.logical(.x) == FALSE, 
                                          .f = ~any(.x[, OBseries_timepoints] > 0.5) & any(.x[, OBseries_timepoints] < 0.5))

```

#### filter the absolute PSI table for junctions switched over the time course

```{r}

list_of_tibbles_OBseries_absolute_PSI_levels_timeseries_junction.switched <- list_of_tibbles_OBseries_absolute_PSI_levels_timeseries[which(list_of_logical_junction_switched_or_not %>% unlist == TRUE)]

tibble_OBseries_absolute_PSI_levels_timeseries_junction.switched <- list_of_tibbles_OBseries_absolute_PSI_levels_timeseries_junction.switched %>% rbindlist %>% as_tibble

# by definition, junctions that go from NA to not NA are switched
write.table(x = tibble_OBseries_absolute_PSI_levels_timeseries_junction.switched, file = paste(results_directory_figures, "wide_table_of_",  nrow(tibble_OBseries_absolute_PSI_levels_timeseries_junction.switched), "_switched.junctions_PSI_OB_diff_any_", p_or_q_value, qpvalue_cutoff, "_any_deltaPSI_greaterthan_", dPSI_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Use the NA values in junction switching to determine average expression of NA

we can use this info to determine if values are missing at random or left-censored.

### fetch row indices which have at least one NA

```{r}

# get row indices of the final junction switching table while have at least one NA

row.indices_junc.switch.table_any.na <- tibble_OBseries_absolute_PSI_levels_timeseries_junction.switched[, OBseries_timepoints] %>% apply(MARGIN = 1, FUN = function(X) {
  
  return(any(is.na(X)) == TRUE)
  
} )

row.indices_junc.switch.table_any.na <- which(row.indices_junc.switch.table_any.na == TRUE)

```

### extract AS_event_ID of na, join onto the wide tibble of detailed tables

```{r}

tibble_AS_event_ID_which_have_na <- tibble_OBseries_absolute_PSI_levels_timeseries_junction.switched[row.indices_junc.switch.table_any.na, ] %>% .$AS_event_ID %>% unique %>% tibble::enframe(value = "AS_event_ID")

# join to get all the values with na
wide_tibble_of_all_detailed_tables_with_na <- dplyr::semi_join(wide_tibble_of_all_detailed_tables, tibble_AS_event_ID_which_have_na, by = "AS_event_ID") %>% type_convert

# join to get all the values with no na
wide_tibble_of_all_detailed_tables_with_no_na <- dplyr::anti_join(wide_tibble_of_all_detailed_tables, tibble_AS_event_ID_which_have_na, by = "AS_event_ID") %>% type_convert

```

### plot distributions

```{r}

plot(density(bw = 0.01, c(wide_tibble_of_all_detailed_tables_with_na$logCPM_1 %>% na.omit, wide_tibble_of_all_detailed_tables_with_na[wide_tibble_of_all_detailed_tables_with_na$comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_ud", ] %>% .$logCPM_2 %>% na.omit)), main = "junction logCPM counts for junction structures with missing values")

plot(density(bw = 0.01, c(wide_tibble_of_all_detailed_tables_with_no_na$logCPM_1 %>% na.omit, wide_tibble_of_all_detailed_tables_with_no_na[wide_tibble_of_all_detailed_tables_with_no_na$comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_ud", ] %>% .$logCPM_2 %>% na.omit)), main = "junction logCPM counts for junction structures with no missing values")

plot(density(bw = 0.01, c(wide_tibble_of_all_detailed_tables %>% type_convert %>% .$logCPM_1 %>% na.omit, wide_tibble_of_all_detailed_tables[wide_tibble_of_all_detailed_tables$comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_ud", ] %>% type_convert %>% .$logCPM_2 %>% na.omit)), main = "junction logCPM counts for all junction structures")

```

## checking the junction counts and LRT statistics

### import the detailed tables into the environment

```{r message=FALSE, warning=FALSE}

wide_table_of_all_detailed_tables <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble

wide_table_of_all_detailed_tables_maxCPM <- wide_table_of_all_detailed_tables %>% dplyr::group_by(Gene) %>% dplyr::summarise(., maxCPM = max(logCPM_1 %>% na.omit, logCPM_2 %>% na.omit))

wide_table_of_all_detailed_tables_maxtranscriptlength <- getBM(filters = "external_gene_name", values = wide_table_of_all_detailed_tables_maxCPM$Gene, attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart) %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length	)) %>% 
  setNames(c("Gene", "maxtranscriptlength"))

wide_table_of_all_detailed_tables_maxCPM_maxtranscriptlength <- dplyr::full_join(wide_table_of_all_detailed_tables_maxCPM, 
                                                                           wide_table_of_all_detailed_tables_maxtranscriptlength, 
                                                                           by = "Gene")

```

### graph the no. of junctions detected vs. max. junction counts logCPM OR maximum transcript length

```{r}

junctions_per_gene_constitutive_all_freq <- PSI_levels_timeseries_constitutive_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_all_freq <- PSI_levels_timeseries_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

junctions_per_gene_AS_plausible_freq <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(Gene) %>% summarise(no_junctions = n())

wide_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength <- dplyr::full_join(wide_table_of_all_detailed_tables_maxCPM_maxtranscriptlength, junctions_per_gene_constitutive_all_freq, by = "Gene") %>% 
  dplyr::full_join(., junctions_per_gene_all_freq, by = "Gene") %>%
  dplyr::full_join(., junctions_per_gene_AS_plausible_freq, by = "Gene") %>% setNames(., c("Gene", "maxCPM", "maxtranscriptlength", "no_junctions_constitutive", "no_junctions_allsig", "no_junctions_AS_plausible"))

long_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength <- reshape2::melt(wide_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength, 
                                                                                    id = c("Gene", "maxCPM", "maxtranscriptlength"), variable.name = "filteringstep",
                                                                                    value.name = "no_junctions") %>% as_tibble %>% type_convert

# no junctions vs. max junction counts in logCPM

ggplot(long_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength %>% na.omit %>% type_convert) + 
geom_point(aes(y = no_junctions, x = maxCPM)) +
geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_junctions, x = maxCPM)) +
facet_wrap(~filteringstep, scales = "free") +
ggtitle(paste("scatterplot of the number of junctions detected per gene against max. junction counts 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("maximum junction count for a gene (logCPM)") +
ylab("number of (differential) junctions detected") +
theme_bw() +
theme(axis.text.x = element_text(hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_junctioncounts_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_junctioncounts_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 


# no. junctions detected vs. maximum annotated transcript length

ggplot(long_table_numberof_junctions_per_gene_maxCPM_maxtranscriptlength) + 
geom_point(aes(y = no_junctions, x = maxtranscriptlength)) +
geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_junctions, x = maxtranscriptlength)) +
facet_wrap(~filteringstep, scales = "free") +
ggtitle(paste("scatterplot of the number of unique junction structures detected per gene against max. annotated transcipt length 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("maximum annotated transcript length") +
ylab("number of (differential) junctions detected") +
theme_bw() +
theme(axis.text.x = element_text(hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_transcriptlength_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no_junctions_vs_max_transcriptlength_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

## PCA analysis of junction counts per sample (replicate)

read the combined counts in the environment
```{r}

library(Amelia)

list_combined_count_filenames_OBseries <- list.files(path = paste(JUM_diff_dir, sep = "")) %>% .[grep(x = ., pattern = "(.*)__combined_count.txt")] %>% array_tree
vector_combined_count_filenames_OBseries <- list_combined_count_filenames_OBseries %>% unlist
list_of_timepoint_names_OBseries <- vector_combined_count_filenames_OBseries %>% gsub(x = ., pattern = "(.*)__combined_count.txt", replacement = "\\1") %>% array_tree
# list_of_assigned_table_names <- vector_combined_count_filenames %>% gsub(x = ., pattern = "(.*)__combined_count.txt", replacement = "\\1_combined_count_table") %>% array_tree


length(list_combined_count_filenames_OBseries)
length(list_of_timepoint_names_OBseries)

list_of_combined_count_files_OBseries <- purrr::map2(.x = list_combined_count_filenames_OBseries, .y = list_of_timepoint_names_OBseries, .f = ~read.delim(file = paste(JUM_diff_dir, .x, sep = ""), sep = "\t", header = FALSE, na.strings = c("NONE", "NA", "INF", "Inf")) %>% setNames(c("sub_junction_id", paste(.y, "_count", sep = ""))) %>% as_tibble %>% mutate_if(is.factor, as.character))

wide_table_of_all_combined_count_files_OBseries <- purrr::reduce(list_of_combined_count_files_OBseries, dplyr::full_join)

# CHECK FOR MISSING VALUES IN THE COMBINED COUNT TABLE. THERE SHOULD BE NONE.

missmap(wide_table_of_all_combined_count_files_OBseries, pdfstub = paste(qualitycheck_results_dir, "heatmap_missingness_combinedcount_tables.pdf", sep = ""))

# PCA analysis

PCA_combined_count <- prcomp(wide_table_of_all_combined_count_files_OBseries[, 2:ncol(wide_table_of_all_combined_count_files_OBseries)])

# plot standard deviations 

PCA_stdev <- tibble(PC = 1:(PCA_combined_count[["sdev"]] %>% length), stdev = PCA_combined_count[["sdev"]])
PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)

ggplot(PCA_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on JUM combined count", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings <- PCA_combined_count[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings <- add_column(PCA_loadings, timepoint = gsub(x = PCA_loadings$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_loadings <- add_column(PCA_loadings, replicatenumber = gsub(x = PCA_loadings$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count", sep = "")) +
  xlab(paste("PC1 (", PCA_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count", sep = "")) +
  xlab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

# I wonder if filtering for low junction counts improves the clustering

### FILTERING FOR JUNCTIONS WITH AT LEAST 5 REOBS IN ALL 3 REPLICATES OF EACH TIMEPOINT

# generate column partitioning indices (subset every 3 columns for each timepoint made up of 3 replicates)
a <- seq(from = 2, to = wide_table_of_all_combined_count_files_OBseries %>% ncol, by = 3)
b <- seq(from = 4, to = wide_table_of_all_combined_count_files_OBseries %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- apply(wide_table_of_all_combined_count_files_OBseries, MARGIN = 1, FUN = function(X) {purrr::map(c, ~all(X[.x] %>% as.numeric >= 5))})

# logical table to show the junction coordinates which have at least one timepoint which has a sufficient number of mapped read counts.
e <- purrr::map(d, ~any(.x == TRUE))

# filter for juunctions backed by sufficient read counts only
wide_table_of_all_combined_count_files_more_than_5_read_in_at_least_3_samples <- wide_table_of_all_combined_count_files_OBseries[which(e == TRUE), ]

# repeat the PCA plots
# PCA analysis

PCA_combined_count_filtered <- prcomp(wide_table_of_all_combined_count_files_more_than_5_read_in_at_least_3_samples[, 2:ncol(wide_table_of_all_combined_count_files_more_than_5_read_in_at_least_3_samples)])

# plot standard deviations 

PCA_stdev_filtered <- tibble(PC = 1:(PCA_combined_count_filtered[["sdev"]] %>% length), stdev = PCA_combined_count_filtered[["sdev"]])
PCA_variance_filtered <- tibble(PC = PCA_stdev_filtered$PC, variance = PCA_stdev_filtered$stdev ^ 2)
PCA_variance_filtered <- add_column(PCA_variance_filtered, variance_explained = PCA_variance_filtered$variance/sum(PCA_variance_filtered$variance) * 100)

ggplot(PCA_variance_filtered) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count_filtered[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on JUM combined count filtered (> 5 in all replicates each timepoint)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_filtered.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_filtered.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings_filtered <- PCA_combined_count_filtered[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, timepoint = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, replicatenumber = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count filtered (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance_filtered[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_filtered.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_filtered.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count filtered (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance_filtered[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_filtered.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_filtered.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

```


## RUV: removal of unwanted variation in the junction count data

### define packages, paths and functions

```{r}

library(RUVnormalize)

# function to transform a numerical array/matrix/tibble into an RLE plot, assuming genes are given on the y-axis and samples/replicates/timepoints are given on the x axis.

transformRLE <- function(input_array) {
  
  input_array <- log10(input_array)
  
  vec_gene_medians <- apply(X = input_array, MARGIN = 1, FUN = function(X) {median(X)})
  
  RLE_array <- apply(X = input_array, MARGIN = 2, FUN = function(X) {X - vec_gene_medians})
  
  return(RLE_array)
  
}

```


### before normalisation

```{r}

wide_table_of_all_combined_count_files_RLE <- wide_table_of_all_combined_count_files_OBseries

wide_table_of_all_combined_count_files_RLE[, 2:ncol(wide_table_of_all_combined_count_files_RLE)] <- transformRLE(wide_table_of_all_combined_count_files_RLE[, 2:ncol(wide_table_of_all_combined_count_files_RLE)])

long_table_of_all_combined_count_files_RLE <- reshape2::melt(wide_table_of_all_combined_count_files_RLE, value.name = "junction_counts", id = "sub_junction_id", variable.name = "samplename")

ggplot(long_table_of_all_combined_count_files_RLE) +
  geom_boxplot(aes(x = samplename, y = junction_counts)) +
  # ylim(1, 100000) +
  theme_bw() +
  xlab("replicate name")+
  ylab("relative log10 junction counts (RLE)") +
  ggtitle("RLE plot of raw junction counts") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), legend.title.align = 0.5, text = element_text(family ="Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_raw.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_raw.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### RUV

Sort genes by their standard deviation

```{r warning=FALSE}

# Sort genes by their standard deviation

wide_table_of_all_combined_count_files_OBseries <- wide_table_of_all_combined_count_files_OBseries %>% type_convert

# sd <- apply(wide_table_of_all_combined_count_files_OBseries[, 2:ncolwide_table_of_all_combined_count_files_OBseries], 1, FUN = function(X) {sd(X)})

# ssd <- wide_table_of_all_combined_count_files_OBseries[order(sd, decreasing = TRUE), ]

# Cluster the samples

# kmres <- kmeans(ssd[, 2:ncol(ssd)], centers = OBseries_timepoints %>% length, nstart = 200)

# vclust <- kmres$cluster

# Compute the distance between clustering by replicate and clustering obtained by k-means

# uScore <- clScore(ssd[, 2:4], ssd[, 5:7])

```

centering genes by replicate

```{r eval=FALSE, include=FALSE}

ssd_centred <- apply(ssd[, 2:ncol(ssd)], 2, FUN = function(X) {scale(X)}) %>% as_tibble
ssd_centred <- bind_cols(tibble(sub_junction_id = ssd$sub_junction_id), ssd_centred)

ssd_centred_RLE <- ssd_centred
ssd_centred_RLE[, 2:ncol(ssd_centred_RLE)] <- transformRLE(ssd_centred_RLE[, 2:ncol(ssd_centred_RLE)])
tibble_ssd_centred_RLE_long <- reshape2::melt(ssd_centred_RLE, value.name = "junction_counts", id = "sub_junction_id", variable.name = "samplename")

ggplot(tibble_ssd_centred_RLE_long) +
  geom_boxplot(aes(x = samplename, y = junction_counts)) +
  # ylim(1, 100000) +
  xlab("replicate name")+
  ylab("relative log10 junction counts (RLE)") +
  ggtitle("RLE plot of centred junction counts") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), legend.title.align = 0.5, text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_centred.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_centred.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

Naive RUV-2 no shrinkage

```{r}

replicate_rownumbers <- tribble(~rep1, ~rep2, ~rep3,
            1,     2,     3,
            4,     5,     6,
            7,     8,     9,
            10,    11,    12,
            13,    14,    15,
            16,    17,    18,
            19,    20,    21,
            22,    23,    24) %>% as.matrix

nsY <- naiveReplicateRUV(t(wide_table_of_all_combined_count_files_OBseries[, 2:ncol(wide_table_of_all_combined_count_files_OBseries)]), scIdx = replicate_rownumbers, k = 5)

tibble_RUV_wide <- bind_cols(wide_table_of_all_combined_count_files_OBseries[, "sub_junction_id"], t(nsY$cY) %>% as_tibble)

tibble_RUV_wide_RLE <- tibble_RUV_wide
tibble_RUV_wide_RLE[, 2:ncol(tibble_RUV_wide_RLE)] <- transformRLE(tibble_RUV_wide_RLE[, 2:ncol(tibble_RUV_wide_RLE)])
tibble_RUV_RLE_long <- reshape2::melt(tibble_RUV_wide_RLE, value.name = "junction_counts", id = "sub_junction_id", variable.name = "samplename")

ggplot(tibble_RUV_RLE_long) +
  geom_boxplot(aes(x = samplename, y = junction_counts)) +
  # ylim(1, 100000) +
  xlab("replicate name")+
  ylab("relative log10 junction counts (RLE)") +
  ggtitle("RLE plot of RUV junction counts") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), legend.title.align = 0.5, text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "RLE_boxplot_junctioncounts_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

plot PCA

```{r}

# repeat the PCA plots
# PCA analysis

PCA_combined_count_filtered <- prcomp(tibble_RUV_wide[, 2:ncol(tibble_RUV_wide)])

# plot standard deviations 

PCA_stdev_filtered <- tibble(PC = 1:(PCA_combined_count_filtered[["sdev"]] %>% length), stdev = PCA_combined_count_filtered[["sdev"]])
PCA_variance_filtered <- tibble(PC = PCA_stdev_filtered$PC, variance = PCA_stdev_filtered$stdev ^ 2)
PCA_variance_filtered <- add_column(PCA_variance_filtered, variance_explained = PCA_variance_filtered$variance/sum(PCA_variance_filtered$variance) * 100)

ggplot(PCA_variance_filtered) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count_filtered[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on JUM combined count RUV (> 5 in all replicates each timepoint)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_JUM_combined_count_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings_filtered <- PCA_combined_count_filtered[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, timepoint = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_loadings_filtered <- add_column(PCA_loadings_filtered, replicatenumber = gsub(x = PCA_loadings_filtered$sample, pattern = "(BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count RUV (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance_filtered[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_JUM_combined_count_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(PCA_loadings_filtered) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PCA standard deviations based on JUM combined count RUV (> 5 in all replicates each timepoint)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance_filtered[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance_filtered[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_RUV.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_JUM_combined_count_RUV.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### export the normalised combined junction count tables

```{r}

RUV_combined_junction_counts <-  paste(qualitycheck_results_dir, "RUV_combined_junction_counts/", sep = "")

if(! dir.exists(RUV_combined_junction_counts) ) {
     dir.create(RUV_combined_junction_counts, recursive = TRUE)}

wide_tibble_junctioncounts_RUV <- tibble_RUV_wide

# move up the values to prevent negative, then x1000 and round to prevent non-integer values and to minimise relative error when we round

wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)] <- round((wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)] - min(wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)])), digits = 0)

for (timepoint in colnames(wide_tibble_junctioncounts_RUV[, 2:ncol(wide_tibble_junctioncounts_RUV)])) {
  
  write.table(x = wide_tibble_junctioncounts_RUV[, c("sub_junction_id", paste(timepoint))], file = paste(RUV_combined_junction_counts, gsub(x = timepoint, pattern = "(.*)_count", replacement = "\\1__combined_count.txt"), sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
  
}

```

## can we merge the OB series and OB series?? are they comparable??

NOTE: INCOMPLETE. WE NEED TO DO JUM ON ALL THE SAMPLES IN ONE RUN SO IT CAN COMBINE THE JUNCTION COUNTS INTO CONSISTENT IDs

there are missing values so we can use missMDA to impute for PCA

```{r eval=FALSE, include=FALSE}

library(missMDA)

wide_table_of_all_combined_count_files_OBandOBseries <- dplyr::full_join(wide_table_of_all_combined_count_files_OBseries, wide_table_of_all_combined_count_files_OBseries, by = "sub_junction_id")

combined_count_files_OBandOBseries_imputePCA <- estim_ncpPCA(wide_table_of_all_combined_count_files_OBandOBseries, method.cv = "Kfold", verbose = FALSE)



```

# COMBINING GENE EXPRESSION DATA WITH THE SPLICEOMIC DATA HERE

## set environment

set directories

```{r}

# the EXACT path of the file, not its containing directory

logCPM_OBseries_anysig_DEGs_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_2_eRNA/R_processing_results/edgeR_GLM_DEGs_logCPM.txt"

```

define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

## extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

logCPM_OBseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_OBseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_OBseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_OBseries_anysig_DEGs <- dplyr::right_join(ENSG_to_genesymbol_DEGs, logCPM_OBseries_anysig_DEGs_import, by = "ensembl_gene_id") %>% average_counts_from_triplicate(., 2)

# reorder the columns to make them chronological

logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_OB_ud_avg", "logCPM_BM_MSC_to_OB_6h_avg", "logCPM_BM_MSC_to_OB_12h_avg", "logCPM_BM_MSC_to_OB_24h_avg", "logCPM_BM_MSC_to_OB_3d_avg", "logCPM_BM_MSC_to_OB_6d_avg", "logCPM_BM_MSC_to_OB_9d_avg", "logCPM_BM_MSC_to_OB_12d_avg")]

colnames(logCPM_OBseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

# subset CPM table by biological role

  # RBPs
column_RBP_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "RNA binding" | .$name_1006 == "spliceosomal complex", "ensembl_gene_id"]

logCPM_OBseries_RBP <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_RBP_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "RBP", .$ensembl_gene_id, sep = "_"), .after = 2)

  # lncRNA
column_lncRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("lncRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble

logCPM_OBseries_lncRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_lncRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "lncRNA", .$ensembl_gene_id, sep = "_"), .after = 2)

  # snRNA
column_snRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("snRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble %>% mutate_if(is.logical, as.character)

logCPM_OBseries_snRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_snRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "snRNA", .$ensembl_gene_id, sep = "_"), .after = 2)

  # all TF complex 
column_TFcomplex_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "transcription factor complex", "ensembl_gene_id"]

logCPM_OBseries_TFcomplex <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_TFcomplex_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., AS_event_ID = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", isoform_ID = paste("RNASeq", "TF_complex", .$ensembl_gene_id, sep = "_"), .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_OBseries_subset <- dplyr::bind_rows(logCPM_OBseries_RBP, logCPM_OBseries_lncRNA, logCPM_OBseries_snRNA, logCPM_OBseries_TFcomplex)

# get rid of ENSG id
logCPM_OBseries_subset <- logCPM_OBseries_subset[, -1]

# rename column before next join

colnames(logCPM_OBseries_subset)[1] <- "Gene"

# add isoform_number to prevent NA

logCPM_OBseries_subset <- add_column(logCPM_OBseries_subset, "isoform_number" = 1)

# combine logCPM and PSI values
tibble_combinedexpr_logCPM_PSI_unscaled <- dplyr::bind_rows(PSI_levels_timeseries_OB_wide %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character), logCPM_OBseries_subset) 

```

## consensus re-clustering of combined expression and PSI data

```{r}

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7)
ydim_range_combinedexpr <- c(8, 9, 10, 11, 6, 7, 8, 5, 6, 7, 4, 5, 4)

som_seed_number <- 7

# OB series #####

tibble_combinedexpr_logCPM_PSI_scaled <- tibble_combinedexpr_logCPM_PSI_unscaled

tibble_combinedexpr_logCPM_PSI_scaled[, 6:ncol(tibble_combinedexpr_logCPM_PSI_scaled)] <- tibble_combinedexpr_logCPM_PSI_unscaled[, 6:ncol(tibble_combinedexpr_logCPM_PSI_unscaled)] %>% genescale(m = ., axis = 1, method = "Z")

# LAST TIME ENSEMBL CHANGED HALFWAY THRU THE ANALYSIS. IM NOT REPEATING THAT MISTAKE AGAIN

write.table(tibble_combinedexpr_logCPM_PSI_scaled, paste(results_directory_figures, "tibble_combinedexpr_logCPM_PSI_scaled_GRCh38.98.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = TRUE)

tibble_combinedexpr_logCPM_PSI_scaled <- read_delim(paste(results_directory_figures, "tibble_combinedexpr_logCPM_PSI_scaled_GRCh38.98.txt", sep = ""), delim = "\t")

set.seed(som_seed_number)

wide_table_combinedexpr_som_sweep_clusters <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~som(tibble_combinedexpr_logCPM_PSI_scaled[, 6:ncol(tibble_combinedexpr_logCPM_PSI_scaled)] %>% as.matrix, grid = somgrid(xdim = .x, ydim = .y, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)) %>% purrr::reduce(bind_cols)

wide_table_combinedexpr_som_sweep_clusters <- wide_table_combinedexpr_som_sweep_clusters %>% as.data.frame

rownames(wide_table_combinedexpr_som_sweep_clusters) <- paste(tibble_combinedexpr_logCPM_PSI_scaled$Gene, "_", tibble_combinedexpr_logCPM_PSI_scaled$isoform_ID, sep = "")


list_matchtest_combinedexpr_som_sweep_byisoform <- purrr::map(wide_table_combinedexpr_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% purrr::map(.f = ~apply(X = wide_table_combinedexpr_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}))

list_percentage_consensus_byisoform_combinedexpr <- purrr::map(list_matchtest_combinedexpr_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble)

# tibble_consensus_matrix_combinedexpr <- purrr::reduce(list_percentage_consensus_byisoform_combinedexpr, bind_rows)

tibble_consensus_matrix_combinedexpr <- list_percentage_consensus_byisoform_combinedexpr %>% rbindlist

matrix_consensus_matrix_combinedexpr <- tibble_consensus_matrix_combinedexpr %>% as.matrix

rownames(matrix_consensus_matrix_combinedexpr) <- names(list_percentage_consensus_byisoform_combinedexpr)

## HOOOOOOOLY SHIT RBINDLIST IS SO QUICK ##########
# WE DONT EVEN NEED THIS
# write.table(tibble_consensus_matrix_combinedexpr, paste(results_directory_figures, "tibble_consensus_matrix_combinedexpr.txt", sep = ""), sep = "\t", row.names = TRUE, quote = FALSE, col.names = TRUE)



# reorder rows of consensus matrix

matrix_consensus_matrix_combinedexpr_dist_result <- matrix_consensus_matrix_combinedexpr %>% Rfast::Dist(method = "euclidean") %>% as.dist
matrix_consensus_matrix_combinedexpr_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_combinedexpr_dist_result, method = "ward.D2")
matrix_consensus_matrix_combinedexpr_consensus_dendrogram <- as.dendrogram(matrix_consensus_matrix_combinedexpr_hclust_result)
# cols/rows should get darker as you move right/down
matrix_consensus_matrix_combinedexpr_rowmeans <- rowMeans(matrix_consensus_matrix_combinedexpr, na.rm = T)
# matrix_consensus_matrix_combinedexpr_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix_combinedexpr) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_combinedexpr_singular_vectors_byrow <- apply(matrix_consensus_matrix_combinedexpr, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered <- reorder(matrix_consensus_matrix_combinedexpr_consensus_dendrogram, matrix_consensus_matrix_combinedexpr_rowmeans)

ggdendrogram(matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered) +
  xlab("Gene/isoform") +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "dendrogram_som_consensus_matrix_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered_order <- matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered %>% unlist
 
matrix_consensus_matrix_combinedexpr_reordered <- matrix_consensus_matrix_combinedexpr[matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered_order, matrix_consensus_matrix_combinedexpr_consensus_dendrogram_reordered_order] %>% as_tibble(rownames = "gene_isoform_ID")
 
tibble_consensus_matrix_combinedexpr_long <- reshape2::melt(matrix_consensus_matrix_combinedexpr_reordered, id = c("gene_isoform_ID"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_if(is.factor, as.character)

write.table(x = matrix_consensus_matrix_combinedexpr_reordered, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

ggplot(tibble_consensus_matrix_combinedexpr_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("OBseries consensus matrix for som of ", nrow(PSI_levels_timeseries_OB_wide), " isoforms, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID) +
  scale_y_discrete(breaks = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID) +
  scale_fill_gradientn(colours = c("blue", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".tiff", sep = ""), device = "tiff", dpi = 1200, width = 40, height = 25, units = "cm", limitsize = FALSE)

write.table(x = tibble_consensus_matrix_combinedexpr_long, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

ggplot(tibble_consensus_matrix_combinedexpr_long[1, ], aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("OBseries consensus matrix for som of ", nrow(PSI_levels_timeseries_OB_wide), " isoforms, ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexs", " (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, labels = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID, limits = matrix_consensus_matrix_combinedexpr_reordered$gene_isoform_ID) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black"), values = c(0, 0.33, 0.67, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 1, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 1, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_directory_figures, "xlabs_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".pdf", sep = ""), device = "pdf", dpi = 400, width = 200, height = 10, units = "cm", limitsize = FALSE)

```

cluster determination from consensus matrix

```{r message=FALSE, warning=FALSE}

tibble_consensus_matrix_combinedexpr_long <- read_delim(paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), delim = "\t")

list_genes_or_isoforms_from_combinedexpr <- tibble_consensus_matrix_combinedexpr_long$variable %>% unique %>% array_tree

# testing purposes only 

# list_genes_or_isoforms_from_combinedexpr <- list_genes_or_isoforms_from_combinedexpr[c(1:50, 1000:1050)]

list_genes_or_isoforms_from_combinedexpr_cooccuring <- purrr::map(.x = list_genes_or_isoforms_from_combinedexpr, .f = ~tibble_consensus_matrix_combinedexpr_long[tibble_consensus_matrix_combinedexpr_long$variable == .x & tibble_consensus_matrix_combinedexpr_long$cocluster_percentage >= 0.5, "gene_isoform_ID"])

names(list_genes_or_isoforms_from_combinedexpr_cooccuring) <- list_genes_or_isoforms_from_combinedexpr

# take pairwise intersections

comparisons_genes_or_isoforms_from_combinedexpr <- combn(list_genes_or_isoforms_from_combinedexpr %>% unlist, m = 2) %>% t %>% as_tibble

colnames(comparisons_genes_or_isoforms_from_combinedexpr) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection

list_comparison_1 <- comparisons_genes_or_isoforms_from_combinedexpr %>% .[, 1] %>% array_tree %>% flatten

list_comparison_2 <- comparisons_genes_or_isoforms_from_combinedexpr %>% .[, 2] %>% array_tree %>% flatten

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection <- purrr::map2(.x = list_comparison_1, .y = list_comparison_2, .f = ~dplyr::intersect(list_genes_or_isoforms_from_combinedexpr_cooccuring[[.x]], list_genes_or_isoforms_from_combinedexpr_cooccuring[[.y]]) %>% nrow) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff <- purrr::map2(.x = list_comparison_1, .y = list_comparison_2, .f = ~dplyr::setdiff(list_genes_or_isoforms_from_combinedexpr_cooccuring[[.x]], list_genes_or_isoforms_from_combinedexpr_cooccuring[[.y]]) %>% nrow)  %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- bind_cols(comparisons_genes_or_isoforms_from_combinedexpr %>% as_tibble, list_genes_or_isoforms_from_combinedexpr_itemwise_intersection[, 1], list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff[, 1])

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- add_column(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, "jaccard" = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_intersection/(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_setdiff + list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_intersection))

write.table(x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, file = paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")


list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3 <- list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2[list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2$coclustering_intersection > 0, ]

plot(density(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3$coclustering_intersection %>% as.numeric))

write.table(x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3, file = paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_intersection1_consensus0.5.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

```{r}

########### GO TO CYTOSCAPE HERE ###################

tibble_combinedexpr_logCPM_PSI_scaled_2 <- bind_cols(tibble_combinedexpr_logCPM_PSI_scaled, gene_isoform_ID = paste(tibble_combinedexpr_logCPM_PSI_scaled$Gene, "_", tibble_combinedexpr_logCPM_PSI_scaled$isoform_ID, sep = ""))

cytoscape_result <- read_delim(paste(results_directory_figures, "consensus_combinedexpr_intersection1_min25_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab", sep = ""), delim = "\t", col_names = c("cluster", "gene_isoform_ID"))

cytoscape_result[, "cluster"] <- gsub(x = cytoscape_result$cluster, pattern = "Cluster ", replacement = "") %>% as.numeric

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = cytoscape_result$cluster %>% unique, .f = ~cytoscape_result[cytoscape_result$cluster == .x, ])

# bind the standardised PSI information to the cluster information
list_combinedexpr_logCPM_PSI_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, tibble_combinedexpr_logCPM_PSI_scaled_2, by = "gene_isoform_ID"))

wide_table_combinedexpr_logCPM_PSI_scaled_clustered <- list_combinedexpr_logCPM_PSI_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

# reorder columns
wide_table_combinedexpr_logCPM_PSI_scaled_clustered <- wide_table_combinedexpr_logCPM_PSI_scaled_clustered[, c("Gene", "AS_event_ID", "splicemode", "isoform_number", "isoform_ID", "gene_isoform_ID", "MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d", "cluster")]

```

### generate expression profile map

the goal of this is to get extract timepoint PSI tables according to each consensus cluster

```{r}

# reorder the cluster factor for correct facet order

wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster <- factor(wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster %>% mixedsort, levels = wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster %>% unique %>% mixedsort)

### convert the som table to a long form interprable by ggplot

# reshaping into long table

long_table_combinedexpr_logCPM_PSI_scaled_clustered <- reshape2::melt(wide_table_combinedexpr_logCPM_PSI_scaled_clustered, id.vars = c("Gene", "AS_event_ID", "splicemode", "isoform_ID", "gene_isoform_ID", "cluster", "isoform_number"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# ggplot of consensus som PSI profiles

ggplot(long_table_combinedexpr_logCPM_PSI_scaled_clustered, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = gene_isoform_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of ", nrow(PSI_levels_timeseries_OB_wide), " isoforms, ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " (any ", p_or_q_value, qpvalue_cutoff, " dPSI greaterthan ", dPSI_cutoff, "), 
                sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Scaled PSI or logCPM Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_combinedexpr_logCPM_PSI_scaled_clustered, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### GO term, family and RBP target enrichment

##### GO term

```{r}

# OB series #####

list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_all <- purrr::map(.x = list_combinedexpr_logCPM_PSI_scaled_clustered
                                                          , .f = ~.x$Gene %>% as.vector %>% unique)

list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly <- purrr::map(.x = list_combinedexpr_logCPM_PSI_scaled_clustered
                                                          , .f = ~.x[.x$splicemode != "RNASeq", "Gene"] %>% unlist %>% as.vector %>% unique)

number_of_consensus_combinedexpr_clusters <- wide_table_combinedexpr_logCPM_PSI_scaled_clustered$cluster %>% unique %>% length

# let's try to do all enrichment at once using purrr

list_of_combinations_of_consensus_combinedexpr_genes_and_GOterms <- cross2(.x = list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly, .y = list("MF", "BP", "CC"))

# note: each element will be [[1]]: gene set, [[2]]: GO term to query

list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables <- purrr::map(.x = list_of_combinations_of_consensus_combinedexpr_genes_and_GOterms, .f = ~GOHyperGAll(catdb = catdb, gocat = .x[[2]], Nannot = 2, sample = .x[[1]]) %>% GOHyperGAll_benjamini_correction)

list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map(.x = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables, ~.[order(.$Padj, decreasing = FALSE), ] %>% head(n = 10))

list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten <- purrr::map2(.x = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten, .y = 1:number_of_consensus_combinedexpr_clusters %>% rep(., times = 3) %>% as.list, .f = ~cbind(.x, "cluster" = .y) %>% as_tibble)

list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2 <- list(
  "MF" = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten[1:number_of_consensus_combinedexpr_clusters] %>% purrr::reduce(bind_rows), 
  "BP" = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten[(number_of_consensus_combinedexpr_clusters + 1):(number_of_consensus_combinedexpr_clusters*2)] %>% purrr::reduce(bind_rows),
  "CC" = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten[((2*number_of_consensus_combinedexpr_clusters) + 1):(number_of_consensus_combinedexpr_clusters*3)] %>% purrr::reduce(bind_rows)) %>% purrr::map(~type_convert(.x))

# cheeky ggplot

purrr::map2(.x = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented", .y, "GO terms for each consensus cluster of PSI and select gene expression combined")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y, "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y, "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2, .y = names(list_of_OBseries_consensus_combinedexpr_hyperGOresult_allGO_clusterwise_tables_topten_2), .f = ~write.table(x = .x, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y, "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

##### family enrichment

```{r}

list_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables <- purrr::map(.x = list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables) <- 1:number_of_consensus_combinedexpr_clusters

list_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten <- purrr::map2(.x = list_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables, .y = 1:number_of_consensus_combinedexpr_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten <- purrr::reduce(.x = list_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten, .f = bind_rows) %>% type_convert

# ggplot

ggplot(wide_table_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten, aes(x = reorder(TermID, padj), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster of PSI and select gene expression combined")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("PFAM family") +
  ylab("Number of genes in family and in cluster") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm")

write.table(x = wide_table_of_OBseries_consensus_combinedexpr_familyenrichment_clusterwise_tables_topten, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

##### RBP target enrichment

```{r}

list_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables <- purrr::map(.x = list_of_timeseries_logCPM_PSI_genes_by_consensus_cluster_diffsplicedonly, .f = ~enrichment(genes = .x, reference = reference_geneset, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble)

names(list_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables) <- 1:number_of_consensus_combinedexpr_clusters

list_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten <- purrr::map2(.x = list_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables, .y = 1:number_of_consensus_combinedexpr_clusters, .f = ~.x[order(.x$padj, decreasing = FALSE), ] %>% head(n = 10) %>% cbind(., cluster = .y) %>% as_tibble)

# bind rows and calculate ggplot facet x and y coordinates
wide_table_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten <- purrr::reduce(.x = list_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten, .f = bind_rows) %>% type_convert

# ggplot

ggplot(wide_table_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten, aes(x = reorder(TermID, pval), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each CONSENSUS cluster in OB series")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 3)) +
  xlab("Upstream RBP with literature reference") +
  ylab("Number of genes enriched amongst RBP target genes") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm")

write.table(x = wide_table_of_OBseries_consensus_combinedexpr_RBPenrichment_clusterwise_tables_topten, file = paste(results_directory_figures, "som_consensus_matrix_combinedexpr_", number_of_consensus_combinedexpr_clusters, "_clusters_",  nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```
