---
title: "Downstream processing of PSI-Sigma analysis results (OBseries)"
author: "Angel Liang"
date: "02/03/2020"
output: html_document
---

# A note on table processing:

## The tables are sequentially filtered at each step in order to gather useful information. The scheme is as follows:

ALL TABLES (RAW) ----> Wide table of absolute PSI (no NA at all) (n = 3) ----> PCA
|
Filter out unreliable timepoints with less than 2 observations (n >= 2)
|
v
Long table of all comparisons (has NA/timepoint, replicate) ----> Differential exons (with na)
|
v
Wide table of absolute PSI with any na (using MSC) - (separate/sum) -----> Exon switching
|
v
Wide table of absolute PSI (complete timepoints) - (separate/sum) -----> SOM
u

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)
library(data.table)

library(genefilter)

# library(future.apply)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)

library(rtracklayer)
library(qualV)

library(ggplot2)
library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
# library(svglite)
# library(scales)
library(ComplexHeatmap)

library(biomaRt)
ensembl_mart <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 98)

library(systemPipeR)
# library(GOstats)
library(PFAM.db)
# library(bc3net)
# 
# library(ggdendro)
# library(Rfast)

shared_dir <- "/mnt/Tertiary/sharedfolder/"
# shared_dir <- "Z:/"

# psisigma_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/"
psisigma_results_dir <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/"

# R_processing_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/"
R_processing_results_dir <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/"

if(! dir.exists(R_processing_results_dir) ) {
  dir.create(R_processing_results_dir, recursive = TRUE)}

vector_OBseries_timepoints_raw <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")
vector_OBseries_timepoints_edited <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

# vector_of_comparisons_final <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/list_of_timepoint_comparisons_final.txt", sep = "\t", header = FALSE, stringsAsFactors = FALSE) %>% unlist
vector_of_comparisons_final <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/list_of_timepoint_comparisons_final.txt", sep = "\t", header = FALSE, stringsAsFactors = FALSE) %>% unlist

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_NMD_classifier/results/Homo_sapiens.GRCh38.98_NMD_PTC_E4.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_NMD_classifier/results/alltimepoints_denovo_reconstructed_stringtiemerged_NMD_PTC_E4.gtf") %>% as_tibble

```

## define functions

Enrichment/Gene Ontology

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

```

```{r}

# FUNCTION to extract the information from matched GTF entries.
# input: a list containing ref + recon GTF entries, a single element of a list of all the matches for each exon.
# things to annotate: gene name, strand, all exons are NMD in the reference GTF, first/last/only exon in reference or recon. GTF

annotate_differential_exon <- function(list_matched_ref_recon_gtf) {
  
  # print(paste("now processing junction number", index))
  
  # DEBUG ######
  
  # list_matched_ref_recon_gtf <- list_ref_matching_exon_entries_IR[[1]]
  
  ##############
  
  # gene name
  matched_gene_names <- NA
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      matched_gene_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$gene_name %>% unique, collapse = ",")
      
    }
    
  }
  
  # transcript name (ref)
  matched_ref_transcript_names <- NA
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      matched_ref_transcript_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$transcript_id %>% unique, collapse = ",")
      
    }
    
  }
  
  # transcript name (recon)
  matched_recon_transcript_names <- NA
  
  if (length(list_matched_ref_recon_gtf$reconstructed_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
      
      matched_recon_transcript_names <- paste(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$transcript_id %>% unique, collapse = ",")
      
    }
    
  }
  
  # strand - match the ref GTF first before going to the recon. GTF
  matched_strand <- NA
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      if (length(list_matched_ref_recon_gtf[["reference_gtf_match"]]$strand %>% unique) == 1) {
        
        matched_strand <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$strand %>% unique)
        
      }
      
    }
    
  } else if (length(list_matched_ref_recon_gtf$reconstructed_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
      
      if (length(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$strand %>% unique) == 1) {
        
        matched_strand <- paste(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$strand %>% unique)
        
      }
      
    }
    
  }
  
  # KNOWN NMD annotation - reference
  NMD_biotype_reference <- FALSE
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      if (all(list_matched_ref_recon_gtf[["reference_gtf_match"]]$transcript_biotype == "nonsense_mediated_decay")) {
        
        NMD_biotype_reference <- TRUE 
        
      }
      
    }
    
  }
  
  # flagged NMD candidates - reference
  NMD_flagged_ref <- FALSE
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      if (all(list_matched_ref_recon_gtf[["reference_gtf_match"]]$NMD_candidate == TRUE)) {
        
        NMD_flagged_ref <- TRUE 
        
      }
      
    } 
    
  }
  
  # flagged NMD candidates - recon
  NMD_flagged_recon <- FALSE
  
  if (length(list_matched_ref_recon_gtf$reconstructed_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
      
      if (all(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$NMD_candidate == TRUE)) {
        
        NMD_flagged_recon <- TRUE 
        
      }
      
    } 
    
  }
  
  # PTC-containing exons or poison exon candidates - reference and recon
  poison_exon_candidate_ref <- NA
  poison_exon_candidate_recon <- NA
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      poison_exon_candidate_ref_temp <- list_matched_ref_recon_gtf[["reference_gtf_match"]]$poison_exon_candidate %>% unique 
      
      if (any(is.na(poison_exon_candidate_ref_temp)) != TRUE) {
        
        poison_exon_candidate_ref <- TRUE
        
      }
      
    }
    
  }
  
  if (length(list_matched_ref_recon_gtf$reconstructed_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
      
      poison_exon_candidate_ref_temp <- list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$poison_exon_candidate %>% unique 
      
      if (any(is.na(poison_exon_candidate_ref_temp)) != TRUE) {
        
        poison_exon_candidate_recon <- TRUE
        
      }
      
    }
    
  }
  
  contains_PTC_ref <- NA
  contains_PTC_recon <- NA
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      contains_PTC_ref_temp <- list_matched_ref_recon_gtf[["reference_gtf_match"]]$contains_PTC %>% unique 
      
      if (any(is.na(contains_PTC_ref_temp)) != TRUE) {
        
        contains_PTC_ref <- TRUE
        
      }
      
    }
    
  }
  
  if (length(list_matched_ref_recon_gtf$reconstructed_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
      
      contains_PTC_recon_temp <- list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$contains_PTC %>% unique 
      
      if (any(is.na(contains_PTC_recon_temp)) != TRUE) {
        
        contains_PTC_recon <- TRUE
        
      }
      
    }
    
  }
  
  # first/last/only exon - reference and recon
  first_or_last_exon_reference <- NA
  
  if (length(list_matched_ref_recon_gtf$reference_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
      
      first_or_last_exon_reference_temp <- list_matched_ref_recon_gtf[["reference_gtf_match"]]$first_or_last_exon %>% unique 
      
      if (all(is.na(first_or_last_exon_reference_temp)) != TRUE) {
        
        first_or_last_exon_reference <- first_or_last_exon_reference_temp %>% na.omit %>% paste(collapse = ",")
        
      }
      
    }
    
  }
  
  first_or_last_exon_recon <- NA
  
  if (length(list_matched_ref_recon_gtf$reconstructed_gtf_match) != 0) {
    
    if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
      
      first_or_last_exon_recon_temp <- list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$first_or_last_exon %>% unique 
      
      if (all(is.na(first_or_last_exon_recon_temp)) != TRUE) {
        
        first_or_last_exon_recon <- first_or_last_exon_recon_temp %>% na.omit %>% paste(collapse = ",")
        
      }
      
    }
    
  }
  
  return(purrr::splice(list_matched_ref_recon_gtf[-which(names(list_matched_ref_recon_gtf) %in% c("reference_gtf_match", "reconstructed_gtf_match"))],
                       "matched_gene_names" = matched_gene_names,
                       "matched_strand" = matched_strand,
                       "matched_ref_transcript_names" = matched_ref_transcript_names,
                       "matched_recon_transcript_names" = matched_recon_transcript_names,
                       "NMD_biotype_reference" = NMD_biotype_reference,
                       "NMD_flagged_ref" = NMD_flagged_ref,
                       "NMD_flagged_recon" = NMD_flagged_recon,
                       "poison_exon_candidate_ref" = poison_exon_candidate_ref,
                       "poison_exon_candidate_recon" = poison_exon_candidate_recon,
                       "contains_PTC_ref" = contains_PTC_ref,
                       "contains_PTC_recon" = contains_PTC_recon,
                       "first_or_last_exon_reference" = first_or_last_exon_reference,
                       "first_or_last_exon_recon" = first_or_last_exon_recon
  ))
  
}
  
```

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# details of ONE junction: $chr, $start, $end, $strand
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons <- function(query_chr, query_start, query_end, query_strand, tibble_gtf_table, tolerance_left = 1, tolerance_right = 1, tolerance_inside = 1, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon") {
  
  # DEBUG ###################
  
  # query_chr = a1$chr %>% type.convert
  # query_start = a1$event_region_start %>% type.convert
  # query_end = a1$event_region_end %>% type.convert
  # query_strand = "*"
  # tibble_gtf_table = tibble_ref_gtf
  # tolerance_left = 0
  # tolerance_right = 0
  # tolerance_inside = 0
  # tolerance_outside = 0
  # match_consecutive = FALSE
  # return_type = "exon"
  
  ###########################
  
  # print(paste("now processing junction number", index))
  
  if (query_strand == "." | query_strand == 0 | query_strand == "*") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% .[.$start <= ((query_end %>% as.numeric) + 1 + tolerance_outside + tolerance_left) & .$end >= ((query_start %>% as.numeric) - 1 - tolerance_outside - tolerance_left), ] %>% .[!(.$start <= ((query_end %>% as.numeric) - tolerance_inside - tolerance_right) & .$end >= ((query_start %>% as.numeric) + tolerance_inside + tolerance_left)), ] %>% .[.$type %in% return_type, ]
    
  } else if (query_strand == "+" | query_strand == "-") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% .[.$strand == query_strand %>% trimws, ] %>% .[.$start <= ((query_end %>% as.numeric) + 1 + tolerance_right) & .$end >= ((query_start %>% as.numeric) - 1 - tolerance_left), ] %>% .[!(.$start <= ((query_end %>% as.numeric) - tolerance_inside - tolerance_right) & .$end >= ((query_start %>% as.numeric) + tolerance_inside + tolerance_left)), ] %>% .[.$type %in% return_type, ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks a junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
  
  if (match_consecutive == TRUE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
    
  } else if (match_consecutive == FALSE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2)
    
  }
  
  return(list_of_tibbles_flanking_exon_gtf.entries_per_transcript)
  
}

# END extract_junction.flanking.exons_JUM() ###

```

```{r}

# FUNCTION TO EXTRACT REFERENCE EXONS WHICH OVERLAP EXACTLY WITH QUERY EXONS
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $chr, $diff_exon_start, $diff_exon_end
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_overlapping.exons <- function(query_chr, query_start, query_end, query_strand, tibble_gtf_table, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon") {

  # DEBUG ###################
  # index <- 1
  # spliceregion_list <- wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_not_IR[[index]]
  # # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_recon_gtf
  # stranded = FALSE
  ###########################

  # print(paste("now processing junction number", index))
  
  if (query_strand == "." | query_strand == 0 | query_strand == "*") {
    
    # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% 
      .[which(.$start > ((query_start %>% as.numeric) - 1 - tolerance_left - tolerance_outside) & .$end < ((query_end %>% as.numeric) + 1 + tolerance_right + tolerance_outside)), ] %>% 
      .[which((.$start < ((query_start %>% as.numeric) + 1 + tolerance_left + tolerance_inside) & .$end > ((query_end %>% as.numeric) - 1 - tolerance_right - tolerance_inside))), ] %>% 
      .[which(.$type == return_type), ]
    
  } else if (query_strand == "+" | query_strand == "-") {
    
    # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws &
                                                              tibble_gtf_table$strand == query_strand %>% trimws, ] %>% 
      .[which(.$start > ((query_start %>% as.numeric) - 1 - tolerance_left - tolerance_outside) & .$end < ((query_end %>% as.numeric) + 1 + tolerance_right + tolerance_outside)), ] %>% 
      .[which((.$start < ((query_start %>% as.numeric) + 1 + tolerance_left + tolerance_inside) & .$end > ((query_end %>% as.numeric) - 1 - tolerance_right - tolerance_inside))), ] %>% 
      .[which(.$type == return_type), ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  return(tibble_gtf_subset_overlapping_exons)
  
}

```

```{r}

# FUNCTION TO EXTRACT COMMON STRING FROM TWO INPUT STRINGS IN ONE STEP, A SIMPLIFICATION OF QUALV

extract_common_string <- function(input_string_a, input_string_b) {
  
  # debug ###
  # 
  # input_string_a <- "ud_absolute.psi_1"
  # input_string_b <- "ud_absolute.psi_2"
  
  ###########
  
  vector_of_letters_a <- strsplit(input_string_a, "") %>% unlist
  vector_of_letters_b <- strsplit(input_string_b, "") %>% unlist 

  raw_LCS <- qualV::LCS(vector_of_letters_a, vector_of_letters_b)
  vector_common_string <- raw_LCS$LCS %>% paste(collapse = "")
  
  return(vector_common_string)
    
}

# END extract_common_string()

# FUNCTION TO TAKE THE AVERAGE VALUE OF A MATRIX OF TIMEPOINTS WITH THREE REPLICATES EACH (3 column compartments at a time)
## replicates of the same timepoint must be all grouped together.
calculate_average_values_from_replicate_columns <- function(input_matrix, number_of_replicates, append_average_to_column_name = TRUE) {
  
  # DEBUG ######
  
  # input_matrix <- wide_tibble_of_psisigma_results_allcomparisons_final_ud.only[, col_indices_observations]
  # number_of_replicates <- 3
  
  ##############
  
  # sanity check - if the number of columns is not an integer multiple of the number of replicates, there's something wrong
  if (ncol(input_matrix) %% number_of_replicates != 0) {
    
    stop("the number of columns in the matrix is not an integer multiple of the number of replicates specified. please check the matrix and try again.")
    
  }
  
  # get the row numbers to subset
  ## start of each compartment
  a <- seq(1, (ncol(input_matrix) - number_of_replicates + 1), number_of_replicates)
  ## end of each compartment
  b <- seq(number_of_replicates, ncol(input_matrix), number_of_replicates)
  # create list of compartments
  c <- purrr::map2(.x = a, .y = b, .f = ~.x:.y)
  # map each column into each compartment
  d <- purrr::map(.x = c, .f = ~input_matrix[, .x])
  # apply the average
  e <- purrr::map(.x = d, .f = ~apply(X = .x, MARGIN = 1, FUN = function(X){mean(X, na.rm = TRUE)}))
  # retrieve the column names of each compartment
  column_names <- purrr::map(.x = d, .f = ~colnames(.x) %>% purrr::reduce(extract_common_string))
  
  if (append_average_to_column_name == TRUE) {
    
    column_names <- paste(column_names, "average", sep = "")
    
  }
  
  # reframe into tibble, return
  f <- e %>% set_names(column_names) %>% as_tibble
  
}

# END calculate_average_values_from_replicate_columns()

```

### FUNCTION TO PLOT PCA FOR TIMEPOINT AND REPLICATE

```{r}

plot_PCA_for_timepoint_and_replicate <- function(matrixtable, timepoint_order = NULL, replicate_order = NULL, PCA_depths_y = NULL, PCA_depths_x = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL, width = 10, height = 10) {
  
  # DEBUG ###
  # save_dir <- R_processing_results_dir
  # save_name <- "raw_MQ_intensities"
  # 
  # graph_title <- paste(.y[[1]], "\n", .y[[2]], sep = "")
  # 
  # timepoint_order <- c("ud_1_24", "ud_30_6", "30m", "1h", "6h", "1d")
  # replicate_order <- vector_replicate_names
  # 
  # PCA_depths_y <- c(2, 3, 4)
  # PCA_depths_x <- c(1, 2, 3)
  ###########
  
  PCA_result <- prcomp(matrixtable)
  
  ## measure PC variance #
  PCA_stdev <- tibble("PC" = 1:(PCA_result[["sdev"]] %>% length), "stdev" = PCA_result[["sdev"]])
  
  PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
  PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)
  
  ggplot(PCA_variance) + 
    geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
    scale_fill_gradientn(colours = heat.colors(n = (PCA_result[["sdev"]] %>% length))) +
    ggtitle(paste("PCA variance distribution\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("PC") +
    ylab("Variance explained (%)") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")
  
  ## measure PC loadings #
  ## column names of the matrix need to be split by a "|", like this: timepoint|replicatenumber
  PCA_loadings <- PCA_result[["rotation"]] %>% as_tibble(rownames = "sample")
  PCA_loadings <- add_column(PCA_loadings, "timepoint" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1") %>% factor(x = ., levels = timepoint_order))
  PCA_loadings <- add_column(PCA_loadings, "replicatenumber" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2") %>% factor(x = ., levels = replicate_order))
  
  # plot PCA for multiple depths all in one go.
  purrr::map2(.y = PCA_depths_y, .x = PCA_depths_x, .f = function(.y, .x) {
    
    pc_y <- .y
    pc_x <- .x
    
    ggplot(PCA_loadings) + 
      geom_point(aes(y = !!(paste("PC", pc_y, sep = "") %>% as.name), x = !!(paste("PC", pc_x, sep = "") %>% as.name), shape = replicatenumber, color = timepoint, size = 2)) +
      # scale_fill_gradientn(name = "Timepoint", colours = rainbow(n = (PCA_loadings %>% nrow))) +
      scale_color_brewer(name = "Timepoint", palette = "Spectral", breaks = timepoint_order, limits = timepoint_order) +
      scale_shape_discrete(name = "Replicate") +
      ggtitle(paste("PCA loadings\n", graph_title, sep = "")) +
      guides(size = FALSE) + 
      xlab(paste("PC", pc_x, " (", PCA_variance[pc_x, "variance_explained"] %>% signif(3), "%)", sep = "")) +
      ylab(paste("PC", pc_y, " (", PCA_variance[pc_y, "variance_explained"] %>% signif(3), "%)", sep = "")) +
      theme_bw() +
      theme(text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".pdf", sep = ""), device = "pdf", dpi = 600, width = width, height = height, units = "cm") +
      ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".svg", sep = ""), device = "svg", dpi = 600, width = width, height = height, units = "cm")
    
  } )
  
}

```

### functions for transcript and domain matching

```{r}

# this will take the result of genomic-to-protein mapping (i.e. ENSP ids) and feed it through biomart. The result is a list of protein domain accessions/ids that overlap (AT THE MOMENT FULL OVERLAP ONLY) with the query interval
# expected input: a list of lists. max level = 2.
# NOTE2: COLUMNS EXPECTED: $1 (ENSP) "names", $2 "start", $3 "width", $4 "end"

tibble_of_mapped_protein_positions_to_list_of_domains_PTMs <- function(list_of_mapped_proteinID, ensemblmart) {
  
  # DEBUG ###
  # list_of_mapped_proteinID <- mapped_aminoacid_positions
  ###########
  
  # extract all query ENSP ids
  vec_all_ENSP_ids <- list_of_mapped_proteinID %>% flatten %>% rbindlist %>% .$names
  
  # create a list of attributes to retrieve from biomart. we will loop thru this.
  list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                         "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                         "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                         "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                         "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                         "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                         "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))
  
  # search biomart
  list_biomart_result_per_attribute <- future_map(.x = list_of_attributes_to_retrieve, .f = ~getBM(filters = "ensembl_peptide_id", values =  vec_all_ENSP_ids %>% unique, attributes = .x, mart = ensemblmart), .progress = TRUE, .options = future_options(globals = c("vec_all_ENSP_ids", "getBM", "ensemblmart")))
  
  # remove na values from biomart result
  list_biomart_result_per_attribute_processed <- purrr::map(.x = list_biomart_result_per_attribute, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_biomart_result_per_attribute[[1]]
    ###########
    
    tibble_of_single_attribute <- .x %>% as_tibble
    
    # fetch na or blank row indices
    row.indices_na_values <- tibble_of_single_attribute %>% apply(MARGIN = 1, FUN = function(X) {any(is.na(X) == TRUE | X == "")}) %>% which
    tibble_of_single_attribute <- tibble_of_single_attribute[-row.indices_na_values, ]
    
    # rename columns start and end to be generic
    colnames(tibble_of_single_attribute)[grep(x = colnames(tibble_of_single_attribute), pattern = "start")] <- "start"
    colnames(tibble_of_single_attribute)[grep(x = colnames(tibble_of_single_attribute), pattern = "end")] <- "end"
    
    return(tibble_of_single_attribute)
    
  } )

  # ALL DOMAIN ANNOTATIONS FROM BIOMART ARE FINISHED HERE ######
  
  # get ENSP to uniprot entry mapping
  table_ENSP_to_uniprot_entry_mapping <- biomaRt::getBM(filters = "ensembl_peptide_id", values = vec_all_ENSP_ids, attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
  (# remove NA/blank rows
    function(x) {
      
      # debug ###
      # x <- table_ENSP_to_uniprot_entry_mapping
      ###########
      
      row.indices_na_or_blank_values <- x %>% apply(MARGIN = 1, FUN = function(X) {any(is.na(X) | X == "")} ) %>% which
      
      table <- x[-row.indices_na_or_blank_values, ]
      
      return(table)
      
    } )
  
  # for each query interval associated with an ENSP id, extract overlapping biomart result entries.
  list_extracted_overlapping_biomart_results <- future_map(.x = list_of_mapped_proteinID, .f = 
                                                             ~purrr::map(.x = .x, .f = 
                                                                           function(.x) {
                                                                             
                                                                             # DEBUG ###
                                                                             # .x <- list_of_mapped_proteinID[[1]][[1]]
                                                                             ###########
                                                                             
                                                                             query_ENSP <- .x$names
                                                                             query_start <- .x$start
                                                                             query_end <- .x$end
                                                                             list_of_mapped_proteinID
                                                                             matching_tibble_entries_biomart <- purrr::map(.x = list_biomart_result_per_attribute_processed, 
                                                                                                                   .f = ~.x[.x$ensembl_peptide_id == query_ENSP & 
                                                                                                                              .x$start < query_end &
                                                                                                                              .x$end > query_start, ])
                                                                             
                                                                             # retrieve equivalent UniProt entry name 
                                                                             vec_uniprot_entry_IDs <- table_ENSP_to_uniprot_entry_mapping[table_ENSP_to_uniprot_entry_mapping$ensembl_peptide_id == query_ENSP, ] %>% .$uniprotkb_entry %>% unique %>% tibble::enframe(name = NULL, value = "uniprotkb_entry")
                                                                             # get overlapping dbPTM entries ###
                                                                             tibble_matching_entries_dbPTM <- dplyr::semi_join(dbPTM_allhuman_annotations, vec_uniprot_entry_IDs, by = "uniprotkb_entry")
                                                                             tibble_matching_entries_dbPTM <- tibble_matching_entries_dbPTM[tibble_matching_entries_dbPTM$modified_residue_position %in% (query_start:query_end) %>% which, ]
                                                                             # get overlapping phosphositeplus entries ###
                                                                             tibble_matching_entries_phosphositeplus <- dplyr::semi_join(phosphosite_allhuman_phosphosites, vec_uniprot_entry_IDs, by = "uniprotkb_entry")
                                                                             tibble_matching_entries_phosphositeplus <- tibble_matching_entries_phosphositeplus[tibble_matching_entries_phosphositeplus$modified_residue_position %in% (query_start:query_end) %>% which, ]
                                                                             
                                                                             matching_tibble_entries_all <- purrr::splice(list("ensembl_peptide_id" = query_ENSP), 
                                                                                                                          matching_tibble_entries_biomart, 
                                                                                                                          "dbPTM" = tibble_matching_entries_dbPTM,
                                                                                                                          "phosphositeplus" = tibble_matching_entries_phosphositeplus)
                                                                             
                                                                             return(matching_tibble_entries_all)
                                                                             
                                                                           } ), .progress = TRUE, .options = future_options(globals = c("list_biomart_result_per_attribute_processed", "table_ENSP_to_uniprot_entry_mapping", "dbPTM_allhuman_annotations", "phosphosite_allhuman_phosphosites")))

return(list_extracted_overlapping_biomart_results)

}

# END tibble_of_mapped_protein_positions_to_list_of_domains_PTMs()

# this will help us deal with ranges with partial overlap. I classify into 3 cases: 1. query start and end positions both lie in the CDS region 2. start is missing 3. end is missing 4. both missing.
# in the case of missing start/end, it's simple. we use the fact that always start > end.
# we will use the closest number between start and end which actually lies in the CDS region as a proxy for the missing value.
match_query_startend_with_vectors_of_CDSpositions <- function(vector_of_sorted_CDSpositions, ENSP_id, input_query_start, input_query_end) {
  
  # # case if none missing
  # if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 1 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 1) {
  # 
  #   proxy_query_start <- input_query_start
  #   proxy_query_end <- input_query_end
  #   
  # # case if input start missing
  # } else if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 0 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 1) {
  # 
  #   proxy_query_start <- min(vector_of_sorted_CDSpositions[which(input_query_start < vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions < input_query_end)])
  #   proxy_query_end <- input_query_end
  #   
  # # case if input end missing
  # } else if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 1 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 0) {

  # DEBUG ###
  # vector_of_sorted_CDSpositions <- list_overlapping_protein_CDS_positions_tibbles[[2]][[2]]
  # gtf_table <- tibble_ref_gtf_simplified
  # ensemblmart <- ensembl_mart
  # ENSP_id <- list_overlapping_protein_CDS_exons_tibbles[[2]][[1]]$protein_id %>% unique
  # input_query_start <- 37022080
  # input_query_end <- 37023044
  # tibble_queryisoforms_chr_strand_start_end
  ###########
  
    proxy_query_start <- min(vector_of_sorted_CDSpositions[which(input_query_start <= vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions <= input_query_end)])
    proxy_query_end <- max(vector_of_sorted_CDSpositions[which(input_query_start <= vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions <= input_query_end)])

  # }

  # NOTICE: I DELIBERATELY EXPANDED THE END RANGE BY 1 TO ACCOUNT FOR N-TERMINAL METHIONINE EXCISION. THIS IS, AFTER ALL, A CATCH-ALL.

  protein_coordinate_start <-((which(vector_of_sorted_CDSpositions == proxy_query_start) - 1) %/% 3) + 1
  protein_coordinate_end <- ((which(vector_of_sorted_CDSpositions == proxy_query_end) - 1) %/% 3) + 1 + 1
  protein_coordinate_width <- protein_coordinate_end - protein_coordinate_start + 1

  tibble_of_mapped_protein_coordinates <- tribble(~names, ~start, ~width, ~end,
                                                    ENSP_id,
                                                    protein_coordinate_start,
                                                    protein_coordinate_width,
                                                    protein_coordinate_end)

  return(tibble_of_mapped_protein_coordinates)
  
  # debug
  # return(list(vector_of_sorted_CDSpositions, ENSP_id, input_query_start, input_query_end, proxy_query_start, proxy_query_end))
  
}

# END match_query_startend_with_vectors_of_CDSpositions

# FILTER THE GTF TABLE BY ANNOTATIONS OVERLAPPING WITH THE QUERY INTERVAL(S)

# possible modes that this function can operate in: 1. "AS region" and 2. "BED_file" 
# AS region mode is for finding all the overlapping gtf annotations of a given AS event
# BED file mode is for annotating a BED file (especially from CLIP-SEQ/RIP-seq/parclip) 
# target level is the filter for the "type" in gtf table. one of: "gene", "transcript", "exon", "CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr", "Selenocysteine"

map_genome_coordinate_to_transcriptandprotein <- function(chr_strand_start_end_tibble, gtf_table, mode, targetlevel = NULL) {
  
  # DEBUG ###
  # chr_strand_start_end_tibble <- tibble_queryisoforms_chr_strand_start_end
  # gtf_table <- tibble_ref_gtf_simplified
  # mode = "AS region"
  ###########
  
  if (mode == "AS region") {
  
  list_of_query_AS_ID <- chr_strand_start_end_tibble$diff_exon_coords %>% array_tree

list_of_all_overlapping_annotations <- future_imap(.x = list_of_query_AS_ID, .f = function(.x, .y) {
  
  # message("Now processing entry number: ", .y)
  
  overlapping_gtf_entries <- gtf_table[(gtf_table$chr == chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "chr"] %>% unique %>% paste %>% as.character) &
    (gtf_table$strand == chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "strand"] %>% unique %>% paste %>% as.character), ] %>% 
    .[(.$start < chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "end"] %>% unique %>% paste %>% as.numeric) & 
        (.$end > chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "start"] %>% unique %>% paste %>% as.numeric), ]
  
  return(overlapping_gtf_entries)
  
}, .progress = TRUE, .options = future_options(globals = c("gtf_table", "chr_strand_start_end_tibble")))

names(list_of_all_overlapping_annotations) <- chr_strand_start_end_tibble$Gene


  } else if (mode == "BED_file") {
  
    bed_chr_strand_start_end <- chr_strand_start_end_tibble
    
    colnames(bed_chr_strand_start_end) <- c("feature_chr", "feature_strand", "feature_start", "feature_end", "ClusterID", "ClusterSequence", "ReadCount", "ModeLocation", "ModeScore", "ConversionLocationCount", "ConversionEventCount", "NonConversionEventCount")

gtf_table_targetlevel <- gtf_table[gtf_table$type == targetlevel, ]

colnames(gtf_table_targetlevel) <- c("annotation_chr", "annotation_start", "annotation_end", "annotation_width", "annotation_strand", "annotation_type", "annotation_annotation_phase", "annotation_gene_id", "annotation_gene_name", "annotation_gene_biotype", "annotation_transcript_id", "annotation_transcript_name", "annotation_transcript_biotype", "annotation_exon_number", "annotation_exon_id", "annotation_protein_id")

gtf_entries_overlapping_with_bed <- purrr::pmap(.l = list(bed_chr_strand_start_end[["feature_chr"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_strand"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_start"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_end"]]) %>% as.list, 
                                                   .f = ~gtf_table_targetlevel %>%
                                                     .[.$annotation_chr == ..1 %>% lapply(as.character) %>% paste, ] %>% 
                                                       .[.$annotation_strand == ..2 %>% lapply(as.character) %>% paste, ] %>% 
                                                     .[(.$annotation_start < ..4 %>% as.numeric %>% paste) & 
                                                         (.$annotation_end > ..3 %>% as.numeric %>% paste), ]) %>% compact

unannotated_bed_file_arraytree <- bed_chr_strand_start_end %>% array_tree %>% purrr::map(~as_tibble(.x))

peaks_with_annotation <- which(purrr::map(gtf_entries_overlapping_with_bed, ~nrow(.x)) %>% unlist != 0)

annotated_bed_file <- purrr::map2(.x = unannotated_bed_file_arraytree[peaks_with_annotation], 
                                  .y = gtf_entries_overlapping_with_bed[peaks_with_annotation], 
                                  .f = ~cbind(.x, .y))

# not actually a list. actually a wide table.

list_of_all_overlapping_annotations <- annotated_bed_file %>% purrr::reduce(bind_rows)

}

return(list_of_all_overlapping_annotations)
  
}

# END map_genome_coordinate_to_transcriptandprotein

# sort lists of protein CDS positions by descending/ascending order depending if ORF is on + or - strand
##  function to look at a tibble containing the CDS positions and see whether you need to sort by increasing or decreasing order

sort_tibble_according_to_strand <- function(tibble_to_be_sorted) {
  
  if (data.class(tibble_to_be_sorted) != "tbl_df") {
    
    CDS_list_out <- tibble_to_be_sorted
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "+") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = FALSE)
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "-") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = TRUE)
    
  }
  
  return(CDS_list_out)
  
}

# END sort_according_to_strand

# THE MAIN FUNCTION TO CONVERT THE TIDIED CHR STRAND START END TIBBLE TO LISTS OF OVERLAPPING ANNOTATION AND PROTEIN DOMAINS
# inputs: 1. table containing regions to be queried. columns must be: Gene, AS event ID, chr, strand, start, end; 2. GTF table, preferably from rtracklayer::import, 3. ensembl mart of choice

tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain <- function(tibble_queryisoforms_chr_strand_start_end, gtf_table, ensemblmart) {
  
  # DEBUG ###
  # tibble_queryisoforms_chr_strand_start_end <- tibble_all_diff_exons_chr_strand_start_end
  # gtf_table <- tibble_ref_gtf_simplified
  # ensemblmart <- ensembl_mart
  ###########
    
  message("Now mapping the specified AS coords to transcript- and protein-relative coords")
  
  gtf_table <- gtf_table
  list_queryisoforms_overlapping_annotations_tibbles <- tibble_queryisoforms_chr_strand_start_end %>% map_genome_coordinate_to_transcriptandprotein(., gtf_table = gtf_table, mode = "AS region") 
  
  # set level 1 list names as the exon coords
  names(list_queryisoforms_overlapping_annotations_tibbles) <- tibble_queryisoforms_chr_strand_start_end$diff_exon_coords
  
  message("Extract the individual CDS regions of each protein overlapping the AS regions")
  list_overlapping_protein_CDS_exons_tibbles <- future_map(.x = list_queryisoforms_overlapping_annotations_tibbles, .f = ~.x$protein_id %>% na.omit %>% unique %>% as.list %>% purrr::map(.x = ., .f = ~gtf_table[gtf_table$protein_id == .x & gtf_table$type == "CDS", ] %>% .[apply(X = ., MARGIN = 1, FUN = function(X) {all(is.na(X)) == FALSE}), ]), .progress = TRUE, .options = future_options(globals = c("gtf_table")))
  
  message("Extract the individual genome-relative CDS nucleotide positions")
  list_overlapping_protein_CDS_positions_tibbles <- future_map(.x = list_overlapping_protein_CDS_exons_tibbles, .f = ~purrr::map(.x = .x, .f = ~sort_tibble_according_to_strand(.x)), .progress = TRUE, .options = future_options(globals = c("sort_tibble_according_to_strand")))
  
  message("Now generate a table of sorted protein relative coordinates for each genomic start and end associated with each unique AS region.")
  # provided functions: 
  # 1. list_overlapping_protein_CDS_positions_tibbles: list of genes corresponding to isoform enriched > list of vectors of genomic positions of CDS for each ENSP, 
  # 2. 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% as.list: level 1 indices, 
  # 3. list_overlapping_protein_CDS_exons_tibbles: list of genes corresponding to isoform enriched > list of subsets of GTF table for each unique ENSP caught by query range. used for ENSP id mapping 
  # NOTE: width < 0 if the ORF is on the - strand
  mapped_aminoacid_positions <- purrr::pmap(.l = list("A" = list_overlapping_protein_CDS_positions_tibbles, 
                                                      "B" = 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% array_tree,
                                                      "C" = list_overlapping_protein_CDS_exons_tibbles), .f = function(A, B, C) {
                                                        
                                                        level_one_index <- B
                                                        
                                                        message("now processing entry number: ", level_one_index)
                                                        
                                                        purrr::map2(.x = A, .y = C, .f = function(.x, .y) {
                                                          
                                                          # print(paste(".x = ", .x %>% head))
                                                          # print(paste(.y))
                                                          
                                                          match_query_startend_with_vectors_of_CDSpositions(vector_of_sorted_CDSpositions = .x,
                                                                                                            ENSP_id = paste(.y$protein_id %>% unique),
                                                                                                            input_query_start = paste(tibble_queryisoforms_chr_strand_start_end[level_one_index, "start"]) %>% as.numeric,
                                                                                                            input_query_end = paste(tibble_queryisoforms_chr_strand_start_end[level_one_index, "end"]) %>% as.numeric)
                                                          
                                                          } )
                                                        } )
  
  # FINALLY! PROTEIN DOMAIN MATCHING!
  
  # get rid of empty genes with no match
  mapped_aminoacid_positions <- purrr::discard(.x = mapped_aminoacid_positions, .p = ~length(.x) == 0)
  
  # retrieve all the domain and PTM annotations
  coinciding_domains_PTMs <- tibble_of_mapped_protein_positzions_to_list_of_domains_PTMs(mapped_aminoacid_positions, ensemblmart)
  
  # summarise protein and transcript-level analyses
  ## for the transcript level, only extract the "type" and "transcript_biotype" columns
  list_of_tibbles_transcript_level_results <- list_queryisoforms_overlapping_annotations_tibbles %>% purrr::map(~.x[, c("type", "transcript_biotype")] %>% unique)
  ## add in the exon coords from the level 1 list and rbind
  tibble_transcript_level_results <- purrr::map2(.x = list_of_tibbles_transcript_level_results, .y = names(list_of_tibbles_transcript_level_results), .f = ~add_column(.x, "diff_exon_coords" = .y, .before = 1)) %>% rbindlist %>% as_tibble
  
  ## for the protein/domain etc. level, extract and collapse OR convert to logical indicating the presence/absence of a feature.
  list_of_tibbles_protein_level_results <- purrr::map2(.x = coinciding_domains_PTMs, .y = names(coinciding_domains_PTMs), .f = function(.x, .y) {
    
    # DEBUG ###
    # .x <- coinciding_domains_PTMs[[1]]
    # .y <- names(coinciding_domains_PTMs) %>% .[[1]]
    ###########
    
    list_L2 <- .x
    L1_id <- .y
    
    # convert ncoils, seg, signalp, tmhmm, mobidblite to logical.
    list_L2_processed <- purrr::map(.x = list_L2, .f = ~purrr::modify_at(.x = .x, .at = c("ncoils", "seg", "signalp", "tmhmm", "mobidblite"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(TRUE)
        
      }
      
      return(annotation_exists)
      
    } ))
    
    # collapse interpro annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("interpro"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(paste(.x$interpro, collapse = ";"))
        
      }
      
    } ))
    
    # collapse sifts annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("sifts"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(paste(.x$sifts_import, collapse = ";"))
        
      }
      
    } ))
    
    # collapse dbPTM annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("dbPTM"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(tibble("dbPTM_uniprotkb_entry" = NA,
                      "dbPTM_modified_residue_position" = NA,
                      "dbPTM_PTM_type" = NA))
        
      } else if (nrow(.x) != 0) {
        
        return(tibble("dbPTM_uniprotkb_entry" = paste(.x$uniprotkb_entry, collapse = ";"),
                      "dbPTM_modified_residue_position" = paste(.x$modified_residue_position, collapse = ";"),
                      "dbPTM_PTM_type" = paste(.x$PTM_type, collapse = ";")))
        
      }
      
    } ))
    
    # collapse phosphositeplus annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("phosphositeplus"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(tibble("phosphositeplus_uniprotkb_entry" = NA,
                      "phosphositeplus_modified_residue_position" = NA))
        
      } else if (nrow(.x) != 0) {
        
        return(tibble("phosphositeplus_uniprotkb_entry" = paste(.x$uniprotkb_entry, collapse = ";"),
                      "phosphositeplus_modified_residue_position" = paste(.x$modified_residue_position, collapse = ";")))
        
      }
      
    } ))
    
    # splice in the level 1 list name (in this case, it's diff_exon_coords)
    list_L2_final <- purrr::map(.x = list_L2_processed, .f = ~purrr::splice(list("diff_exon_coords" = L1_id), 
                                                                            .x))
    
    return(list_L2_final)
    
  })
  ## flatten, tibblise within each element then rbind. 
  tibble_protein_level_results <- list_of_tibbles_protein_level_results %>% flatten 
  names(tibble_protein_level_results) <- NULL
  tibble_protein_level_results <- tibble_protein_level_results %>% purrr::map(~flatten(.x) %>% as_tibble) %>% rbindlist %>% as_tibble
  
  return(list("transcript_level_results" = tibble_transcript_level_results,
              "protein_level_results" = tibble_protein_level_results))

}

# END tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain

```

# Read the ir.sorted files into environment

## create file list and import using purrr

```{r}

list_of_psisigma_result_tibbles_raw <- future_map(.x = vector_of_comparisons_final, .f = ~read.delim(paste(psisigma_results_dir, .x, "/", .x, "_r1_ir3.sorted.txt", sep = ""), sep = "\t") %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble", "psisigma_results_dir")))

```

## process column names, split the absolute PSI values and append comparison info

```{r}

list_of_psisigma_result_tibbles_processed <- future_map(.x = list_of_psisigma_result_tibbles_raw, .f = 
                                                          # rename all columns
                                                          ~setNames(.x, c("event_region_coords", "psisigma_gene.symbol", "diff_exon_coords", "splicemode", "num.replicates_comparison.1", "num.replicates_comparison.2", "psisigma_exon_type", "psisigma_reference.transcript", "dpsi", "pvalue", "FDR", "psi_comparison.1", "psi_comparison.2", "database_ID")) %>%
                                                          # separate absolute PSI columns
                                                          tidyr::separate(., col = psi_comparison.1, sep = "\\|", into = c("comparison.1_absolute.psi_1", "comparison.1_absolute.psi_2", "comparison.1_absolute.psi_3")) %>% 
                                                          # separate absolute PSI columns
                                                          tidyr::separate(., col = psi_comparison.2, sep = "\\|", into = c("comparison.2_absolute.psi_1", "comparison.2_absolute.psi_2", "comparison.2_absolute.psi_3")) %>%
                                                          # separate the co-ordinates of the differential exon in preparation for matching
                                                          add_column("chr" = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\1"), 
                                                                     "diff_exon_start" = purrr::map2(.x = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert, .y = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert, .f = ~min(.x, .y)) %>% unlist, 
                                                                     "diff_exon_end" = purrr::map2(.x = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert, .y = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert, .f = ~max(.x, .y)) %>% unlist,
                                                                     
                                                                     "event_region_start" = purrr::map2(.x = gsub(x = .$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert, .y = gsub(x = .$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert, .f = ~min(.x, .y)) %>% unlist,
                                                                     "event_region_end" = purrr::map2(.x = gsub(x = .$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert, .y = gsub(x = .$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert, .f = ~max(.x, .y)) %>% unlist), .progress = TRUE)
# add column indicating what comparison the tibble is from
list_of_psisigma_result_tibbles_processed <- map2(.x = list_of_psisigma_result_tibbles_processed, .y = vector_of_comparisons_final, .f = ~add_column(.x, "comparison" = .y))

# collapse into a long tibble
wide_tibble_of_psisigma_results_allcomparisons_processed <- list_of_psisigma_result_tibbles_processed %>% rbindlist %>% as_tibble %>% type_convert(na = c("", "NA", "na"))

# remove all special characters from the splicemode column
wide_tibble_of_psisigma_results_allcomparisons_processed[, "splicemode"] <- gsub(x = wide_tibble_of_psisigma_results_allcomparisons_processed$splicemode, pattern = "(.*)overlapping(.*)", replacement = "IR_overlapping_region")

wide_tibble_of_psisigma_results_allcomparisons_processed <- wide_tibble_of_psisigma_results_allcomparisons_processed %>% as.data.frame

# impute missing values of PSI
wide_tibble_of_psisigma_results_allcomparisons_processed[, colnames(wide_tibble_of_psisigma_results_allcomparisons_processed)[grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_processed), pattern = "comparison.1_")]] <- future_map2(.x = wide_tibble_of_psisigma_results_allcomparisons_processed %>% dplyr::select(contains("comparison.1_")) %>% array_tree(margin = 1), .y = wide_tibble_of_psisigma_results_allcomparisons_processed %>% dplyr::select(contains("comparison.1_")) %>% rowMeans(na.rm = TRUE), .f = function(a1, a2) {a1[is.na(a1)] <- a2; return(a1 %>% t %>% as.data.frame)}, .progress = TRUE ) %>% rbindlist(use.names = TRUE) %>% as_tibble

wide_tibble_of_psisigma_results_allcomparisons_processed[, colnames(wide_tibble_of_psisigma_results_allcomparisons_processed)[grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_processed), pattern = "comparison.2_")]] <- future_map2(.x = wide_tibble_of_psisigma_results_allcomparisons_processed %>% dplyr::select(contains("comparison.2_")) %>% array_tree(margin = 1), .y = wide_tibble_of_psisigma_results_allcomparisons_processed %>% dplyr::select(contains("comparison.2_")) %>% rowMeans(na.rm = TRUE), .f = function(a1, a2) {a1[is.na(a1)] <- a2; return(a1 %>% t %>% as.data.frame)}, .progress = TRUE ) %>% rbindlist(use.names = TRUE) %>% as_tibble

wide_tibble_of_psisigma_results_allcomparisons_processed <- wide_tibble_of_psisigma_results_allcomparisons_processed %>% as_tibble

```

## re-label the gene/strand/first.last.only exon etc.

### match exons/junctions with the reference GTF

PSI-Sigma does a horrible job of getting the gene/strand information from the reference GTF. We will replace the existing annotation by doing our exact matching.

While we're at it, also match with the reconstructed GTF if matching to reference GTF is not possible.

NOTE: the reference GTF must have already had first/last/only exon info appended.

#### match to junctions for IR and exons to non-IR

```{r}

wide_tibble_of_all_unique_VSR_and_exon_coords <- wide_tibble_of_psisigma_results_allcomparisons_processed[, c("splicemode", "diff_exon_coords", "event_region_coords", "chr", "diff_exon_start", "diff_exon_end", "event_region_start", "event_region_end")] %>% unique

# wide_tibble_of_all_unique_VSR_and_exon_coords <- wide_tibble_of_psisigma_results_allcomparisons_processed[sample(1:nrow(wide_tibble_of_psisigma_results_allcomparisons_processed), 1000), c("splicemode", "diff_exon_coords", "event_region_coords", "chr", "diff_exon_start", "diff_exon_end", "event_region_start", "event_region_end")] %>% unique

# split exon co-ords by whether it's IR or not
wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_IR <- wide_tibble_of_all_unique_VSR_and_exon_coords[grep(x = wide_tibble_of_all_unique_VSR_and_exon_coords$splicemode, pattern = "IR"), ] %>% array_tree
wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_not_IR <- wide_tibble_of_all_unique_VSR_and_exon_coords[-grep(x = wide_tibble_of_all_unique_VSR_and_exon_coords$splicemode, pattern = "IR"), ] %>% array_tree

# junction-flanking exon matches for IR events
list_ref_matching_exon_entries_IR <- future_imap(.x = wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_IR, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_IR[[2]]
  ###########
  
  cat(a2, "\n")
  
  # match exons to reference for IR events
  reference_gtf_match <- extract_junction.flanking.exons(query_chr = a1$chr %>% type.convert, query_start = a1$diff_exon_start %>% type.convert, query_end = a1$diff_exon_end %>% type.convert, query_strand = "*", tibble_gtf_table = tibble_ref_gtf, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon") %>% (function(x) {if (length(x) != 0) {x %>% rbindlist(use.names = TRUE) %>% as_tibble} } )
  
  reconstructed_gtf_match <- extract_junction.flanking.exons(query_chr = a1$chr %>% type.convert, query_start = a1$diff_exon_start %>% type.convert, query_end = a1$diff_exon_end %>% type.convert, query_strand = "*", tibble_gtf_table = tibble_recon_gtf, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon") %>% (function(x) {if (length(x) != 0) {x %>% rbindlist(use.names = TRUE) %>% as_tibble} } )
  
  return(splice(a1,
                "reference_gtf_match" = list(reference_gtf_match),
                "reconstructed_gtf_match" = list(reconstructed_gtf_match)))
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_recon_gtf", "extract_junction.flanking.exons", "rbindlist", "as_tibble")))

list_ref_matching_exon_entries_IR_annotated <- future_imap(.x = list_ref_matching_exon_entries_IR, .f = function(a1, a2) {
  
  cat(a2, "\n")
  
  annotate_differential_exon(a1) %>% as_tibble %>% return
  
} , .progress = TRUE, .options = future_options(globals = c("annotate_differential_exon", "as_tibble")))

# for non-IR events, scan VSR then overlap exons.
# if VSRs couldnt be matched then find perfectly overlapping exons instead
## it's a little more complicated
list_ref_matching_exon_entries_not_IR <- future_map(.x = wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_not_IR, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_not_IR[[300]]
  ###########
  
  # cat(a2, "\n")
  
  # match VSRs to reference for non-IR events
  # extract parent transcript ids
  # extract the GTF entry of overlapping exons.
  ## get VSR-matching entries
  raw_reference_gtf_match <- extract_junction.flanking.exons(query_chr = a1$chr %>% type.convert, query_start = a1$event_region_start %>% type.convert, query_end = a1$event_region_end %>% type.convert, query_strand = "*", tibble_gtf_table = tibble_ref_gtf, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = FALSE, return_type = "exon")
  
  raw_reconstructed_gtf_match <- extract_junction.flanking.exons(query_chr = a1$chr %>% type.convert, query_start = a1$event_region_start %>% type.convert, query_end = a1$event_region_end %>% type.convert, query_strand = "*", tibble_gtf_table = tibble_recon_gtf, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = FALSE, return_type = "exon")
  
  # go to matching by exons only if VSR match failed
  if (length(raw_reference_gtf_match) == 0) {
    
    list_matched_exon_ref <- extract_overlapping.exons(query_chr = a1$chr %>% type.convert, query_start = a1$diff_exon_start %>% type.convert, query_end = a1$diff_exon_end %>% type.convert, query_strand = "*", tibble_gtf_table = tibble_ref_gtf, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon")
    
  } else {
    
    ## retrieve parent transcript_id
    vector_ref_matched_parent_transcript_ids <- raw_reference_gtf_match %>% purrr::map(.f = ~.x$transcript_id) %>% unlist %>% unique
    
    ## retrieve all entries from the parent transcript_id
    list_ref_parent_transcript_entries <- vector_ref_matched_parent_transcript_ids %>% purrr::map(.f = ~tibble_ref_gtf[which(tibble_ref_gtf$transcript_id == .x & tibble_ref_gtf$type == "exon"), ])
    
    ## overlap with alternative exon. take cases:
    ## 1. there is overlap, match that exon
    ## 2. alternative exon is adjacent to stuff. match those 
    ## 3. if no match still, then no match.
    list_matched_exon_ref <- purrr::map(.x = list_ref_parent_transcript_entries, 
                                        .f = function(b1) {
                                          
                                          # DEBUG ###
                                          # b1 <- list_ref_parent_transcript_entries[[1]]
                                          ###########
                                          
                                          # match overlapping exons first
                                          tibble_matched_overlapping_exon_entry <- b1[which(b1$start <= a1$diff_exon_end %>% type.convert & b1$end >= a1$diff_exon_start %>% type.convert), ]
                                          # if that fails, then check for adjacency
                                          if (tibble_matched_overlapping_exon_entry %>% nrow == 0) {
                                            tibble_matched_overlapping_exon_entry <- b1[which(b1$start <= (a1$diff_exon_start %>% type.convert) - 1 & b1$end >= (a1$diff_exon_start %>% type.convert) - 1),]
                                          }
                                          
                                          if (tibble_matched_overlapping_exon_entry %>% nrow == 0) {
                                            tibble_matched_overlapping_exon_entry <- b1[which(b1$start <= (a1$diff_exon_end %>% type.convert) + 1 & b1$end >= (a1$diff_exon_end %>% type.convert) + 1),]
                                          }
                                          
                                          return(tibble_matched_overlapping_exon_entry)
                                          
                                        } ) %>% (function(x) {if (length(x) != 0) {x %>% rbindlist(use.names = TRUE) %>% as_tibble} } )
    
  }
  
  # go to matching by exons only if VSR match failed
  if (length(raw_reconstructed_gtf_match) == 0) {
    
    list_matched_exon_recon <- extract_overlapping.exons(query_chr = a1$chr %>% type.convert, query_start = a1$diff_exon_start %>% type.convert, query_end = a1$diff_exon_end %>% type.convert, query_strand = "*", tibble_gtf_table = tibble_recon_gtf, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon")
    
  } else {
    
    ## retrieve parent transcript_id
  vector_recon_matched_parent_transcript_ids <- raw_reconstructed_gtf_match %>% purrr::map(.f = ~.x$transcript_id) %>% unlist %>% unique
  
  ## retrieve all entries from the parent transcript_id
  list_recon_parent_transcript_entries <- vector_recon_matched_parent_transcript_ids %>% purrr::map(.f = ~tibble_recon_gtf[which(tibble_recon_gtf$transcript_id == .x & tibble_recon_gtf$type == "exon"), ])
  
  ## overlap with alternative exon. take cases:
  ## 1. there is overlap, match that exon
  ## 2. alternative exon is adjacent to stuff. match those 
  ## 3. if no match still, then no match.
  list_matched_exon_recon <- purrr::map(.x = list_recon_parent_transcript_entries, 
                                      .f = function(b1) {
                                        
                                        # DEBUG ###
                                        # b1 <- list_ref_parent_transcript_entries[[1]]
                                        ###########
                                        
                                        # match overlapping exons first
                                        tibble_matched_overlapping_exon_entry <- b1[which(b1$start <= a1$diff_exon_end %>% type.convert & b1$end >= a1$diff_exon_start %>% type.convert), ]
                                        # if that fails, then check for adjacency
                                        if (tibble_matched_overlapping_exon_entry %>% nrow == 0) {
                                          tibble_matched_overlapping_exon_entry <- b1[which(b1$start <= (a1$diff_exon_start %>% type.convert) - 1 & b1$end >= (a1$diff_exon_start %>% type.convert) - 1),]
                                        }
                                        
                                        if (tibble_matched_overlapping_exon_entry %>% nrow == 0) {
                                          tibble_matched_overlapping_exon_entry <- b1[which(b1$start <= (a1$diff_exon_end %>% type.convert) + 1 & b1$end >= (a1$diff_exon_end %>% type.convert) + 1),]
                                        }
                                        
                                        return(tibble_matched_overlapping_exon_entry)
                                        
                                      } ) %>% (function(x) {if (length(x) != 0) {x %>% rbindlist(use.names = TRUE) %>% as_tibble} } )
    
  }
  
  return(splice(a1,
                "reference_gtf_match" = list(list_matched_exon_ref),
                "reconstructed_gtf_match" = list(list_matched_exon_recon)))
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_recon_gtf", "extract_overlapping.exons", "extract_junction.flanking.exons")))

list_ref_matching_exon_entries_not_IR_annotated <- future_imap(.x = list_ref_matching_exon_entries_not_IR, .f = ~annotate_differential_exon(.x) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("annotate_differential_exon", "as_tibble")))

tibble_ref_matching_exon_entries_all <- dplyr::bind_rows(list_ref_matching_exon_entries_IR_annotated %>% rbindlist, list_ref_matching_exon_entries_not_IR_annotated %>% rbindlist) %>% as_tibble

write.table(tibble_ref_matching_exon_entries_all, file = paste(R_processing_results_dir, "table_all_exons_reference_match_info.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

#### SUMMARISE NON-IR ENTRIES (SIMPLE)

Summarise for first/last exon, NMD.

behaviour: if annotation appears in at least ONE match in either reference or recon, then TRUE (union)

```{r}

# read the table of annotation
tibble_ref_matching_exon_entries_all <- read.delim(file = paste(R_processing_results_dir, "table_all_exons_reference_match_info.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE) %>% type_convert %>% as_tibble

# extract the row indices of IR event entries from the tibble_ref_matching_exon_entries_all
row.indices_IR_events <- grep(x = tibble_ref_matching_exon_entries_all$splicemode, pattern = "IR")

# subset exon annotation table for non IR events
tibble_ref_matching_exon_entries_all_not.IR <- tibble_ref_matching_exon_entries_all[-row.indices_IR_events, ]

# summarise annotation
## initialise columns
tibble_ref_matching_exon_entries_all_not.IR_summarised <- tibble_ref_matching_exon_entries_all_not.IR %>% 
  add_column("any_first_exon" = FALSE,
             "any_last_exon" = FALSE,
             "any_NMD" = FALSE)

tibble_ref_matching_exon_entries_all_not.IR_summarised[union(grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_reference, pattern = "first_exon"),
                                                               grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_recon, pattern = "first_exon")), "any_first_exon"] <- TRUE

tibble_ref_matching_exon_entries_all_not.IR_summarised[union(grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_reference, pattern = "last_exon"),
                                                               grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_recon, pattern = "last_exon")), "any_last_exon"] <- TRUE

tibble_ref_matching_exon_entries_all_not.IR_summarised[which(tibble_ref_matching_exon_entries_all_not.IR_summarised$NMD_flagged_ref == TRUE | tibble_ref_matching_exon_entries_all_not.IR_summarised$NMD_flagged_recon == TRUE), "any_NMD"] <- TRUE

```

#### REANNOTATE AND SUMMARISE IR ENTRIES (COMPLICATED)

```{r}

# re-match the IR events to the reference annotation
# for IR event entries, complicated. First retrieve the matched/recon transcripts. then find transcripts with overlapping exons.
# These IR-spanning transcripts must have at least ONE start/end coord/gene name in common with the junction-matched transcripts.
# return their corresponding annotations.
# NOTE: it seems like JUM only associates one junction ID with each IR event (which makes sense). However, my small sample size of 52 IR junctions isn't enough to fully conclude this is the case.
## array tree-ify the AS_event_IDs for looping
list_ref_matching_exon_entries_all_array.tree_IR <- tibble_ref_matching_exon_entries_all[row.indices_IR_events, ] %>% array_tree

## look up the annotation tibble for each AS_event_ID, summarise.
list_ref_matching_exon_entries_all_array.tree_IR_reannotated <- future_imap(.x = list_ref_matching_exon_entries_all_array.tree_IR, .f = function(.x, .y) {
  
  # message("now processing entry number: ", .y)
  
  # DEBUG ###
  # .x <- list_ref_matching_exon_entries_all_array.tree_IR[[11]]
  # tibble_ref_gtf <- tibble_ref_gtf
  # tibble_recon_gtf <- tibble_recon_gtf
  ###########
  # 
  # tibble_ref_gtf <<- tibble_ref_gtf
  # tibble_recon_gtf <<- tibble_recon_gtf
  
  chr <- .x$chr %>% paste %>% trimws
  start <- .x$diff_exon_start %>% paste %>% trimws %>% type.convert
  end <- .x$diff_exon_end %>% paste %>% trimws %>% type.convert
  strand <- .x$matched_strand %>% paste %>% trimws
  vec_ref_transcripts_matched_to_junction <- .x$matched_ref_transcript_names %>% strsplit(split = ",") %>% unlist %>% tibble::enframe(name = NULL, value = "transcript_id")
  vec_recon_transcripts_matched_to_junction <- .x$matched_recon_transcript_names %>% strsplit(split = ",") %>% unlist %>% tibble::enframe(name = NULL, value = "transcript_id")
  
  # check reference annotation - but only if the junction was matched to reference in the first place.
  tibble_all_confirmed_IR_entries_ref <- "uninit"
  
  if (all(is.na(vec_ref_transcripts_matched_to_junction)) != TRUE) {
    
    # match IR region to reference
    tibble_ref_gtf_subset_IR_overlap <- tibble_ref_gtf[which(tibble_ref_gtf$seqnames == chr %>% trimws), ] %>% .[which(.$strand == strand %>% trimws), ] %>% .[which(.$start <= ((start %>% as.numeric) - 2) & .$end >= ((end %>% as.numeric) + 2)), ] %>% .[which(.$type == "exon"), ]
  
    # get all the entries which matched to the junction
    tibble_ref_gtf_subset_junction_matching_entries <- dplyr::semi_join(tibble_ref_gtf[tibble_ref_gtf$type == "exon", ], vec_ref_transcripts_matched_to_junction, by = "transcript_id")
    
    # extract all the start coords of the junction-matched entries
    vector_junction_matched_start_coords <- tibble_ref_gtf_subset_junction_matching_entries[, "start"]
    # find which IR matched entry has any same start coord
    tibble_ref_gtf_subset_IR_overlap_start.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_start_coords)
    
    # extract all the end coords of the junction-matched entries
    vector_junction_matched_end_coords <- tibble_ref_gtf_subset_junction_matching_entries[, "end"]
    # find which IR matched entry has any same end coord
    tibble_ref_gtf_subset_IR_overlap_end.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_end_coords)
    
    # extract all the gene names of the junction-matched entries
    vector_junction_matched_gene_names <- tibble_ref_gtf_subset_junction_matching_entries[, "gene_name"]
    # find which IR matched entry has any same end coord
    tibble_ref_gtf_subset_IR_overlap_gene.name.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_gene_names)
    
    tibble_union_start.and.end.matched <- list(tibble_ref_gtf_subset_IR_overlap_start.matched, 
                                            tibble_ref_gtf_subset_IR_overlap_end.matched,
                                            tibble_ref_gtf_subset_IR_overlap_gene.name.matched) %>% purrr::reduce(dplyr::union)
    
    if (nrow(tibble_union_start.and.end.matched) == 0) {
      
      tibble_all_confirmed_IR_entries_ref <- "uninit"
      
    } else if (nrow(tibble_union_start.and.end.matched) > 0) {
      
      tibble_all_confirmed_IR_entries_ref <- tibble_union_start.and.end.matched
      
    }
    
  }
  
  # check recon annotation - but only if the junction was matched to recon in the first place.
  tibble_all_confirmed_IR_entries_recon <- "uninit"
  
  if (all(is.na(vec_recon_transcripts_matched_to_junction)) != TRUE) {
    
    # match IR region to recon GTF
    tibble_recon_gtf_subset_IR_overlap <- tibble_recon_gtf[tibble_recon_gtf$seqnames == chr %>% trimws, ] %>% .[.$strand == strand %>% trimws, ] %>% .[.$start <= ((start %>% as.numeric) - 2) & .$end >= ((end %>% as.numeric) + 2), ] %>% .[.$type == "exon", ]
  
    # get all the entries which matched to the junction
    tibble_recon_gtf_subset_junction_matching_entries <- dplyr::semi_join(tibble_recon_gtf[tibble_recon_gtf$type == "exon", ], vec_recon_transcripts_matched_to_junction, by = "transcript_id")
    
    # extract all the start coords of the junction-matched entries
    vector_junction_matched_start_coords <- tibble_recon_gtf_subset_junction_matching_entries[, "start"]
    # find which IR matched entry has any same start coord
    tibble_recon_gtf_subset_IR_overlap_start.matched <- dplyr::semi_join(tibble_recon_gtf_subset_IR_overlap, vector_junction_matched_start_coords)
    
    # extract all the end coords of the junction-matched entries
    vector_junction_matched_end_coords <- tibble_recon_gtf_subset_junction_matching_entries[, "end"]
    # find which IR matched entry has any same end coord
    tibble_recon_gtf_subset_IR_overlap_end.matched <- dplyr::semi_join(tibble_recon_gtf_subset_IR_overlap, vector_junction_matched_end_coords, by = "end")
    
    tibble_union_start.and.end.matched <- list(tibble_recon_gtf_subset_IR_overlap_start.matched, 
                                            tibble_recon_gtf_subset_IR_overlap_end.matched) %>% purrr::reduce(dplyr::union)
    
    if (nrow(tibble_union_start.and.end.matched) == 0) {
      
      tibble_all_confirmed_IR_entries_recon <- "uninit"
      
    } else if (nrow(tibble_union_start.and.end.matched) > 0) {
      
      tibble_all_confirmed_IR_entries_recon <- tibble_union_start.and.end.matched
      
    }
    
  }
  
  # we now have enough info. to write up the final summary
  summarised_tibble_annotation <- .x %>% as_tibble
  
  # refresh the matched ref and recon transcript names
  summarised_tibble_annotation[, "matched_ref_transcript_names"] <- if (tibble_all_confirmed_IR_entries_ref != "uninit") {
    tibble_all_confirmed_IR_entries_ref$transcript_id %>% paste(collapse = ",")
  }
  
  summarised_tibble_annotation[, "matched_recon_transcript_names"] <- if (tibble_all_confirmed_IR_entries_recon != "uninit") {
    tibble_all_confirmed_IR_entries_recon$transcript_id %>% paste(collapse = ",")
  }
  
  summarised_tibble_annotation[, "NMD_biotype_reference"] <- if (tibble_all_confirmed_IR_entries_ref == "uninit") {
    FALSE
    } else {
      all(tibble_all_confirmed_IR_entries_ref$transcript_biotype == "nonsense_mediated_decay")
    }
  
  summarised_tibble_annotation[, "NMD_flagged_ref"] <- if (tibble_all_confirmed_IR_entries_ref == "uninit") {
    FALSE
    } else {
      any(tibble_all_confirmed_IR_entries_ref$NMD_flagged_ref == "nonsense_mediated_decay")
    }
  
   summarised_tibble_annotation[, "NMD_flagged_recon"] <- if (tibble_all_confirmed_IR_entries_recon == "uninit") {
     FALSE
     } else {
       all(tibble_all_confirmed_IR_entries_recon$NMD_flagged_recon == TRUE)
     }
   
   summarised_tibble_annotation[, "first_or_last_exon_reference"] <- if (tibble_all_confirmed_IR_entries_ref == "uninit") {
     .x$first_or_last_exon_reference %>% paste(collapse = ";")
     } else {
       tibble_all_confirmed_IR_entries_ref$first_or_last_exon %>% paste(collapse = ";")
     }
   
   summarised_tibble_annotation[, "first_or_last_exon_recon"] <- if (tibble_all_confirmed_IR_entries_recon == "uninit") {
     .x$first_or_last_exon_recon %>% paste(collapse = ";")
     } else {
       tibble_all_confirmed_IR_entries_recon$first_or_last_exon %>% paste(collapse = ";")
     }
   
   summarised_tibble_annotation <- summarised_tibble_annotation %>% add_column(
     "any_first_exon" = any(c(grep(x = .$first_or_last_exon_reference, pattern = "first_exon") %>% na.omit, 
                              grep(x = .$first_or_last_exon_recon, pattern = "first_exon") %>% na.omit)),
     "any_last_exon" = any(c(grep(x = .$first_or_last_exon_reference, pattern = "last_exon") %>% na.omit, 
                             grep(x = .$first_or_last_exon_recon, pattern = "last_exon") %>% na.omit)),
     "any_NMD" = any(c(grep(x = .$NMD_reference, pattern = "TRUE") %>% na.omit,
                       grep(x = .$NMD_recon, pattern = "TRUE") %>% na.omit)), .after = "NMD_flagged_recon")
  
  return(summarised_tibble_annotation)
  
}, .progress = TRUE, .options = future_options(globals = c("as_tibble", "tibble_ref_gtf", "tibble_recon_gtf")))

# tibblize
tibble_as.event.id_with_summarised_annotation_IR <- list_ref_matching_exon_entries_all_array.tree_IR_reannotated %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble

# save.image(file = paste(R_processing_results_dir, "04082020_halfway.RData", sep = ""))

```

### bind rows for final summarised exon reference annotation

```{r}

tibble_ref_matching_exon_entries_all_summarised <- dplyr::bind_rows(tibble_as.event.id_with_summarised_annotation_IR %>% type_convert %>% type_convert, 
                                                                    # look at this shit LOL
                                                                    tibble_ref_matching_exon_entries_all_not.IR_summarised %>% type_convert %>% type_convert)

# left join of the annotated exon info onto the PSI-Sigma result tables
long_tibble_of_psisigma_DEXSeq_results <- dplyr::left_join(wide_tibble_of_psisigma_results_allcomparisons_processed, tibble_ref_matching_exon_entries_all_summarised, by = c("event_region_coords" ,"diff_exon_coords", "splicemode", "chr", "diff_exon_start", "diff_exon_end", "event_region_start", "event_region_end")) %>% dplyr::mutate_if(is.factor, as.character)

# reorder columns
long_tibble_of_psisigma_DEXSeq_results <- long_tibble_of_psisigma_DEXSeq_results[, c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "psisigma_gene.symbol", "psisigma_reference.transcript", "psisigma_exon_type", "chr", "diff_exon_start", "diff_exon_end", "event_region_start", "event_region_end", "matched_gene_names", "matched_recon_transcript_names", "matched_ref_transcript_names", "matched_strand", "NMD_biotype_reference", "NMD_flagged_ref", "NMD_flagged_recon", "any_NMD", "poison_exon_candidate_ref", "poison_exon_candidate_recon", "contains_PTC_ref", "contains_PTC_recon", "first_or_last_exon_reference", "first_or_last_exon_recon", "any_first_exon", "any_last_exon", "num.replicates_comparison.1", "num.replicates_comparison.2", "pvalue", "FDR", "dpsi", "comparison.1_absolute.psi_1", "comparison.1_absolute.psi_2", "comparison.1_absolute.psi_3", "comparison.2_absolute.psi_1", "comparison.2_absolute.psi_2", "comparison.2_absolute.psi_3", "comparison")]

cat("There are", long_tibble_of_psisigma_DEXSeq_results[, c("event_region_coords", "diff_exon_coords")] %>% unique %>% nrow, "exons detected in total (at least one observation across the entire time series)")

# remove exons which have less than 2 observations in both comparisons
long_tibble_of_psisigma_DEXSeq_results <- long_tibble_of_psisigma_DEXSeq_results %>% dplyr::filter(., num.replicates_comparison.1 >= 2 & num.replicates_comparison.2 >= 2) %>% mutate_if(is.factor, as.character) %>% type_convert

```

### add gene info for those entries which still don't have gene info 
#### if couldn't directly match reference/recon, use the PSI-Sigma gene symbol instead

```{r}

# get row indices of those that do not have strand info
row.indices_na_matched_gene_name <- which(is.na(long_tibble_of_psisigma_DEXSeq_results$matched_gene_names))

# migrate PSI-sigma gene symbols to the match column
long_tibble_of_psisigma_DEXSeq_results[row.indices_na_matched_gene_name, "matched_gene_names"] <- long_tibble_of_psisigma_DEXSeq_results[row.indices_na_matched_gene_name, "psisigma_gene.symbol"]

```

### add strand for those entries which still don't have strand info 
#### if couldn't directly match reference/recon, use the PSI-Sigma gene symbol to get strand info

```{r}

# get row indices of those that do not have strand info
row.indices_na_matched_strand <- which(is.na(long_tibble_of_psisigma_DEXSeq_results$matched_strand))

# purrr::map to look up the reference GTF strand of each row based on psi sigma gene symbol
list_missing_strand_info <- future_map(.x = row.indices_na_matched_strand, .f = ~tibble_ref_gtf[tibble_ref_gtf$gene_name == long_tibble_of_psisigma_DEXSeq_results[.x, "psisigma_gene.symbol"] %>% paste, "strand"] %>% unlist %>% unique %>% paste, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "long_tibble_of_psisigma_DEXSeq_results")))

# if the strand info is ambiguous, then we just star the strand
list_missing_strand_info <- list_missing_strand_info %>% purrr::map(.f = function(.x) {
  if (length(.x) > 1) {
    return("*")
  } else if (length(.x) == 0) {
    return(NA)
  } else { 
    return(.x)
      }
  } )

long_tibble_of_psisigma_DEXSeq_results[row.indices_na_matched_strand, "matched_strand"] <- list_missing_strand_info %>% unlist

cat("there are", which(is.na(long_tibble_of_psisigma_DEXSeq_results$matched_strand)) %>% length, "rows with missing strand info\n")

# this is the FINAL tibble of all all comparisons ######
# export #
write.table(x = long_tibble_of_psisigma_DEXSeq_results, file = paste(R_processing_results_dir, "table_of_all_psi.sigma_results.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# write all unique genes as background
vec_all_psi.sigma_genes_genesymbol <- long_tibble_of_psisigma_DEXSeq_results$matched_gene_names %>% unique
write.table(x = vec_all_psi.sigma_genes_genesymbol, file = paste(R_processing_results_dir, "table_of_all_psi.sigma_genes_genesymbol.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
# convert to ENSG
vec_all_psi.sigma_genes_ENSG <- getBM(filters = "external_gene_name", values = vec_all_psi.sigma_genes_genesymbol, attributes = "ensembl_gene_id", mart = ensembl_mart)
write.table(x = vec_all_psi.sigma_genes_ENSG, file = paste(R_processing_results_dir, "table_of_all_psi.sigma_genes_ENSG.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

# save image (for katana use)
# save.image(paste(R_processing_results_dir, "04082020_psisigma_dexseq_processed.RData", sep = ""))

```

# Run DEXSeq

## Create environment

### load packages and data

```{r}

DEXSeq_dir <- paste(R_processing_results_dir, "DEXSeq/", sep = "")

if(! dir.exists(DEXSeq_dir) ) {
  dir.create(DEXSeq_dir, recursive = TRUE)}

long_tibble_of_psisigma_DEXSeq_results <- read.delim(file = paste(R_processing_results_dir, "table_of_all_psi.sigma_results.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

# get example
# tibble_example_jum_dexseq_gff <- rtracklayer::import("/media/sbi/4tb_ironwolf/PGNEXUS_OBseries/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/JUM_diff/combined_AS_JUM.gff") %>% as_tibble

```

## get denominator and numerator values

### load the denominator values (.gct)

```{r}

list_of_psisigma_denominator_gct_tibbles <- future_map(.x = vector_of_comparisons_final, .f = ~read.delim(paste(psisigma_results_dir, .x, "/", .x, "_r1_ir3.denominator.gct", sep = ""), skip = 2, sep = "\t") %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble", "psisigma_results_dir"))) %>% 
  set_names(vector_of_comparisons_final)

# save(list_of_psisigma_denominator_gct_tibbles, file = paste(R_processing_results_dir, "list_of_psisigma_denominator_gct_tibbles.Rlist", sep = ""))
# load(file = paste(R_processing_results_dir, "list_of_psisigma_denominator_gct_tibbles.Rlist", sep = ""))

```

### process the denominator tibbles

- get rid of the gene name in the "Event" column and rename it to database_ID
- add comparison column
- rename each column to not be comparison specific
- get rid of the NMD column

```{r}

list_of_psisigma_denominator_gct_tibbles_processed <- purrr::map2(.x = list_of_psisigma_denominator_gct_tibbles, 
                                                                 .y = names(list_of_psisigma_denominator_gct_tibbles),
                                                                 .f = function(a1, a2) {
                                                                   
                                                                   tibble_temp <- a1
                                                                   
                                                                   tibble_temp[, "Event"] <- gsub(x = tibble_temp$Event, pattern = "^(.*{0,1}\\:)(.*)", replacement = "\\2")
                                                                   
                                                                   tibble_temp <- tibble_temp %>% 
                                                                     add_column("comparison" = a2) %>%
                                                                     dplyr::select(-Annotation) %>% 
                                                                     setNames(c("database_ID", "comparison.1_denominator_1", "comparison.1_denominator_2", "comparison.1_denominator_3", "comparison.2_denominator_1", "comparison.2_denominator_2", "comparison.2_denominator_3", "comparison"))
                                                                     
                                                                     return(tibble_temp)
                                                                   
                                                                 } )

# rbind and tibblise
long_tibble_psisigma_denominator_gct_tibbles_processed <- list_of_psisigma_denominator_gct_tibbles_processed %>% rbindlist %>% as_tibble

```

### table join onto the main psisigma table

```{r}

wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator <- dplyr::left_join(long_tibble_of_psisigma_DEXSeq_results, long_tibble_psisigma_denominator_gct_tibbles_processed, by = c("database_ID", "comparison")) %>% type_convert(na = c("", "na", "NA"))

```

### add back the numerator

numerator = psi * denominator

```{r}

wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator %>% 
  dplyr::mutate("comparison.1_numerator_1" = comparison.1_absolute.psi_1 * comparison.1_denominator_1 * 0.01) %>%
  dplyr::mutate("comparison.1_numerator_2" = comparison.1_absolute.psi_2 * comparison.1_denominator_2 * 0.01) %>%
  dplyr::mutate("comparison.1_numerator_3" = comparison.1_absolute.psi_3 * comparison.1_denominator_3 * 0.01) %>%
  
  dplyr::mutate("comparison.2_numerator_1" = comparison.2_absolute.psi_1 * comparison.2_denominator_1 * 0.01) %>%
  dplyr::mutate("comparison.2_numerator_2" = comparison.2_absolute.psi_2 * comparison.2_denominator_2 * 0.01) %>%
  dplyr::mutate("comparison.2_numerator_3" = comparison.2_absolute.psi_3 * comparison.2_denominator_3 * 0.01) %>% 
  # add in the ER values
  dplyr::mutate("comparison.1_ER_1" = comparison.1_denominator_1 - comparison.1_numerator_1) %>%
  dplyr::mutate("comparison.1_ER_2" = comparison.1_denominator_2 - comparison.1_numerator_2) %>%
  dplyr::mutate("comparison.1_ER_3" = comparison.1_denominator_3 - comparison.1_numerator_3) %>%
  
  dplyr::mutate("comparison.2_ER_1" = comparison.2_denominator_1 - comparison.2_numerator_1) %>%
  dplyr::mutate("comparison.2_ER_2" = comparison.2_denominator_2 - comparison.2_numerator_2) %>%
  dplyr::mutate("comparison.2_ER_3" = comparison.2_denominator_3 - comparison.2_numerator_3)

```

### add id column for traceability

```{r}

wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator %>% add_column("id" = paste("id_", 1:nrow(.), sep = ""), .before = 1)

```

### write the tibble of numerator and denominator

```{r}

write.table(x = wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator, file = paste(R_processing_results_dir, "wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator <- read.delim(file = paste(R_processing_results_dir, "wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

```

### filter for only exons with at least 5 inclusion reads in 3 samples. (numerator)

```{r}

# create logical test 
## logical test based on numerator of comparison 1
vector_logical_5_in_at_least_3_comparison_1 <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator[, c("comparison.1_numerator_1", "comparison.1_numerator_2", "comparison.1_numerator_3")] %>% array_tree(margin = 1) %>% future_map(.f = ~(all((.x %>% na.omit > 5)) & any(is.na(.x)) != TRUE), .progress = TRUE) %>% unlist
## logical test based on numerator of comparison 2
vector_logical_5_in_at_least_3_comparison_2 <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator[, c("comparison.2_numerator_1", "comparison.2_numerator_2", "comparison.2_numerator_3")] %>% array_tree(margin = 1) %>% future_map(.f = ~(all((.x %>% na.omit > 5)) & any(is.na(.x)) != TRUE), .progress = TRUE) %>% unlist

vector_logical_5_in_at_least_3 <- (vector_logical_5_in_at_least_3_comparison_1 == TRUE) | (vector_logical_5_in_at_least_3_comparison_2 == TRUE)

# retrieve row indices which are valid
vector_row.indices_5_in_at_least_3 <- which(vector_logical_5_in_at_least_3 == TRUE)

wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3 <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator[vector_row.indices_5_in_at_least_3, ]

# write table
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3, file = paste(R_processing_results_dir, "wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3 <- read.delim(file = paste(R_processing_results_dir, "wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

```

## create GFF of pseudotranscripts

- each differential exon belonging to an approximate Local Isoform Variant will have its own pseudotranscript.
- each pseudotranscript has two exons. Exon 1: the differential exon count; Exon 2: The denominator (spanning the entirety of the event region)

### build GFF tibble and export for each comparison

```{r}

# group_split the wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3
list_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3_by_comparison <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3 %>% dplyr::group_split(comparison)

names(list_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3_by_comparison) <- list_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3_by_comparison %>% purrr::map(~.x$comparison %>% unique) %>% unlist

purrr::map2(.x = list_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3_by_comparison, 
            .y = names(list_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3_by_comparison), 
            .f = function(a1, a2) {
              
              cat("now processing: ", a2)
              
              # only use distinct exons needed to build the GFF
              tibble_GFF_building_exons_info <- a1 %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, .keep_all = TRUE)
              
              # list-ify by each exon
              list_GFF_building_exons_info <- tibble_GFF_building_exons_info %>% 
                array_tree %>%
                # add in the event region start and end
                future_map(.f = ~purrr::splice(.x, 
                                               "event_region_start" = gsub(x = .x$event_region_coords, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(.*)$", replacement = "\\2"),
                                               "event_region_end" = gsub(x = .x$event_region_coords, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(.*)$", replacement = "\\3")), 
                           .progress = TRUE, .options = future_options(globals = c("purrr::splice", "gsub")))
              
              # create pseudotranscript entries for each L1 element
              ## it goes: 
              ## row 1: aggregate_gene
              ## row 2: the exon (001)
              ## row 3: the denominator (002)
              
              # note that we'll have to add in the width later.
              # note2: gene_id is taken as the id column for GFF compatibility purposes.
              list_GFF_building_tibble <- future_map(.x = list_GFF_building_exons_info, 
                                                     .f = ~tibble("seqnames" = .x$chr,
                                                                  "start" = c(.x$event_region_start, .x$diff_exon_start, .x$event_region_start),
                                                                  "end" = c(.x$event_region_end, .x$diff_exon_end, .x$event_region_end),
                                                                  "strand" = .x$matched_strand,
                                                                  "source" = "PSISigma_combined_BM.MSC_to_OB_2012_PGNEXUS",
                                                                  "type" = c("aggregate_gene", "exonic_part", "exonic_part"),
                                                                  "score" = NA,
                                                                  "phase" = NA,
                                                                  "exonic_part_number" = c(NA, "001", "002"),
                                                                  "gene_id" = .x$id),
                                                     .progress = TRUE, .options = future_options(globals = c("tibble")))
              
              # rbind, tibblise and add width, modify data classes
              tibble_combined_GFF0 <- list_GFF_building_tibble %>% rbindlist %>% as_tibble %>%
                type_convert %>% type_convert %>%
                add_column("width" = .$end - .$start, .after = "end")
              
              # where start > end, flip them around and negate the width.
              # fking hell.
              tibble_combined_GFF1 <- tibble_combined_GFF0
              ## flip start/end
              tibble_combined_GFF1[which(tibble_combined_GFF0$width < 0), "start"] <- tibble_combined_GFF0[which(tibble_combined_GFF0$width < 0), "end"]
              tibble_combined_GFF1[which(tibble_combined_GFF0$width < 0), "end"] <- tibble_combined_GFF0[which(tibble_combined_GFF0$width < 0), "start"]
              ## negate width
              tibble_combined_GFF1[which(tibble_combined_GFF0$width < 0), "width"] <- -tibble_combined_GFF0[which(tibble_combined_GFF0$width < 0), "width"]
              
              tibble_combined_GFF1[which(is.na(tibble_combined_GFF1$strand)), "strand"] <- "*"
              
              rtracklayer::export(object = tibble_combined_GFF1, con = paste(DEXSeq_dir, a2, "_combined_dexseq_GFF_PSISigma.gff", sep = ""), format = "gff2")

            } )

```

## Create text file of counts

- 001: IR
- 002: ER = denominator - IR

### build tibble per comparison

- do for each comparison
- 2 columns: column 1: gene:001 or 002, column 2: count(numerator or denominator - numerator)

```{r}

# map each comparison >> map each replicate
list_combined_count_tibbles <- purrr::map(
  .x = list_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3_by_comparison,
  .f = function(a1) {
    
    list(
      "comparison.1_replicate_1" = dplyr::bind_rows(tibble("gene:exon" = paste(a1$id, ":001", sep = ""),
                                                           "count" = a1$comparison.1_numerator_1), 
                                                    tibble("gene:exon" = paste(a1$id, ":002", sep = ""),
                                                           "count" = (a1$comparison.1_denominator_1) - (a1$comparison.1_numerator_1))),
      "comparison.1_replicate_2" = dplyr::bind_rows(tibble("gene:exon" = paste(a1$id, ":001", sep = ""),
                                                           "count" = a1$comparison.1_numerator_2), 
                                                    tibble("gene:exon" = paste(a1$id, ":002", sep = ""),
                                                           "count" = (a1$comparison.1_denominator_2) - (a1$comparison.1_numerator_2))),
      "comparison.1_replicate_3" = dplyr::bind_rows(tibble("gene:exon" = paste(a1$id, ":001", sep = ""),
                                                           "count" = a1$comparison.1_numerator_3), 
                                                    tibble("gene:exon" = paste(a1$id, ":002", sep = ""),
                                                           "count" = (a1$comparison.1_denominator_3) - (a1$comparison.1_numerator_3))),
      
      "comparison.2_replicate_1" = dplyr::bind_rows(tibble("gene:exon" = paste(a1$id, ":001", sep = ""),
                                                           "count" = a1$comparison.2_numerator_1), 
                                                    tibble("gene:exon" = paste(a1$id, ":002", sep = ""),
                                                           "count" = (a1$comparison.2_denominator_1) - (a1$comparison.2_numerator_1))),
      "comparison.2_replicate_2" = dplyr::bind_rows(tibble("gene:exon" = paste(a1$id, ":001", sep = ""),
                                                           "count" = a1$comparison.2_numerator_2), 
                                                    tibble("gene:exon" = paste(a1$id, ":002", sep = ""),
                                                           "count" = (a1$comparison.2_denominator_2) - (a1$comparison.2_numerator_2))),
      "comparison.2_replicate_3" = dplyr::bind_rows(tibble("gene:exon" = paste(a1$id, ":001", sep = ""),
                                                           "count" = a1$comparison.2_numerator_3), 
                                                    tibble("gene:exon" = paste(a1$id, ":002", sep = ""),
                                                           "count" = (a1$comparison.2_denominator_3) - (a1$comparison.2_numerator_3)))
    )
    
  } )

# write tibbles
future_map2(.x = list_combined_count_tibbles, 
            .y = names(list_combined_count_tibbles),
            .f = function(a1, a2) {
              
              purrr::map2(.x = a1,
                          .y = names(a1),
                          .f = function(b1, b2) {
                            
                            # get the replicate number for L2 element
                            replicate_number <- gsub(x = b2, pattern = "comparison.([1-2])_replicate_(.*)", replacement = "\\2")
                            # get the comparison number for L2 element. and refer back to comparison
                            comparison_number <- gsub(x = b2, pattern = "comparison.([1-2])_replicate_(.*)", replacement = "\\1")
                            # get timepoint from comparison name
                            comparison_name <- gsub(x = a2, pattern = "^(.*)_vs_(.*)", replacement = paste("\\", comparison_number, sep = ""))
                            
                            b1[is.na(b1)] <- 0
                            
                            write.table(x = b1 %>% .[mixedorder(.$`gene:exon`), ] %>% dplyr::mutate_at(.vars = "count", round), file = paste(DEXSeq_dir, a2, "_comparison", comparison_number, "r", replicate_number, "_combined_count.txt", sep = ""), sep = "\t", quote = FALSE, col.names = FALSE, row.names = FALSE)
                            
                          } )
              
            }, .progress = TRUE )

```

## run DEXSeq for each comparison

```{r}

library(DEXSeq)

list_DEXSeq_results <- purrr::map(.x = vector_of_comparisons_final,
           .f = function(a1) {
             
             cat("now processing: ", a1)
             
             DEXSeqDataSet_PSISigma <-  DEXSeqDataSetFromHTSeq(
               countfiles = list.files(path = DEXSeq_dir, pattern = paste(a1, ".*.txt", sep = ""), full.names = TRUE),
               sampleData = data.frame("replicatename" = paste(a1, c("_comparison1r1_combined_count.txt", "_comparison1r2_combined_count.txt", "_comparison1r3_combined_count.txt", "_comparison2r1_combined_count.txt", "_comparison2r2_combined_count.txt", "_comparison2r3_combined_count.txt"), sep = ""),
                                       "condition" = c(rep(gsub(x = a1, pattern = "(.*)_vs_(.*)", replacement = "\\1"), times = 3), rep(gsub(x = a1, pattern = "(.*)_vs_(.*)", replacement = "\\2"), times = 3))),
               design = ~ sample + exon + condition:exon,
               flattenedfile = paste(DEXSeq_dir, a1, "_combined_dexseq_GFF_PSISigma.gff", sep = ""))
             
             DEXSeqDataSet_PSISigma = estimateSizeFactors(DEXSeqDataSet_PSISigma)
             DEXSeqDataSet_PSISigma = estimateDispersions(DEXSeqDataSet_PSISigma, BPPARAM = MulticoreParam(workers = 8, progressbar = TRUE))
             
             DEXSeqDataSet_PSISigma = testForDEU(DEXSeqDataSet_PSISigma, BPPARAM = MulticoreParam(workers = 8, progressbar = TRUE))
             DEXSeqDataSet_PSISigma = DEXSeq::estimateExonFoldChanges(DEXSeqDataSet_PSISigma, fitExpToVar = "condition", maxRowsMF = 5000, BPPARAM = MulticoreParam(workers = 8, progressbar = TRUE))
             
             tibble_dexseq_results <- DEXSeqResults(DEXSeqDataSet_PSISigma) %>% as_tibble %>% add_column("comparison" = a1)
             
             return(list("DEXSeq_object" = DEXSeqDataSet_PSISigma,
                         "tibble_results" = tibble_dexseq_results))
             
           } )

names(list_DEXSeq_results) <- vector_of_comparisons_final

# rename the tibble column names
list_DEXSeq_results <- list_DEXSeq_results %>% purrr::map(~modify_at(.x = .x, .at = "tibble_results", .f = function(b1) {
  
  tibble <- b1
  
  colnames(tibble) <- c("id", "featureID", "DEXSeq_exonBaseMean", "DEXSeq_dispersion", "DEXSeq_stat", "DEXSeq_pvalue", "DEXSeq_padj", "DEXSeq_logCPM_first", "DEXSeq_logCPM_second", "DEXSeq_log2FC_second_minus_first", "genomicData.seqnames", "genomicData.start", "genomicData.end", "genomicData.width", "genomicData.strand", "countData.1", "countData.2", "countData.3", "countData.4", "countData.5", "countData.6", "transcripts", "comparison")
  
  return(tibble)
  
} ))

save(list_DEXSeq_results, file = paste(DEXSeq_dir, "list_DEXSeq_results.Rlist", sep = ""))
# load(file = paste(DEXSeq_dir, "list_DEXSeq_results.Rlist", sep = ""))

# plot the statistics for each comparison
## this purrr returns nothing
future_map2(.x = list_DEXSeq_results,
            .y = names(list_DEXSeq_results),
           .f = function(a1, a2) {
             
             pdf(paste(DEXSeq_dir, "DEXSeq_dispersion_estimates_", a2, ".pdf", sep = ""))
             plotDispEsts(a1$DEXSeq_object)
             dev.off()
             
             pdf(paste(DEXSeq_dir, "DEXSeq_MAplot_", a2, ".pdf", sep = ""))
             plotMA(a1$DEXSeq_object, cex = 0.8)
             dev.off()
             
             pdf(paste(DEXSeq_dir, "DEXSeq_pvalue_distributions_", a2, ".pdf", sep = ""))
             plot(density(a1$tibble_results$DEXSeq_pvalue %>% na.omit))
             dev.off()
             
             # my own volcano plot
             ggplot(data = a1$tibble_results, mapping = aes(x = DEXSeq_log2FC_second_minus_first, y = -(DEXSeq_padj %>% log10))) +
               geom_point(size = 2) +
               ggtitle(paste("Volcano Plot for PSI-Sigma/DEXSeq", sep = "\n")) +
               guides(size = FALSE) + 
               xlab(expression(log[2](Fold~Change))) +
               # (P[BH])
               ylab(expression(-log[10](P[BH]))) +
               geom_hline(yintercept = -log10(0.01), col = "red", lty = 2) + 
               geom_vline(xintercept = -log2(1), col = "red", lty = 2) + 
               geom_vline(xintercept = log2(1), col = "red", lty = 2) +
               theme_bw() +
               theme(text = element_text(family = "Helvetica")) +
               ggsave(filename = paste(DEXSeq_dir, "DEXSeq_volcanoplot_", a2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 15, units = "cm") +
               ggsave(filename = paste(DEXSeq_dir, "DEXSeq_volcanoplot_", a2, ".svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 15, units = "cm")
             
           }, .progress = TRUE, .options = future_options(globals = c("plotDispEsts", "plotMA", "DEXSeq_dir")))

```

## Calculate PSI

```{r}

## extract only the result tibbles
list_DEXSeq_results_tibble.only <- list_DEXSeq_results %>% purrr::map(~.x$tibble_results)

list_DEXSeq_results_tibble.only_with_PSI <- purrr::map2(.x = list_DEXSeq_results_tibble.only,
                                                        .y = names(list_DEXSeq_results_tibble.only),
                                                        .f = function(a1, a2) {
                                                          
                                                          # DEBUG ###
                                                          # a1 <- list_DEXSeq_results_tibble.only[[1]]
                                                          ###########
                                                          
                                                          tibble <- a1 %>% 
                                                            dplyr::mutate("DEXSeq_IR_first" = 2^DEXSeq_logCPM_first,
                                                                          "DEXSeq_IR_second" = 2^DEXSeq_logCPM_second) %>%
                                                            dplyr::group_by(id) %>% 
                                                            dplyr::mutate("DEXSeq_pseudotranscript_IR_plus_ER_first" = sum(DEXSeq_IR_first),
                                                                          "DEXSeq_pseudotranscript_IR_plus_ER_second" = sum(DEXSeq_IR_second)) %>%
                                                            dplyr::ungroup() %>%
                                                            dplyr::filter(featureID == "E001") %>%
                                                            dplyr::mutate("DEXSeq_PSI_first" = DEXSeq_IR_first/DEXSeq_pseudotranscript_IR_plus_ER_first,
                                                                          "DEXSeq_PSI_second" = DEXSeq_IR_second/DEXSeq_pseudotranscript_IR_plus_ER_second) %>%
                                                            dplyr::mutate("DEXSeq_dpsi" = DEXSeq_PSI_first - DEXSeq_PSI_second)
                                                            
                                                        } )

# plot the dpsi distributions
future_map2(.x = list_DEXSeq_results_tibble.only_with_PSI,
            .y = names(list_DEXSeq_results_tibble.only_with_PSI),
           .f = function(a1, a2) {
             
             pdf(paste(DEXSeq_dir, "DEXSeq_dpsi_density_distributions_", a2, ".pdf", sep = ""))
             plot(density(a1$DEXSeq_dpsi %>% na.omit))
             dev.off()
             
             pdf(paste(DEXSeq_dir, "DEXSeq_dpsi_cdf_distributions_", a2, ".pdf", sep = ""))
             plot(ecdf(a1$DEXSeq_dpsi %>% na.omit))
             dev.off()
             
           }, .progress = TRUE, .options = future_options(globals = c("DEXSeq_dir")))

```

## Bind the DEXSeq results onto the master PSI-Sigma table. This is final.

```{r}

# rbind and tibblise
long_tibble_DEXSeq_results_with_PSI <- list_DEXSeq_results_tibble.only_with_PSI %>% rbindlist %>% as_tibble %>%
# select only cols that are informative
  dplyr::select(id, DEXSeq_exonBaseMean, DEXSeq_dispersion, DEXSeq_stat, DEXSeq_pvalue, DEXSeq_padj, DEXSeq_log2FC_second_minus_first, comparison, DEXSeq_IR_first, DEXSeq_IR_second, DEXSeq_pseudotranscript_IR_plus_ER_first, DEXSeq_pseudotranscript_IR_plus_ER_second, DEXSeq_PSI_first, DEXSeq_PSI_second, DEXSeq_dpsi)

long_tibble_of_psisigma_DEXSeq_results <- dplyr::left_join(wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3, long_tibble_DEXSeq_results_with_PSI, by = c("id", "comparison"))

write.table(x = long_tibble_of_psisigma_DEXSeq_results, file = paste(R_processing_results_dir, "long_tibble_of_psisigma_DEXSeq_results.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# save image (for katana use)
# save.image(paste(R_processing_results_dir, "04082020_psisigma_dexseq_processed.RData", sep = ""))

```

# Space for running poison exon finder and coming back

```{r}

long_tibble_of_psisigma_DEXSeq_results <- read.delim(paste(R_processing_results_dir, "long_tibble_of_psisigma_DEXSeq_results.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# write coords for poison exon finder
write.table(x = long_tibble_of_psisigma_DEXSeq_results[, c("event_region_coords", "diff_exon_coords", "splicemode")] %>% dplyr::rename("VSR_coords" = "event_region_coords", "alternative_exon_coords" = "diff_exon_coords"), file = paste(R_processing_results_dir, "long_tibble_of_psisigma_DEXSeq_results_prepare_for_poison_exon_finder.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# comeback from poison exon finder
tibble_poison_exon_finder_results <- read.delim(paste(R_processing_results_dir, "PSISigma_all_exons_with_na_poison_exon_finder.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# create logical of whether exon introduces PTC or not
# filter for PTC-introducing exons only
# subset to simplify table
tibble_poison_exon_finder_results_processed0 <- tibble_poison_exon_finder_results %>%
  dplyr::mutate("introduces_PTC" = grepl(x = PTC_exists_in_alternative_exon, pattern = "TRUE")) %>%
  dplyr::filter(introduces_PTC == TRUE | has_frameshift == TRUE) %>% 
  dplyr::select(-list_three_frame_translation, -vector_transcript_segment_forward_genome_relative_coords, -list_forward_nucleotides)

# create a summary of each exon's PTC and frameshift behaviour, accounting for all matched ref. transcripts.
tibble_poison_exon_finder_results_processed1 <- tibble_poison_exon_finder_results_processed0 %>%
  dplyr::group_by(chr, VSR_start, VSR_end, alternative_exon_start, alternative_exon_end, splicemode) %>%
  dplyr::summarise(introduces_PTC_for_all_matched_transcripts = all(introduces_PTC == TRUE),
                   introduces_PTC_for_any_matched_transcripts = any(introduces_PTC == TRUE),
                   
                   alters_frame_for_all_matched_transcripts = all(has_frameshift == TRUE),
                   alters_frame_for_any_matched_transcripts = any(has_frameshift == TRUE)) %>% 
  dplyr::mutate("event_region_coords" = paste(chr, ":", VSR_start, "-", VSR_end, sep = ""),
                "diff_exon_coords" = paste(chr, ":", alternative_exon_start, "-", alternative_exon_end, sep = "")) %>%
  dplyr::ungroup() %>%
  dplyr::select(-VSR_start, -VSR_end, -alternative_exon_start, -alternative_exon_end, -chr)

# JOIN onto the main PSI-Sigma table
long_tibble_of_psisigma_DEXSeq_results <- dplyr::left_join(long_tibble_of_psisigma_DEXSeq_results, tibble_poison_exon_finder_results_processed1, by = c("event_region_coords", "diff_exon_coords", "splicemode"))

long_tibble_of_psisigma_DEXSeq_results[, c("introduces_PTC_for_all_matched_transcripts", "introduces_PTC_for_any_matched_transcripts", "alters_frame_for_all_matched_transcripts", "alters_frame_for_any_matched_transcripts")][is.na(long_tibble_of_psisigma_DEXSeq_results[, c("introduces_PTC_for_all_matched_transcripts", "introduces_PTC_for_any_matched_transcripts", "alters_frame_for_all_matched_transcripts", "alters_frame_for_any_matched_transcripts")])] <- FALSE

write.table(x = long_tibble_of_psisigma_DEXSeq_results, file = paste(R_processing_results_dir, "long_tibble_of_psisigma_DEXSeq_results_poison_exon_finder.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# Filter for differential exons

## set filter criteria, dpsi and pvalue

```{r}

long_tibble_of_psisigma_DEXSeq_results <- read.delim(paste(R_processing_results_dir, "long_tibble_of_psisigma_DEXSeq_results_poison_exon_finder.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

long_tibble_of_psisigma_DEXSeq_results[, "comparison"] <- gsub(x = long_tibble_of_psisigma_DEXSeq_results$comparison, pattern = "ud", replacement = "MSC")
long_tibble_of_psisigma_DEXSeq_results[, "comparison"] <- gsub(x = long_tibble_of_psisigma_DEXSeq_results$comparison, pattern = "24h", replacement = "1d")

# 2 choices: "pvalue" or "FDR" or DEXSeq_pvalue or DEXSeq_padj
pvalue_or_FDR <- "DEXSeq_padj"

dpsi_cutoff <- 15

pvalue_cutoff <- 0.01

```

## filter, return the co-ordinates of the differential LIVs (Local Isoform Variants)

- PSI-Sigma approximates local isoform variants using its indexing method
- When we sum up all LIVs in each Variable Splice Region (VSR), we should get the overall PSI for the exon in all isoforms of the gene.

```{r}

# filter dpsi, pvalue and also remove exons which have less than 2 observations in both comparisons
wide_tibble_of_psisigma_results_allcomparisons_differential <- long_tibble_of_psisigma_DEXSeq_results %>% dplyr::filter(., !!as.name(pvalue_or_FDR) <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & num.replicates_comparison.1 >= 2 & num.replicates_comparison.2 >= 2)

number.of.LIVs_differential_anysig_with_na <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode, chr, diff_exon_start, diff_exon_end, matched_strand) %>% nrow
number.of.exons_differential_anysig_with_na <- wide_tibble_of_psisigma_results_allcomparisons_differential$diff_exon_coords %>% unique %>% length

message("There are ", number.of.LIVs_differential_anysig_with_na, " differential LIVs using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)
message("There are ", number.of.exons_differential_anysig_with_na, " differential exons using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)

# get table of all differential exons info - for all timepoints and not just the significant timepoint.
## at the level of LIVs
wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV <- dplyr::semi_join(long_tibble_of_psisigma_DEXSeq_results, wide_tibble_of_psisigma_results_allcomparisons_differential, by = c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode"))
## write table
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV, file = paste(R_processing_results_dir, "long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV", number.of.LIVs_differential_anysig_with_na, "_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# export associated gene set
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV$matched_gene_names %>% unique %>% na.omit %>% mixedsort, file = paste(R_processing_results_dir, "geneset_of_differential_LIV_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV$matched_gene_names %>% unique %>% na.omit %>% length, "genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

# get table at the level of exons.
wide_tibble_of_psisigma_results_allcomparisons_differential_info_exons <- dplyr::semi_join(long_tibble_of_psisigma_DEXSeq_results, wide_tibble_of_psisigma_results_allcomparisons_differential, by = c("diff_exon_coords"))
## write
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_differential_info_exons, file = paste(R_processing_results_dir, "long_tibble_of_psisigma_results_allcomparisons_differential_info_exons", number.of.exons_differential_anysig_with_na, "_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write coords for three-frame translation
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_differential_info_exons[, c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")] %>% 
              dplyr::rename("VSR_coords" = "event_region_coords", "alternative_exon_coords" = "diff_exon_coords", "gene_name" = "matched_gene_names") %>% 
              add_column("organism" = "Homo sapiens", "custom_identifier" = NA), file = paste(R_processing_results_dir, "long_tibble_of_psisigma_allcomparisons_differential_exons", number.of.exons_differential_anysig_with_na, "_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_anysig_with_na_3FT.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# also write table of differential information for 12d vs. MSC
tibble_differential_results_12d_vs_ud <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::filter(comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_MSC" & !!as.name(pvalue_or_FDR) <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff)
# write table
write.table(x = tibble_differential_results_12d_vs_ud, file = paste(R_processing_results_dir, "long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV", tibble_differential_results_12d_vs_ud %>% nrow, "_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_12d.vs.ud_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# export associated gene set
write.table(x = tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% na.omit %>% mixedsort, file = paste(R_processing_results_dir, "geneset_differential_LIV_", tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% length, "genes_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_12d.vs.ud_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

cat("There are", tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% na.omit %>% length, "differential genes between MSC and 12d only, using the specified cutoff of", pvalue_or_FDR, "<", pvalue_cutoff, "and dpsi > ", dpsi_cutoff)

```

## plot graph of the cumulative changes

### create tibble of cumulative differential changes, excluding each timepoint successively and filtering by logFC.

```{r}

# filter for IR or non-IR events here
wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR <- wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>%
  dplyr::filter(str_detect(string = `splicemode`, pattern = "IR"))

wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR <- wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>%
  dplyr::filter(!str_detect(string = `splicemode`, pattern = "IR"))

tibble_cumulative_diff_changes_total <- tibble("timepoint" = vector_OBseries_timepoints_edited, 
                                         "cumulative_diff_changes" = 
                                           c(0, 
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d") & !str_detect(string = comparison, pattern = "1d") & !str_detect(string = comparison, pattern = "12h")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d") & !str_detect(string = comparison, pattern = "1d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff) %>% .$diff_exon_coords %>% unique %>% length)) %>% 
  add_column("cumulative_diff_changes_pct" = .$cumulative_diff_changes * 100 / (.$cumulative_diff_changes %>% max))

tibble_cumulative_diff_changes_IR <- tibble("timepoint" = vector_OBseries_timepoints_edited, 
                                         "cumulative_diff_changes" = 
                                           c(0, 
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d") & !str_detect(string = comparison, pattern = "1d") & !str_detect(string = comparison, pattern = "12h")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d") & !str_detect(string = comparison, pattern = "1d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff) %>% .$diff_exon_coords %>% unique %>% length)) %>% 
  add_column("cumulative_diff_changes_pct" = .$cumulative_diff_changes * 100 / (.$cumulative_diff_changes %>% max))

tibble_cumulative_diff_changes_non.IR <- tibble("timepoint" = vector_OBseries_timepoints_edited, 
                                         "cumulative_diff_changes" = 
                                           c(0, 
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d") & !str_detect(string = comparison, pattern = "1d") & !str_detect(string = comparison, pattern = "12h")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d") & !str_detect(string = comparison, pattern = "1d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d") & !str_detect(string = comparison, pattern = "3d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d") & !str_detect(string = comparison, pattern = "6d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d") & !str_detect(string = comparison, pattern = "9d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & !str_detect(string = comparison, pattern = "12d")) %>% .$diff_exon_coords %>% unique %>% length,
                                             wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_non.IR %>% dplyr::filter(pvalue <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff) %>% .$diff_exon_coords %>% unique %>% length)) %>% 
  add_column("cumulative_diff_changes_pct" = .$cumulative_diff_changes * 100 / (.$cumulative_diff_changes %>% max))

```

### GGPLOT

```{r}

ggplot(tibble_cumulative_diff_changes_total, aes(y = cumulative_diff_changes_pct, x = timepoint)) +
  # geom_point() +
  geom_line(aes(group = "OBseries"), colour = "firebrick4") +
  ggtitle("Cumulative changes in the hMSC-TERT4 spliceome\nOsteogenesis\nPSI-Sigma (LIVs, total)") +
  xlab("Timepoint") +
  ylab("Cumulative differential changes") +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes_total_OBseries.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 12, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes_total_OBseries.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 12, units = "cm")

ggplot(tibble_cumulative_diff_changes_IR, aes(y = cumulative_diff_changes_pct, x = timepoint)) +
  # geom_point() +
  geom_line(aes(group = "OBseries"), colour = "firebrick4") +
  ggtitle("Cumulative changes in the hMSC-TERT4 spliceome\nOsteogenesis\nPSI-Sigma (LIVs, IR)") +
  xlab("Timepoint") +
  ylab("Cumulative differential changes") +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes_IR_OBseries.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 12, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes_IR_OBseries.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 12, units = "cm")

ggplot(tibble_cumulative_diff_changes_non.IR, aes(y = cumulative_diff_changes_pct, x = timepoint)) +
  # geom_point() +
  geom_line(aes(group = "OBseries"), colour = "firebrick4") +
  ggtitle("Cumulative changes in the hMSC-TERT4 spliceome\nOsteogenesis\nPSI-Sigma (LIVs, non-IR)") +
  xlab("Timepoint") +
  ylab("Cumulative differential changes") +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes_non.IR_OBseries.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 12, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes_non.IR_OBseries.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 12, units = "cm")

```

### Plot the distributions of dpsi

```{r}

# all (LIV PSI)
pdf(paste(R_processing_results_dir, "plot_of_absolute_dpsi_changes_LIV_all.pdf", sep = ""), width = 5, height = 5)
plot(density(long_tibble_of_psisigma_DEXSeq_results$dpsi %>% abs, bw = 1), 
     main = "Distribution of absolute magnitude of change in dpsi, PSI-Sigma (LIVs)", 
     xlab = "Absolute dPSI in any direction (%)",
     ylab = "Frequency density",
     col = "firebrick4", 
     xaxt = "n",
     xlim = c(0, 100)) + 
  polygon(density(long_tibble_of_psisigma_DEXSeq_results$dpsi %>% abs, bw = 1),
          col = alpha("firebrick4", 0.33),
          border = FALSE,
          xaxt = "n",
          xlim = c(0, 100)) +
  axis(side = 1, at = seq(0, 100, by = 20), labels = seq(0, 100, by = 20))
dev.off()

# LIV PSI - differential
pdf(paste(R_processing_results_dir, "plot_of_absolute_dpsi_changes_LIV_diff.pdf", sep = ""), width = 5, height = 5)
plot(density(wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV$dpsi %>% abs, bw = 1), 
     main = "Distribution of absolute magnitude of change in dpsi, PSI-Sigma (LIVs)", 
     xlab = "Absolute dPSI in any direction (%)",
     ylab = "Frequency density",
     col = "firebrick4", 
     xaxt = "n",
     xlim = c(0, 100)) + 
  polygon(density(wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV$dpsi %>% abs, bw = 1),
          col = alpha("firebrick4", 0.33),
          border = FALSE,
          xaxt = "n",
          xlim = c(0, 100)) +
  axis(side = 1, at = seq(0, 100, by = 20), labels = seq(0, 100, by = 20))
dev.off()

# exon PSI - differential
pdf(paste(R_processing_results_dir, "plot_of_absolute_dpsi_changes_exon_diff.pdf", sep = ""), width = 5, height = 5)
plot(density(wide_tibble_of_psisigma_results_allcomparisons_differential_info_exons %>% dplyr::group_by(diff_exon_coords) %>% dplyr::summarise("exon_dpsi" = sum(dpsi, na.rm = TRUE)) %>% .$exon_dpsi %>% abs), 
     main = "Distribution of absolute magnitude of change in dpsi, PSI-Sigma (exons)", 
     xlab = "Absolute dPSI in any direction (%)",
     ylab = "Frequency density",
     col = "firebrick4") +
  # ,
  # xaxt = "n",
  # xlim = c(0, 100)) 
  polygon(density(wide_tibble_of_psisigma_results_allcomparisons_differential_info_exons %>% dplyr::group_by(diff_exon_coords) %>% dplyr::summarise("exon_dpsi" = sum(dpsi, na.rm = TRUE)) %>% .$exon_dpsi %>% abs),
          col = alpha("firebrick4", 0.33),
          border = FALSE,
          xaxt = "n")
# ,
# xlim = c(0, 100))
# +
#   axis(side = 1, at = seq(0, 100, by = 20), labels = seq(0, 100, by = 20))
dev.off()

```

## filter for constitutive exons only

In order to apply the constitutive cutoff (which requires that ALL timepoints must be)

```{r}

# to fetch the unique LIVs which are constitutive:
## group all unique LIVs together
wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV <- long_tibble_of_psisigma_DEXSeq_results %>% dplyr::group_by(database_ID, event_region_coords, diff_exon_coords, splicemode, chr, diff_exon_start, diff_exon_end, matched_strand)
## create logical of whether each LIV has all pvalue and dpsi cutoff AS WELL AS having all comparisons intact (and not missing)
## if return NA, then it's not constitutive.
wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV_constitutive.test <- wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV %>% dplyr::summarise("LIV_is_constitutive" = all(!!as.name(pvalue_or_FDR) > pvalue_cutoff & abs(dpsi) < dpsi_cutoff & num.replicates_comparison.1 >= 2 & num.replicates_comparison.2 >= 2) & n() == vector_of_comparisons_final %>% length) %>% dplyr::mutate_at("LIV_is_constitutive", .funs = function(x) {
  
  y <- x 
  
  y[which(is.na(y))] <- FALSE
  
  return(y)
  
} )
## subset table for only constitutive LIVs and extract all unique LIVs
wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV_constitutive.only <- wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV_constitutive.test[wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV_constitutive.test$LIV_is_constitutive == TRUE, ]
## extract unique constitutive LIVs
tibble_unique_constitutive_LIVs <- wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LIV_constitutive.only %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode, chr, diff_exon_start, diff_exon_end, matched_strand, .keep_all = TRUE)
## rejoin onto main table
tibble_constitutive_LIV_info <- dplyr::semi_join(long_tibble_of_psisigma_DEXSeq_results, tibble_unique_constitutive_LIVs)

# print numbers
number.of.LIVs_constitutive <- nrow(tibble_unique_constitutive_LIVs)
number.of.exons_constitutive <- tibble_unique_constitutive_LIVs$diff_exon_coords %>% unique %>% length

message("There are ", number.of.LIVs_constitutive, " constitutive LIVs using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)
message("There are ", number.of.exons_constitutive, " constitutive exons using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)

# write table of all constitutive LIVs info
write.table(x = tibble_constitutive_LIV_info, file = paste(R_processing_results_dir, "long_table_of_all_constitutive_LIV", number.of.LIVs_constitutive, "_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write coords for three-frame translation
write.table(x = tibble_constitutive_LIV_info[, c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")] %>% 
              dplyr::rename("VSR_coords" = "event_region_coords", "alternative_exon_coords" = "diff_exon_coords", "gene_name" = "matched_gene_names") %>% 
              add_column("organism" = "Homo sapiens", "custom_identifier" = NA), file = paste(R_processing_results_dir, "long_table_of_all_constitutive_LIV", number.of.LIVs_constitutive, "_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_3FT.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# Exon switching analysis

## Retrieve wide table of absolute PSI with timepoint/replicate NA

### subset the table of comparisons for comparisons to MSC timepoint only

Join table separately by local isoform topology.

```{r}

vector_of_comparisons_final_edited <- vector_of_comparisons_final
vector_of_comparisons_final_edited <- gsub(x = vector_of_comparisons_final_edited, pattern = "ud", replacement = "MSC")
vector_of_comparisons_final_edited <- gsub(x = vector_of_comparisons_final_edited, pattern = "24h", replacement = "1d")

# get a vector containing all the comparison names which have MSC in them
vector_of_ud_comparisons <- vector_of_comparisons_final_edited[grep(x = vector_of_comparisons_final_edited, pattern = "MSC$")]

# subset the wide table of all comparisons for only comparisons which have MSC
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0 <- dplyr::filter(wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV, comparison %in% vector_of_ud_comparisons) %>% dplyr::select(database_ID, event_region_coords, diff_exon_coords, splicemode, chr, diff_exon_start, diff_exon_end, matched_gene_names, matched_recon_transcript_names, matched_ref_transcript_names, matched_strand, NMD_biotype_reference, NMD_flagged_ref, NMD_flagged_recon, any_NMD, poison_exon_candidate_ref, poison_exon_candidate_recon, contains_PTC_ref, contains_PTC_recon, first_or_last_exon_reference, first_or_last_exon_recon, any_first_exon, any_last_exon, comparison, DEXSeq_PSI_first, DEXSeq_PSI_second) %>% dplyr::rename("DEXSeq_PSI_ud" = "DEXSeq_PSI_second")

# rename the columns. replace "comparison name" with "timepoint", rename the comparison 2 to MSC
# >
colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0)[which(colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0) == "comparison")] <- "timepoint"

# replace the actual "comparison name" with "timepoint"
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0[, "timepoint"] <- gsub(x = wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0$timepoint, pattern = "(BM_MSC_to_OB_)(.*)_vs_(BM_MSC_to_OB_)(.*)", replacement = "\\2")

# rbind to shake off the timepointwise comparison
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp1 <- dplyr::bind_rows(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0 %>% dplyr::select(-DEXSeq_PSI_ud) %>% dplyr::rename("PSI" = "DEXSeq_PSI_first"),
                                                                                       wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0 %>% dplyr::select(-DEXSeq_PSI_first) %>% dplyr::rename("PSI" = "DEXSeq_PSI_ud") %>% dplyr::mutate_at(.vars = "timepoint", .funs = function(x) {"MSC" %>% return}) %>% dplyr::group_by_at(.vars = setdiff(colnames(.), "PSI")) %>% dplyr::mutate_at(.vars = "PSI", .funs = mean )) %>% dplyr::distinct()

# recast into a wide tibble
## aggregate function taken as the mean
## wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp0[c(2200:2206, 2665:2670), ]
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only <- reshape2::dcast(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp1, formula = database_ID + event_region_coords + diff_exon_coords + splicemode + chr + diff_exon_start + diff_exon_end + matched_gene_names + matched_recon_transcript_names + matched_ref_transcript_names + matched_strand + NMD_biotype_reference + NMD_flagged_ref + NMD_flagged_recon + any_NMD + poison_exon_candidate_ref + poison_exon_candidate_recon + contains_PTC_ref + contains_PTC_recon + first_or_last_exon_reference + first_or_last_exon_recon + any_first_exon + any_last_exon ~ timepoint, value.var = "PSI") %>% as_tibble

wide_tibble_of_psisigma_results_allcomparisons_final_ud.only <- wide_tibble_of_psisigma_results_allcomparisons_final_ud.only %>% dplyr::select(colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only)[!colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only) %in% vector_OBseries_timepoints_edited], all_of(vector_OBseries_timepoints_edited))

colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only) <- c(colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only)[!colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only) %in% vector_OBseries_timepoints_edited], vector_OBseries_timepoints_edited)

wide_tibble_of_psisigma_PSI_with_na_LIV <- wide_tibble_of_psisigma_results_allcomparisons_final_ud.only

```

### Get the sum exon PSIs for the same splice region/splicemode - for later use

```{r}

wide_tibble_of_absolute_PSI_averages_sum_temp <- wide_tibble_of_psisigma_PSI_with_na_LIV %>% dplyr::select(., -database_ID)

# create list of event region, splicemode
list_unique_exon_regions <- wide_tibble_of_absolute_PSI_averages_sum_temp[, c("event_region_coords", "diff_exon_coords")] %>% unique %>% array_tree

# load the tibble of separated PSI averages into list
list_of_tibbles_absolute_PSI_average_subset_by_exon <- future_map(.x = list_unique_exon_regions, .f = ~wide_tibble_of_absolute_PSI_averages_sum_temp[wide_tibble_of_absolute_PSI_averages_sum_temp$event_region_coords == (.x[[1]] %>% paste) & wide_tibble_of_absolute_PSI_averages_sum_temp$diff_exon_coords == (.x[[2]] %>% paste), ], .progress = TRUE, .options = future_options(globals = c("wide_tibble_of_absolute_PSI_averages_sum_temp")))

# take the average PSI of each timepoint
# we assume there are no more bugs which cause identical virtual splice variations to be duplicated. so therefore we do not need to take unique values.
list_of_tables_absolute_PSI_average_subset_by_region_sum <- future_map(.x = list_of_tibbles_absolute_PSI_average_subset_by_exon, 
                                                                        .f = ~cbind(.x[, !colnames(.x) %in% vector_OBseries_timepoints_edited] %>% unique, 
                                                                                    apply(X = .x[, colnames(.x) %in% vector_OBseries_timepoints_edited], MARGIN = 2, FUN = function(X) {
                                                                                      if (all(is.na(X))) {
                                                                                        
                                                                                        X[NA_integer_]
                                                                                        
                                                                                        } else {
                                                                                          
                                                                                          sum(X, na.rm = TRUE)
                                                                                          # sum(X %>% unique, na.rm = TRUE)

                                                                                        } 
                                                                                      
                                                                                      }) %>% t), .progress = TRUE, .options = future_options(globals = c("vector_OBseries_timepoints_edited")))

wide_tibble_of_psisigma_PSI_with_na_exon.sum <- list_of_tables_absolute_PSI_average_subset_by_region_sum %>% rbindlist %>% as_tibble

```

### Do Switching LIVs

#### create subset list for every unique event region

```{r}

list_of_tibbles_absolute_PSI_levels_exon.switching <- future_map(.x = wide_tibble_of_psisigma_PSI_with_na_LIV$event_region_coords %>% unique, .f = ~wide_tibble_of_psisigma_PSI_with_na_LIV[wide_tibble_of_psisigma_PSI_with_na_LIV$event_region_coords == .x, ], .progress = TRUE, .options = future_options(globals = c("wide_tibble_of_psisigma_PSI_with_na_LIV")))

```

#### calculate the ranks for every differentially spliced region with more than one exon recorded

```{r}

# calculate ranks
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching, .p = ~nrow(.x) > 1, .f = ~apply(X = .x[, colnames(.x) %in% vector_OBseries_timepoints_edited], MARGIN = 2, FUN = function(X) {
  if (all(is.na(X))) {
    
    vector_rank <- rep(NA, times = length(X))
    
    } else {
      
      vector_rank <- rank(X %>% as.numeric, na.last = TRUE)
      
    }
  
  return(vector_rank)
  
  }) %>% t %>% na.omit %>% t)

remove_consecutive_duplicates_from_data.frame <- function(df) {
  
  # turn dataframe into list
  a <- df %>% array_tree
  # test if each term starting from 2nd element is identical to previous
  b <- purrr::map2(.x = a[1:(length(a) - 1)], .y = a[2:(length(a))], .f = ~identical(.x, .y))
  # get the elements (minus 1) which are not identical to previous
  c <- which(b == FALSE)
  # return filtered list
  d <- a[c(1, c + 1)]
  # re-make into dataframe
  e <- d %>% rbindlist %>% as.data.frame
  row.names(e) <- names(d)
  
  # return filtered dataframe
  return(e %>% t)
  
}

# unique consecutive ranks only
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint, .p = ~nrow(.x) > 1 & ncol(.x) > 1, .f = ~.x %>% t %>% remove_consecutive_duplicates_from_data.frame)

```

#### which elements have more than one column?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique, .p = ~nrow(.x) > 1, .f = ~ncol(.x) > 1)

```

#### for those exons with only one entry, is PSI going back and forth between 50%?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_logical_exon_switched_or_not, .p = ~is.logical(.x) == FALSE, 
                                          .f = ~any(.x[, colnames(.x) %in% vector_OBseries_timepoints_edited] %>% unlist %>% na.omit > 50) & any(.x[, colnames(.x) %in% vector_OBseries_timepoints_edited] %>% unlist %>% na.omit < 50))

```

#### filter the absolute PSI table for exons switched over the time course

```{r}

list_of_tibbles_of_absolute_PSI_averages_exon.switched <- list_of_tibbles_absolute_PSI_levels_exon.switching[which(list_of_logical_exon_switched_or_not %>% unlist == TRUE)]

tibble_of_absolute_PSI_averages_exon.switched_separate <- list_of_tibbles_of_absolute_PSI_averages_exon.switched %>% rbindlist %>% as_tibble

write.table(x = tibble_of_absolute_PSI_averages_exon.switched_separate, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(tibble_of_absolute_PSI_averages_exon.switched_separate), "_switched.LIVs_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Do exon switching

#### create subset list for every unique exon

```{r}

list_of_tibbles_absolute_PSI_levels_exon.switching <- future_map(.x = wide_tibble_of_psisigma_PSI_with_na_exon.sum$event_region_coords %>% unique, .f = ~wide_tibble_of_psisigma_PSI_with_na_exon.sum[wide_tibble_of_psisigma_PSI_with_na_exon.sum$event_region_coords == .x, ], .progress = TRUE, .options = future_options(globals = c("wide_tibble_of_psisigma_PSI_with_na_exon.sum")))

```

#### calculate the ranks for every differentially spliced region with more than one exon recorded

```{r}

# calculate ranks
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching, .p = ~nrow(.x) > 1, .f = ~apply(X = .x[, colnames(.x) %in% vector_OBseries_timepoints_edited], MARGIN = 2, FUN = function(X) {
  if (all(is.na(X))) {
    
    vector_rank <- rep(NA, times = length(X))
    
    } else {
      
      vector_rank <- rank(X %>% as.numeric, na.last = TRUE)
      
    }
  
  return(vector_rank)
  
  }) %>% t %>% na.omit %>% t)

remove_consecutive_duplicates_from_data.frame <- function(df) {
  
  # turn dataframe into list
  a <- df %>% array_tree
  # test if each term starting from 2nd element is identical to previous
  b <- purrr::map2(.x = a[1:(length(a) - 1)], .y = a[2:(length(a))], .f = ~identical(.x, .y))
  # get the elements (minus 1) which are not identical to previous
  c <- which(b == FALSE)
  # return filtered list
  d <- a[c(1, c + 1)]
  # re-make into dataframe
  e <- d %>% rbindlist %>% as.data.frame
  row.names(e) <- names(d)
  
  # return filtered dataframe
  return(e %>% t)
  
}

# unique consecutive ranks only
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint, .p = ~nrow(.x) > 1 & ncol(.x) > 1, .f = ~.x %>% t %>% remove_consecutive_duplicates_from_data.frame)

```

#### which elements have more than one column?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique, .p = ~nrow(.x) > 1, .f = ~ncol(.x) > 1)

```

#### for those exons with only one entry, is PSI going back and forth between 50%?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_logical_exon_switched_or_not, .p = ~is.logical(.x) == FALSE, 
                                          .f = ~any(.x[, colnames(.x) %in% vector_OBseries_timepoints_edited] %>% unlist %>% na.omit > 50) & any(.x[, colnames(.x) %in% vector_OBseries_timepoints_edited] %>% unlist %>% na.omit < 50))

```

#### filter the absolute PSI table for exons switched over the time course

```{r}

list_of_tibbles_of_absolute_PSI_averages_exon.switched <- list_of_tibbles_absolute_PSI_levels_exon.switching[which(list_of_logical_exon_switched_or_not %>% unlist == TRUE)]

tibble_of_absolute_PSI_averages_exon.switched_sum <- list_of_tibbles_of_absolute_PSI_averages_exon.switched %>% rbindlist %>% as_tibble

write.table(x = tibble_of_absolute_PSI_averages_exon.switched_sum, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(tibble_of_absolute_PSI_averages_exon.switched_sum), "_switched.exons_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# Clustering using self-organising maps

## separate PSI per LIV

### Filter the wide table of absolute PSI for exons with complete timeseries only
#### Then filter for differential exons.

```{r}

# get row indices which have any na.
row.indices_with_na <- apply(X = wide_tibble_of_psisigma_PSI_with_na_LIV[, colnames(wide_tibble_of_psisigma_PSI_with_na_LIV) %in% vector_OBseries_timepoints_edited], MARGIN = 1, FUN = function(X) {any(is.na(X))})

# remove those rows that are true (that have any na)
wide_tibble_of_LIV_PSI_no_na <- wide_tibble_of_psisigma_PSI_with_na_LIV[which(row.indices_with_na == FALSE), ]

no.LIV.exons_differentially.spliced_complete.timeseries <- nrow(wide_tibble_of_LIV_PSI_no_na)

cat("There are", no.LIV.exons_differentially.spliced_complete.timeseries, "exons with a complete time profile of LIV-based PSI which are differentially spliced.")

# THIS IS THE FINAL TIBBLE OF ALL THE EXONS WITH A COMPLETE TIME-SERIES PSI PROFILE

```

### scale PSI levels

```{r}

wide_tibble_of_LIV_PSI_no_na_scaled <- wide_tibble_of_LIV_PSI_no_na

wide_tibble_of_LIV_PSI_no_na_scaled[, colnames(wide_tibble_of_LIV_PSI_no_na_scaled) %in% vector_OBseries_timepoints_edited] <- wide_tibble_of_LIV_PSI_no_na_scaled[, colnames(wide_tibble_of_LIV_PSI_no_na_scaled) %in% vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble

write.table(x = wide_tibble_of_LIV_PSI_no_na_scaled, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(wide_tibble_of_LIV_PSI_no_na_scaled), "LIVs_scaled.PSI_OB_diff.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

set.seed(som_seed_number)

somdata_5_by_5_OBseries <- som(wide_tibble_of_LIV_PSI_no_na_scaled[, vector_OBseries_timepoints_edited] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries_separate <- cbind(wide_tibble_of_LIV_PSI_no_na_scaled, "cluster" = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table
long_table_of_final_SOM_summary_5_by_5_OBseries_separate <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate, id.vars = colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate)[!colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate) %in% vector_OBseries_timepoints_edited], variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries_separate[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries_separate[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries_separate[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_table_of_final_SOM_summary_5_by_5_OBseries_separate_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries_separate, aes(x = timepoint, y = scaled_PSI_value, group = paste(event_region_coords, diff_exon_coords, splicemode)), alpha = 0.33) +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries_separate_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate), "LIV PSI values during OB diff (any", pvalue_or_FDR, 
               " < ", pvalue_cutoff, "any deltaPSI >", dpsi_cutoff, ")")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_separate %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode) %>% nrow, "_exons_LIV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_separate %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode) %>% nrow, "_exons_LIV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries_separate, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_separate %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode) %>% nrow, "_exons_LIV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries_separate, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_separate %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode) %>% nrow, "_exons_LIV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## summed PSI per exon

### Filter the wide table of absolute PSI for exons with complete timeseries only
#### Then filter for differential exons.

```{r}

# get row indices which have any na.
row.indices_with_na <- apply(X = tibble_of_absolute_PSI_averages_exon.switched_sum[, colnames(tibble_of_absolute_PSI_averages_exon.switched_sum) %in% vector_OBseries_timepoints_edited], MARGIN = 1, FUN = function(X) {any(is.na(X))})

# remove those rows that are true (that have any na)
wide_tibble_of_exon_PSI_no_na <- tibble_of_absolute_PSI_averages_exon.switched_sum[which(row.indices_with_na == FALSE), ]

no.sum.exons_differentially.spliced_complete.timeseries <- length(wide_tibble_of_exon_PSI_no_na$diff_exon_coords)

cat("There are", no.sum.exons_differentially.spliced_complete.timeseries, "exons with a complete time profile of exon-based PSI which are differentially spliced.")

# THIS IS THE FINAL TIBBLE OF ALL THE EXONS WITH A COMPLETE TIME-SERIES PSI PROFILE

```

### scale PSI levels

```{r}

wide_tibble_of_exon_PSI_no_na_scaled <- wide_tibble_of_exon_PSI_no_na

wide_tibble_of_exon_PSI_no_na_scaled[, colnames(wide_tibble_of_exon_PSI_no_na_scaled) %in% vector_OBseries_timepoints_edited] <- wide_tibble_of_exon_PSI_no_na_scaled[, colnames(wide_tibble_of_exon_PSI_no_na_scaled) %in% vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble

# write the scaled PSI table
write.table(x = wide_tibble_of_exon_PSI_no_na_scaled, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(wide_tibble_of_exon_PSI_no_na_scaled), "exons_scaled.PSI_OB_diff.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

somdata_5_by_5_OBseries <- som(wide_tibble_of_exon_PSI_no_na_scaled[, vector_OBseries_timepoints_edited] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries_sum <- cbind(wide_tibble_of_exon_PSI_no_na_scaled, "cluster" = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries_sum <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum, id.vars = colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum)[!colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum) %in% vector_OBseries_timepoints_edited], variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries_sum[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries_sum[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries_sum[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_table_of_final_SOM_summary_5_by_5_OBseries_sum_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries_sum, aes(x = timepoint, y = scaled_PSI_value, group = paste(diff_exon_coords, splicemode)), alpha = 0.33) +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries_sum_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum), "exon PSI values during OB diff (any", pvalue_or_FDR, 
               " < ", pvalue_cutoff, "any deltaPSI >", dpsi_cutoff, ")")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_sum %>% dplyr::distinct(diff_exon_coords, splicemode) %>% nrow, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_sum %>% dplyr::distinct(diff_exon_coords, splicemode) %>% nrow, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries_sum, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_sum %>% dplyr::distinct(diff_exon_coords, splicemode) %>% nrow, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries_sum, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", long_table_of_final_SOM_summary_5_by_5_OBseries_sum %>% dplyr::distinct(diff_exon_coords, splicemode) %>% nrow, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# GENE ONTOLOGY

## prepare GO catalog for the gene background

running hyperGOall in systempipeR

This gene background shall contain all ensembl protein coding, long noncoding and transcribed genes.

```{r}

# GOTERM
# polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "go_id", "namespace_1003"), mart = ensembl_mart) %>% .[.$namespace_1003 != "",]
#
# polyA_RNAseq_GO_background[, "namespace_1003"] <- as.character(polyA_RNAseq_GO_background[, "namespace_1003"])
#
# write.table(x = polyA_RNAseq_GO_background, file = paste(R_processing_results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

## Create catDB instance (takes a while but needs to be done only once)
# note: you had to save the GO annotation file to disk in the previous steps above
# catdb <- makeCATdb(myfile = paste(R_processing_results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), lib = NULL, org = "", colno = c(2, 1, 3), idconv = NULL)

load(paste(shared_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

## all exons, anysig with na.

### hypergeometric test for GO terms

```{r}

# create vector of differential genes
vector_differential_genes_anysig_with_na <- wide_tibble_of_psisigma_results_allcomparisons_differential$matched_gene_names %>% unique

# count number of differential genes
number.of.genes_differential_anysig_with_na <- vector_differential_genes_anysig_with_na %>% length

cat(number.of.genes_differential_anysig_with_na, "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation with FDR <", pvalue_cutoff, "\n")

# create list of GO categories
list_GO_categories <- c("MF", "BP", "CC") %>% array_tree

# map GO test
list_of_GO_test_tibbles_anysig_with_na_raw <- purrr::map(.x = list_GO_categories, .f = ~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = vector_differential_genes_anysig_with_na, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% type_convert) %>% set_names(list_GO_categories)

# filter out the top ~30 most significant GO terms for each node
list_of_GO_test_tibbles_anysig_with_na_top.hits <- purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_raw, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 900) %>% dplyr::filter(NodeSize < 1500) %>% dplyr::mutate_at(.vars = "Term", .funs = function(x) {stringr::str_trunc(string = x, side = "right", width = 78) %>% return}))

# print out the top hits of the GO enrichment
purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_top.hits, .f = ~.x %>% print)

# collapse into a long tibble for plot
long_tibble_GO_test_anysig_with_na_top.hits <- list_of_GO_test_tibbles_anysig_with_na_top.hits %>% rbindlist %>% as_tibble

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(long_tibble_GO_test_anysig_with_na_top.hits, aes(x = reorder(Term, -Phyper), y = -log10(Phyper))) +
  geom_col(aes(fill = SampleMatch)) +
  scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = 1, aesthetics = "fill", na.value = "yellow") +
  geom_hline(yintercept = -log10(0.05), lty = 2) +
  coord_flip() +
  facet_wrap(Ont ~ ., ncol = 3, scales = "free_y") +
  ggtitle(paste("Top 30 significantly over-represented GO terms for OB series for 
                dPSI cutoff of", dpsi_cutoff, "and any sig", pvalue_or_FDR, pvalue_cutoff, "encompassing", number.of.genes_differential_anysig_with_na, "genes")) +
  xlab("GO term") +
  ylab(expression(log["10"](P["b-hoch"]))) +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype="solid", colour ="black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "top_30_GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(R_processing_results_dir, "top_30 GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) 

# write table of top 30 results
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(R_processing_results_dir, "top_30_GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of every enrichment
write.table(x = list_of_GO_test_tibbles_anysig_with_na_raw %>% purrr::map(~dplyr::arrange(.x, Phyper)) %>% rbindlist, file = paste(R_processing_results_dir, "top_inf_GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

## Gene ontology of each SOM cluster, separate and summed PSI

### preparation of separate data frames containing gene sets of each cluster

at the end of this, we will get list_of_OB/OBseries_gene_tables_by_SOM_cluster which are lists containing 25 nested data frames

```{r}

# create list of SOM clusters
list_of_SOM_clusters <- 1:number_of_som_clusters %>% array_tree

# load the tibble into list by cluster
list_of_tibble_SOM.separate.PSI_subset_by_cluster <- list(purrr::map(.x = list_of_SOM_clusters, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_separate[wide_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster == .x, ]) %>% set_names(list_of_SOM_clusters), purrr::map(.x = list_of_SOM_clusters, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_sum[wide_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster == .x, ]) %>% set_names(list_of_SOM_clusters)) %>% set_names(c(paste("separate.PSI_", wide_table_of_final_SOM_summary_5_by_5_OBseries_separate$matched_gene_names %>% unique %>% length, sep = ""), paste("sum.PSI_", wide_table_of_final_SOM_summary_5_by_5_OBseries_sum$matched_gene_names %>% unique %>% length, sep = "")))

# take gene set for each cluster
list_of_vectors_genesets_per_SOM_cluster <- purrr::map_depth(.x = list_of_tibble_SOM.separate.PSI_subset_by_cluster, .depth = 2, .ragged = FALSE, .f = ~.x$matched_gene_names %>% unique)

```

### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_SOM_genes_and_GOterms <- cross2(.x = list_of_vectors_genesets_per_SOM_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_SOM_genes_and_GOterms_names <- cross2(.x = list_of_vectors_genesets_per_SOM_cluster %>% names, .y = list("MF", "BP", "CC"))

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination
list_of_tibbles_SOM_hyperGOresult_clusterwise <- future_map(.x = list_of_combinations_of_SOM_genes_and_GOterms, .f = ~purrr::map2(.x = .x[[1]], .y = .x[[2]], .f = ~GOHyperGAll(catdb = catdb, gocat = .y, Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble), .progress = TRUE)

# write the table of top inf
tibble_SOM_hyperGOresult_clusterwise_top_inf <- purrr::map2(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise,
                                                            .y = list_of_combinations_of_SOM_genes_and_GOterms_names,
                                                            .f = function(a1, a2) {
                                                              
                                                              purrr::map2(.x = a1, .y = names(a1), .f = ~add_column(.x, 
                                                                                                                   "cluster" = .y,
                                                                                                                   "separate_or_sum_PSI" = a2[[1]] %>% strsplit(split = "_") %>% purrr::map(~.x[1]) %>% unlist)) %>% rbindlist %>% return
                                                              
                                                            } ) %>% rbindlist %>% as_tibble

write.table(x = tibble_SOM_hyperGOresult_clusterwise_top_inf, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_OB_diff_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI", dpsi_cutoff, "_GO_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter gene ontology tables for top hits
list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise, .f = ~purrr::map(.x = .x, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 10)))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# ggplot, separate PSI

# get list indices of the GO result tibbles that house the separate PSI info.

purrr::map2(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[2], "_genes_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[2], "_genes_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[2], "_genes_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Gene Ontology for the isoforms/genes with highest PSIs at every time point (separate + sum PSI)

Plan: 

1. for each OB/OB series, for each time point, filter separately for the isoforms with the top ... 10%? (depends on total no. of isoforms) PSI
2. Generate all 3 GO nodes for each timepoint
3. Append timepoint to their respective GO output tables
4. Bind rows for a total of three massive tables (one for each GO node)
5. GGPLOT

### set PSI cutoff percentages according to scaled PSI values

```{r}

high_scaled.PSI.cutoff <- 0.1

low_scaled.PSI.cutoff <- 0.1

# string to simplify the code
cutoff_string <- paste("H", high_scaled.PSI.cutoff, "L", low_scaled.PSI.cutoff, sep = "")

```

### creation of lists of NORMALISED(SCALED) PSI values of isoforms per time point

```{r}

# column names corresponding to PSI observations are just the OB series timepoints
list_of_tibbles_scaled_PSI_subset_by_timepoint <- list(list(purrr::map(.x = vector_OBseries_timepoints_edited, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_separate[, colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate)[
  c(-which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate) %in% vector_OBseries_timepoints_edited[vector_OBseries_timepoints_edited != .x]), 
    -which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate) == "cluster"))]]) %>% set_names(vector_OBseries_timepoints_edited), "PSI_type" = "separate.PSI"), 
                                                       list(purrr::map(.x = vector_OBseries_timepoints_edited, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_sum[, colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum)[
  c(-which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum) %in% vector_OBseries_timepoints_edited[vector_OBseries_timepoints_edited != .x]), 
    -which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum) == "cluster"))]]) %>% set_names(vector_OBseries_timepoints_edited), "PSI_type" = "sum.PSI"))

```

### filter for top 10% of isoforms with highest/lowest PSI

```{r}

list_of_tibbles_highest.lowest_PSI_by_timepoint <- purrr::cross2(.x = list_of_tibbles_scaled_PSI_subset_by_timepoint, .y = list("highest_PSI", "lowest_PSI")) %>% purrr::map(.x = ., .f = ~flatten(.x) %>% set_names(c("data", "PSI_type", "highest_or_lowest_PSI")))

# the result: individual tibbles with the PSI type and highest/lowest PSI alongside it
## map the highest PSI tibbles
list_of_tibbles_highest.lowest_PSI_by_timepoint <- purrr::map_if(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .p = ~.x[["highest_or_lowest_PSI"]] == "highest_PSI", .f = ~list("data" = purrr::map2(.x = .x[["data"]], .y = vector_OBseries_timepoints_edited, .f = ~.x[order(.x[, .y], decreasing = TRUE), ] %>% head(.x, n = floor(nrow(.x) * high_scaled.PSI.cutoff))), "PSI_type" = .x[["PSI_type"]], "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))
## map the lowest PSI tibbles
list_of_tibbles_highest.lowest_PSI_by_timepoint <- purrr::map_if(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .p = ~.x[["highest_or_lowest_PSI"]] == "lowest_PSI", .f = ~list("data" = purrr::map2(.x = .x[["data"]], .y = vector_OBseries_timepoints_edited, .f = ~.x[order(.x[, .y], decreasing = FALSE), ] %>% head(.x, n = floor(nrow(.x) * low_scaled.PSI.cutoff))), "PSI_type" = .x[["PSI_type"]], "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))

# write each highest/lowest table for use in cytoscape
future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .f = function(.x) {
  
  data <- .x$data
  timepoint_names <- names(data)
  
  PSI_type <- .x$PSI_type
  highest_or_lowest_PSI <- .x$highest_or_lowest_PSI
  
  purrr::map2(.x = data, .y = timepoint_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "table_top10_", cutoff_string, "_", highest_or_lowest_PSI, "_timepointwise_", .y, "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", PSI_type, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))
  
} )

```

### run gohypergall

```{r}

# take combinations of the so far sum/separate PSI and highest/lowest PSI with GO terms MF BP CC
list_of_tibbles_highest.lowest_PSI_by_timepoint_renamed <- purrr::cross2(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .y = list("MF", "BP", "CC")) %>% purrr::map(.x = ., .f = ~set_names(.x, c("sum.sep_highest.lowest_data", "GO_category")) %>% flatten)

list_of_tibbles_hyperGOresult_timepointwise <- future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint_renamed, 
                                                              .f = ~list("GO_enrichment" = pmap(.l = list("data" = .x[[1]], 
                                                                                  "PSI_type" = .x[[2]], 
                                                                                  "highest_or_lowest_PSI" = .x[[3]], 
                                                                                  "GO_category" = .x[[4]],
                                                                                  "timepoint" = vector_OBseries_timepoints_edited %>% array_tree), .f = ~GOHyperGAll(catdb = catdb, gocat = ..4, Nannot = 2, sample = ..1$matched_gene_names) %>% GOHyperGAll_benjamini_correction),
                                                                         "PSI_type" = .x[[2]],
                                                                         "highest_or_lowest_PSI" = .x[[3]],
                                                                         "GO_category" = .x[[4]]), .progress = TRUE)

```

### reprocess the list into form ameable to ggplot

```{r}

# append timepoint column to each enrichment result, arrange in ascending pvalue order, rbindlist into a long tibble
list_of_tibbles_hyperGOresult_timepointwise_topten <- purrr::map(.x = list_of_tibbles_hyperGOresult_timepointwise, .f = ~list("GO_enrichment" = map2(.x = .x[["GO_enrichment"]], .y = names(.x[["GO_enrichment"]]), .f = ~.x %>% add_column("timepoint" = .y) %>% dplyr::arrange(., Phyper) %>% head(n = 10)) %>% rbindlist %>% as_tibble, 
                                                                                    "PSI_type" = .x[["PSI_type"]],
                                                                                    "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]],
                                                                                    "GO_category" = .x[["GO_category"]]))

```


#### GGPLOT

```{r}

# a single function to call all 12 plots:
# separate/sum PSI, highest/lowest PSI cutoff, MF/BP/CC categories.

# list_of_data_tibbles <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_timepointwise, .f = ~.x$GO_enrichment)

future_map(.x = list_of_tibbles_hyperGOresult_timepointwise_topten, .f = ~ggplot(.x[["GO_enrichment"]], aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint %>% as.factor %>% fct_relevel(., vector_OBseries_timepoints_edited), scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .x[["GO_category"]], " GO terms for the ", cutoff_string, .x[["highest_or_lowest_PSI"]], " exons in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, .x[["GO_category"]], "_GOterms_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, .x[["GO_category"]], "_GOterms_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm"), .progress = TRUE)

future_map(.x = list_of_tibbles_hyperGOresult_timepointwise_topten, .f = ~write.table(x = .x[["GO_enrichment"]], file = paste(R_processing_results_dir, .x[["GO_category"]], "_GOterms_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# protein family enrichment

goal: to conduct hypergeometric tests of overrepresentation for gene subsets in protein families

## generating enrichment catalog of PFAM protein families

```{r}

# PROTEINFAMILY
polyA_RNAseq_background_pfam <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "pfam"), mart = ensembl_mart) %>% .[.$pfam != "",]

# obtain description(definition, DE) for each PFAM ID

PFAM_all_descriptions <- as.data.frame(PFAMDE[mappedkeys(PFAMDE)]) %>% setNames(., c("pfam", "family_description"))

polyA_RNAseq_background_pfam <- dplyr::left_join(polyA_RNAseq_background_pfam, PFAM_all_descriptions, by = "pfam")

polyA_RNAseq_background_pfam[, "family_description"] <- as.character(polyA_RNAseq_background_pfam[, "family_description"])

write.table(x = polyA_RNAseq_background_pfam, file = paste(R_processing_results_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

# create list of gene UNIVERSE

reference_geneset_universe <- polyA_RNAseq_background_pfam$external_gene_name

# create list containing collections of genes under their according family descriptions

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam_2[, names(polyA_RNAseq_background_pfam_2) != "pfam"]

list_of_pfam_descriptions <- polyA_RNAseq_background_pfam_2$family_description %>% unique %>% as.list

list_of_pfam_gene_family_categories <- purrr::map(.x = list_of_pfam_descriptions, .f = ~as.list(polyA_RNAseq_background_pfam[polyA_RNAseq_background_pfam$family_description == .x, "external_gene_name"]))

names(list_of_pfam_gene_family_categories) <- list_of_pfam_descriptions

list_of_pfam_gene_family_categories <- list_of_pfam_gene_family_categories %>% purrr::map(~unlist(.x))

```

## all exons, anysig with na

### hypergeometric test for protein families

```{r}

# Hypergeometric test
tibble_pfam.enrichment_anysig_with_na_raw <- bc3net::enrichment(genes = vector_differential_genes_anysig_with_na, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], vector_differential_genes_anysig_with_na) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble

# filter out the top ~30 most significant GO terms for each node
tibble_pfam.enrichment_anysig_with_na_top.hits <- dplyr::arrange(tibble_pfam.enrichment_anysig_with_na_raw, pval) %>% head(n = 30)

print(tibble_pfam.enrichment_anysig_with_na_top.hits)

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(tibble_pfam.enrichment_anysig_with_na_top.hits, aes(x = reorder(TermID %>% as.character, pval), y = genes)) +
  geom_col(aes(fill = log(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  ggtitle(paste("Top 30 significantly over-represented PFAM families for OB series for 
                dPSI cutoff of", dpsi_cutoff, "and any sig", pvalue_or_FDR, pvalue_cutoff, "encompassing", number.of.genes_differential_anysig_with_na, "genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "top_30_PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 40, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "top_30 PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 40, height = 15, units = "cm") 

# write the top hits table
write.table(x = tibble_pfam.enrichment_anysig_with_na_top.hits, file = paste(R_processing_results_dir, "top_30_PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# also write all the hits 
write.table(x = dplyr::arrange(tibble_pfam.enrichment_anysig_with_na_raw, pval), file = paste(R_processing_results_dir, "top_inf_PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_SOM_family.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_SOM_cluster, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_SOM_family.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Family enrichment for the isoforms/genes with highest PSIs at every time point (separate + sum PSI)

### run family enrichment

```{r}

list_of_tibbles_family.enrichment_timepointwise <- future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, 
                                                              .f = ~list("family_enrichment" = pmap(.l = list("data" = .x[[1]], 
                                                                                  "PSI_type" = .x[[2]], 
                                                                                  "highest_or_lowest_PSI" = .x[[3]],
                                                                                  "timepoint" = vector_OBseries_timepoints_edited %>% array_tree), .f = ~bc3net::enrichment(genes = ..1$matched_gene_names, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], ..1$matched_gene_names) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble),
                                                                         "PSI_type" = .x[[2]],
                                                                         "highest_or_lowest_PSI" = .x[[3]]), .progress = TRUE)

```

### reprocess the list into form ameable to ggplot

```{r}

# append timepoint column to each enrichment result, arrange in ascending pvalue order, rbindlist into a long tibble
list_of_tibbles_family.enrichment_timepointwise_topten <- purrr::map(.x = list_of_tibbles_family.enrichment_timepointwise, .f = ~list("family_enrichment" = map2(.x = .x[["family_enrichment"]], .y = names(.x[["family_enrichment"]]), .f = ~.x %>% add_column("timepoint" = .y) %>% dplyr::arrange(., pval) %>% head(n = 10)) %>% rbindlist %>% as_tibble, 
                                                                                    "PSI_type" = .x[["PSI_type"]],
                                                                                    "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))

```

#### GGPLOT

```{r}

# a single function to call all 12 plots:
# separate/sum PSI, highest/lowest PSI cutoff, MF/BP/CC categories.

# list_of_data_tibbles <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_timepointwise, .f = ~.x$GO_enrichment)

future_map(.x = list_of_tibbles_family.enrichment_timepointwise_topten, .f = ~ggplot(.x[["family_enrichment"]], aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint %>% as.factor %>% fct_relevel(., vector_OBseries_timepoints_edited), scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented protein families for the ", cutoff_string, .x[["highest_or_lowest_PSI"]], " exons in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "family.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "family.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm"), .progress = TRUE)

future_map(.x = list_of_tibbles_family.enrichment_timepointwise_topten, .f = ~write.table(x = .x[["family_enrichment"]], file = paste(R_processing_results_dir, "family.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# ENRICHMENT OF SPLICING FACTORS - didnt work

## Generate table of all the mRNA sequences of all annotated transcripts

- mRNA sequences: UNSPLICED, for,
- Genes: ANYSIG

```{r eval=FALSE, include=FALSE}

anysig_all_mrna_seqs <- getBM(filters = "external_gene_name", values = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene, attributes = c("external_gene_name", "ensembl_transcript_id", "transcript_exon_intron"), mart = ensembl_mart) %>% as_tibble

```

## generate lists of target genes containing motifs of splicing factors

use regex lmao

```{r eval=FALSE, include=FALSE}

RBM41_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "(A|T)TAC(A|T)TT")), "external_gene_name"] %>% unique

print(nrow(RBM41_binding_motif_containing_genes))

SRSF2_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "AGGAG(A|T)(G|A|T)")), "external_gene_name"] %>% unique

print(nrow(SRSF2_binding_motif_containing_genes))

wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$Gene %>% unique %>% length %>% print

print("rip")

```

## import MBNL (HiTS-CLiP) and SRSF (FLASH-Seq) data and match with GTF information

### set directories

```{r}

clipseq_dir <- "Z:/isoform_usage_project/CLIPseq_files/"

FLASHseq_dir <- "Y:/2019_FLASHseq/results/R_processing_results/"

```

### prepare geneset categories

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
                                               
  "SRSF1 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR1-SRSF1.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF2 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR5-SRSF2.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF3 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR8-SRSF3.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF4 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR9-SRSF4.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF5 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR10-SRSF5.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF6 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR11-SRSF6.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF7 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR12-SRSF7.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF9 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR13-SRSF9.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF11 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR14-SRSF11.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_SOM_cluster, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## enrichment of upstream RBPs - timepointwise, per gene

### perform enrichment step

```{r}

list_of_tibbles_upstream.RBP.enrichment_timepointwise <- future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, 
                                                              .f = ~list("family_enrichment" = pmap(.l = list("data" = .x[[1]], 
                                                                                  "PSI_type" = .x[[2]], 
                                                                                  "highest_or_lowest_PSI" = .x[[3]],
                                                                                  "timepoint" = vector_OBseries_timepoints_edited %>% array_tree), .f = ~bc3net::enrichment(genes = ..1$matched_gene_names, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], ..1$matched_gene_names) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble),
                                                                         "PSI_type" = .x[[2]],
                                                                         "highest_or_lowest_PSI" = .x[[3]]), .progress = TRUE)

```

### reprocess the list into form amenable to ggplot

```{r}

# append timepoint column to each enrichment result, arrange in ascending pvalue order, rbindlist into a long tibble
list_of_tibbles_upstream.RBP.enrichment_timepointwise_topten <- purrr::map(.x = list_of_tibbles_upstream.RBP.enrichment_timepointwise, .f = ~list("family_enrichment" = map2(.x = .x[["family_enrichment"]], .y = names(.x[["family_enrichment"]]), .f = ~.x %>% add_column("timepoint" = .y) %>% dplyr::arrange(., pval) %>% head(n = 10)) %>% rbindlist %>% as_tibble, 
                                                                                    "PSI_type" = .x[["PSI_type"]],
                                                                                    "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))

```

### ggplot

```{r}

# a single function to call all 12 plots:
# separate/sum PSI, highest/lowest PSI cutoff, MF/BP/CC categories.

# list_of_data_tibbles <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_timepointwise, .f = ~.x$GO_enrichment)

future_map(.x = list_of_tibbles_upstream.RBP.enrichment_timepointwise_topten, .f = ~ggplot(.x[["family_enrichment"]], aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint %>% as.factor %>% fct_relevel(., vector_OBseries_timepoints_edited), scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for the ", cutoff_string, .x[["highest_or_lowest_PSI"]], " exons in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "upstream.RBP.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "upstream.RBP.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm"), .progress = TRUE)

future_map(.x = list_of_tibbles_upstream.RBP.enrichment_timepointwise_topten, .f = ~write.table(x = .x[["family_enrichment"]], file = paste(R_processing_results_dir, "upstream.RBP.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# COMBINING GENE EXPRESSION DATA WITH THE SPLICEOMIC DATA HERE

## set environment

set directories

```{r}

# the EXACT path of the file, not its containing directory

logCPM_OBseries_anysig_DEGs_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_2_eRNA/R_processing_results/edgeR_GLM_DEGs_logCPM.txt"

```

define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

## extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

logCPM_OBseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_OBseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_OBseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_OBseries_anysig_DEGs <- dplyr::right_join(ENSG_to_genesymbol_DEGs, logCPM_OBseries_anysig_DEGs_import, by = "ensembl_gene_id") %>% average_counts_from_triplicate(., 2)

# reorder the columns to make them chronological

logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_OB_MSC_avg", "logCPM_BM_MSC_to_OB_6h_avg", "logCPM_BM_MSC_to_OB_12h_avg", "logCPM_BM_MSC_to_OB_24h_avg", "logCPM_BM_MSC_to_OB_3d_avg", "logCPM_BM_MSC_to_OB_6d_avg", "logCPM_BM_MSC_to_OB_9d_avg", "logCPM_BM_MSC_to_OB_12d_avg")]

colnames(logCPM_OBseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

# subset CPM table by biological role

  # RBPs
column_RBP_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "RNA binding" | .$name_1006 == "spliceosomal complex", "ensembl_gene_id"]

logCPM_OBseries_RBP <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_RBP_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # lncRNA
column_lncRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("lncRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble

logCPM_OBseries_lncRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_lncRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # snRNA
column_snRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("snRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble %>% mutate_if(is.logical, as.character)

logCPM_OBseries_snRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_snRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # all TF complex 
column_TFcomplex_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "transcription factor complex", "ensembl_gene_id"]

logCPM_OBseries_TFcomplex <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_TFcomplex_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_OBseries_subset <- dplyr::bind_rows(logCPM_OBseries_RBP, logCPM_OBseries_lncRNA, logCPM_OBseries_snRNA, logCPM_OBseries_TFcomplex)

# get rid of ENSG id
logCPM_OBseries_subset <- logCPM_OBseries_subset[, -1]

# rename column before next join

colnames(logCPM_OBseries_subset)[1] <- "matched_gene_names"

# combine logCPM and PSI values
list_of_tibbles_combinedexpr_logCPM_PSI_unscaled <- list("combinedexpr_logCPM_PSI_separate" = dplyr::bind_rows(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate %>% setNames(gsub(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate), pattern = "_absolute.psi_average", replacement = "")) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character), logCPM_OBseries_subset) %>% add_column("identifier" = paste(.$database_ID, "/", .$event_region_coords, "/", .$splicemode, "/", .$diff_exon_coords, sep = "")),
                                                         "combinedexpr_logCPM_PSI_sum" = dplyr::bind_rows(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum %>% setNames(gsub(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum), pattern = "_absolute.psi_average", replacement = "")) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character), logCPM_OBseries_subset) %>% add_column("identifier" = paste(.$event_region_coords, "/", .$splicemode, "/", .$diff_exon_coords, sep = "")))

```

## consensus re-clustering of combined expression and PSI data

### execute ensemble SOM and create consensus matrix

```{r}

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7)
ydim_range_combinedexpr <- c(8, 9, 10, 11, 6, 7, 8, 5, 6, 7, 4, 5, 4)

som_seed_number <- 7

list_of_tibbles_combinedexpr_logCPM_PSI_scaled <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_unscaled, .f = function(.x) {
  
  tibble_combinedexpr <- .x
  
  tibble_combinedexpr[, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")] <- tibble_combinedexpr[, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")] %>% genescale(m = ., axis = 1, method = "Z")
  
  return(tibble_combinedexpr)
  
})

# LAST TIME ENSEMBL CHANGED HALFWAY THRU THE ANALYSIS. IM NOT REPEATING THAT MISTAKE AGAIN

purrr::map2(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .y = names(list_of_tibbles_combinedexpr_logCPM_PSI_scaled), .f = ~write.table(.x, paste(R_processing_results_dir, "tibble", .y, "_GRCh38.99.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = TRUE))

# list_of_tibbles_combinedexpr_logCPM_PSI_scaled <- purrr::map(.x = names(list_of_tibbles_combinedexpr_logCPM_PSI_scaled), .f = ~read_delim(paste(R_processing_results_dir, "tibble", .y, "_GRCh38.99.txt", sep = ""), delim = "\t"))

set.seed(som_seed_number)

list_of_wide_tibbles_combinedexpr_som_sweep_clusters <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .f = function(.x) {
  
  tibble_combinedexpr_logCPM_PSI_scaled <- .x
  
  # calculate the cluster membership for each iteration of the SOM
  purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~som(tibble_combinedexpr_logCPM_PSI_scaled[, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")] %>% as.matrix, grid = somgrid(xdim = .x, ydim = .y, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)) %>% 
    purrr::reduce(bind_cols)
  
})

# set rownames to be the gene_identifier_ID
list_of_wide_df_combinedexpr_som_sweep_clusters <- purrr::map2(.x = list_of_wide_tibbles_combinedexpr_som_sweep_clusters, .y = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .f = function(.x, .y) {
  
  df <- .x %>% as.data.frame
  rownames(df) <- paste(.y$matched_gene_names, "_", .y$identifier, sep = "")
  
  return(df)
  
})

list_matchtest_combinedexpr_som_sweep_byisoform <- purrr::map(.x = list_of_wide_df_combinedexpr_som_sweep_clusters, .f = function(.x) {
  
  # DEBUG ###
  
  # df_of_membership <- list_of_wide_df_combinedexpr_som_sweep_clusters[[1]]
  
  ###########
  
  df_of_membership <- .x
  
  list_of_clusters <- purrr::map(.x = df_of_membership %>% array_tree, .f = ~base::unlist(.x)) 
  
  list_of_correlation_2 <- furrr::future_map(.x = list_of_clusters, .f = ~base::apply(X = df_of_membership, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("list_of_clusters", "df_of_membership")))
  
  return(list_of_correlation_2)
  
})

list_percentage_consensus_byisoform_combinedexpr <- purrr::map(.x = list_matchtest_combinedexpr_som_sweep_byisoform, .f = function(.x) {
  
  list_logical_coclustering_test <- .x
  
  list_percentage_consensus <- furrr::future_map(.x = list_logical_coclustering_test, .f = ~base::apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("list_logical_coclustering_test", "as_tibble")))
  
  return(list_percentage_consensus)
  
})

list_of_tables_consensus_matrix_combinedexpr <- purrr::map(.x = list_percentage_consensus_byisoform_combinedexpr, .f = ~.x %>% rbindlist)

list_of_consensus_matrices_combinedexpr <- purrr::map2(.x = list_of_tables_consensus_matrix_combinedexpr, .y = list_percentage_consensus_byisoform_combinedexpr, .f = function(.x, .y) {
  
  matrix <- .x %>% as.matrix
  
  rownames(matrix) <- names(.y)
  
  return(matrix)
  
})

# 2D clustering of consensus matrix
## create hclust dist matrix
list_of_consensus_matrices_combinedexpr_dist_result <- furrr::future_map(.x = list_of_consensus_matrices_combinedexpr, .f = ~.x %>% Rfast::Dist(method = "euclidean") %>% as.dist, .progress = TRUE, .options = future_options(globals = c("Rfast", "list_of_consensus_matrices_combinedexpr")))
## cluster based on distance matrix per row
list_of_consensus_matrices_combinedexpr_hclust_result <- purrr::map(.x = list_of_consensus_matrices_combinedexpr_dist_result, .f = ~fastcluster::hclust(.x, method = "ward.D2"))
## create dendrogram
list_of_consensus_matrices_combinedexpr_consensus_dendrogram <- purrr::map(.x = list_of_consensus_matrices_combinedexpr_hclust_result, .f = ~as.dendrogram(.x))
## reorder rows
# cols/rows should get darker as you move right/down
list_consensus_matrices_combinedexpr_rowmeans <- purrr::map(.x = list_of_consensus_matrices_combinedexpr, .f = ~rowMeans(.x, na.rm = T))
# matrix_consensus_matrix_combinedexpr_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix_combinedexpr) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_combinedexpr_singular_vectors_byrow <- apply(matrix_consensus_matrix_combinedexpr, 1 , FUN = function(X) {svd(X) %>% .$d})

list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered <- purrr::map2(.x = list_of_consensus_matrices_combinedexpr_consensus_dendrogram, .y = list_consensus_matrices_combinedexpr_rowmeans, .f = ~reorder(.x, .y))

purrr::pmap(.l = list(list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered, 
                      names(list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), 
            .f = ~ggdendrogram(..1) +
  xlab("Gene/isoform") +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "dendrogram_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE))

# extract the order of dendrogram
list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered_order <- list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered %>% purrr::map(~unlist(.x))
# reorder both the rows and columns of the consensus matrix according to the dendrogram order
list_consensus_matrices_combinedexpr_reordered <- purrr::map2(.x = list_of_consensus_matrices_combinedexpr, .y = list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered_order, .f = ~.x[.y, .y] %>% as_tibble(rownames = "gene_isoform_ID"))
# melt the reordered consensus matrix into a long tibble
list_tibble_consensus_matrix_combinedexpr_long <- list_consensus_matrices_combinedexpr_reordered %>% purrr::map(~reshape2::melt(.x, id = c("gene_isoform_ID"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_if(is.factor, as.character))

# write the tibbles
purrr::pmap(.l = list(list_consensus_matrices_combinedexpr_reordered, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~write.table(x = ..1, file = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

# plot the heatmaps
purrr::pmap(.l = list(list_tibble_consensus_matrix_combinedexpr_long, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~ggplot(..1, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("OBseries consensus matrix for som of ", nrow(..3), " exons, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", pvalue_or_FDR, pvalue_cutoff, " dPSI greaterthan ", dpsi_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_y_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_fill_gradientn(colours = c("blue", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_blank(), legend.title.align = 0.5, axis.text.y = element_blank(), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica"), panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
  ggsave(filename = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".png", sep = ""), device = "png", dpi = 300, width = 20, height = 15, units = "cm", limitsize = FALSE))

# plot heatmap data
purrr::pmap(.l = list(list_tibble_consensus_matrix_combinedexpr_long, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~write.table(x = ..1, file = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

# plot the heatmap axes text
purrr::pmap(.l = list(list_tibble_consensus_matrix_combinedexpr_long, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~ggplot(..1 %>% dplyr::distinct(., gene_isoform_ID, .keep_all = TRUE), aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("OBseries consensus matrix for som of ", nrow(..3), " exons, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", pvalue_or_FDR, pvalue_cutoff, " dPSI greaterthan ", dpsi_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_y_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_fill_gradientn(colours = c("blue", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".pdf", sep = ""), device = "pdf", dpi = 1200, width = 40, height = 25, units = "cm", limitsize = FALSE))

```

### cluster determination from consensus matrix

```{r message=FALSE, warning=FALSE}

# tibble_consensus_matrix_combinedexpr_long <- read_delim(paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), delim = "\t")

list_genes_or_exons_from_combinedexpr <- list_tibble_consensus_matrix_combinedexpr_long %>% purrr::map(~.x$variable %>% unique %>% array_tree)

# for each genes_identifier ID, group up those which have a cocluster percentage of more than 0.5
list_genes_or_exons_from_combinedexpr_cooccuring <- purrr::map2(.x = list_genes_or_exons_from_combinedexpr, .y = list_tibble_consensus_matrix_combinedexpr_long, .f = function(.x, .y) {
  
  gene_identifier_IDs <- .x
  consensus_scores <- .y
  
  list_of_coclustered_IDs <- future_map(.x = gene_identifier_IDs, .f = ~consensus_scores[consensus_scores$variable == .x & consensus_scores$cocluster_percentage >= 0.5, "gene_isoform_ID"], .progress = TRUE, .options = future_options(globals = c("gene_identifier_IDs", "consensus_scores")))
  
  names(list_of_coclustered_IDs) <- gene_identifier_IDs
  
  return(list_of_coclustered_IDs)
  
})

# take pairwise intersections
list_pairwise_comparisons_genes_or_exons_from_combinedexpr <- future_map(.x = list_genes_or_exons_from_combinedexpr, .f = function(.x) {
  
  tibble_comparisons <- combn(.x %>% unlist, m = 2) %>% t %>% as_tibble %>% setNames(c("comparison_1", "comparison_2"))
  
  list_comparisons <- list("list_comparison_1" = tibble_comparisons[, "comparison_1"] %>% array_tree, "list_comparison_2" = tibble_comparisons[, "comparison_2"] %>% array_tree)
  
  return(list_comparisons)
  
}, .progress = TRUE, .options = future_options(globals = c("as_tibble", "list_genes_or_exons_from_combinedexpr")))

# NOTE: EACH L1 ELEMENT OF THE FOLLOWING LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.
list_genes_or_isoforms_from_combinedexpr_itemwise_intersection <- purrr::map2(.x = list_pairwise_comparisons_genes_or_exons_from_combinedexpr, .y = list_genes_or_exons_from_combinedexpr_cooccuring, .f = function(.x, .y) {
  
  # DEBUG ###
  
  # gene_identifier_ID <- list_pairwise_comparisons_genes_or_exons_from_combinedexpr[[1]]
  
  ###########
  
  gene_identifier_ID <- .x
  genes_or_exons_from_combinedexpr_cooccuring <- .y
  
  list_intersection <- future_map2(.x = gene_identifier_ID[["list_comparison_1"]] %>% set_names(NULL), .y = gene_identifier_ID[["list_comparison_2"]] %>% set_names(NULL), .f = ~dplyr::intersect(genes_or_exons_from_combinedexpr_cooccuring[[.x]], genes_or_exons_from_combinedexpr_cooccuring[[.y]]) %>% length, .progress = TRUE) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")
  
  return(list_intersection)
  
})

# .options = future_options(globals = c("dplyr", "genes_or_exons_from_combinedexpr_cooccuring"))

list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff <- purrr::map2(.x = list_pairwise_comparisons_genes_or_exons_from_combinedexpr, .y = list_genes_or_exons_from_combinedexpr_cooccuring, .f = function(.x, .y) {
  
  # DEBUG ###
  
  # gene_identifier_ID <- list_pairwise_comparisons_genes_or_exons_from_combinedexpr[[1]]
  
  ###########
  
  gene_identifier_ID <- .x
  genes_or_exons_from_combinedexpr_cooccuring <- .y
  
  list_setdiff <- future_map2(.x = gene_identifier_ID[["list_comparison_1"]] %>% set_names(NULL), .y = gene_identifier_ID[["list_comparison_2"]] %>% set_names(NULL), .f = ~dplyr::setdiff(genes_or_exons_from_combinedexpr_cooccuring[[.x]], genes_or_exons_from_combinedexpr_cooccuring[[.y]]) %>% length, .progress = TRUE) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")
  
  return(list_setdiff)
  
})

# append the intersection and setdiff as new columns onto the pairwise comparison
list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- purrr::pmap(.l = list(list_pairwise_comparisons_genes_or_exons_from_combinedexpr,
                                                                                          list_genes_or_isoforms_from_combinedexpr_itemwise_intersection,
                                                                                          list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff), .f = ~bind_cols(..1 %>% as_tibble, ..2[, 1], ..3[, 1]) %>% add_column("jaccard" = .$coclustering_intersection/(.$coclustering_setdiff + .$coclustering_intersection)) %>% purrr::map(~unlist(.x)) %>% as_tibble)

# write the tables  - all intersection values
purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "itemwise_anyintersection_consensus0.5_", .y, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

# read the table back
# list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2), .f = ~read_delim(paste(R_processing_results_dir, "itemwise_anyintersection_consensus0.5_", .y, ".txt", sep = ""), delim = "\t"))

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3 <- purrr::map(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, .f = ~.x[.x$coclustering_intersection > 0, ])

# plot intersection distribution
purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3), .f = function(.x, .y) {
  
  pdf(paste(R_processing_results_dir, "itemwise_intersection1_consensus0.5_", .y, "_consensus.distribution.pdf", sep = ""))
  
  plot(density(.x$coclustering_intersection %>% as.numeric), main = paste("intersection score distribution for", .y))
  
  dev.off()
  
})

# write the tables - nonzero intersection values only
purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "itemwise_intersection1_consensus0.5_", .y, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### GO TO CYTOSCAPE HERE

```{r}

########### RETURN FROM CYTOSCAPE HERE ###################

# import the cluster membership info
list_cytoscape_result <- purrr::map(.x = list("consensus_separate.PSI_combinedexpr_intersection1_min25_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab",
                                              "consensus_sum.PSI_combinedexpr_intersection1_min25_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab"), .f = function(.x) {
                                                
                                                tibble_result <- read_delim(paste(R_processing_results_dir, .x, sep = ""), delim = "\t", col_names = c("cluster", "gene_identifier_ID"))
                                                tibble_result[, "cluster"] <- gsub(x = tibble_result$cluster, pattern = "Cluster ", replacement = "") %>% as.numeric
                                                
                                                return(tibble_result)
                                                
                                              } )

# append the gene_identifier_ID onto the tibble of combined scaled PSI and expr
list_of_tibbles_combinedexpr_logCPM_PSI_scaled_2 <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .f = ~bind_cols(.x, gene_identifier_ID = paste(.x$matched_gene_names, "_", .x$identifier, sep = "")))

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_results_by_cluster <- purrr::map(.x = list_cytoscape_result, .f = function(.x) {
  
  tibble_result <- .x
  
  purrr::map(.x = tibble_result$cluster %>% unique, .f = ~tibble_result[tibble_result$cluster == .x, ])
  
} ) %>% set_names(names(list_of_tibbles_combinedexpr_logCPM_PSI_scaled_2))

# bind the standardised PSI information to the cluster information
list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered <- purrr::map2(.x = list_cytoscape_results_by_cluster, .y = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_2, .f = function(.x, .y) {
  
  cytoscape_results_by_cluster <- .x
  tibbles_combinedexpr_logCPM_PSI_scaled_2 <- .y
  
  list_of_tibbles_with_cluster_info_by_cluster <- purrr::map(.x = cytoscape_results_by_cluster, .f = ~dplyr::left_join(.x, tibbles_combinedexpr_logCPM_PSI_scaled_2, by = "gene_identifier_ID"))
  
  tibble_with_cluster_info <- list_of_tibbles_with_cluster_info_by_cluster %>% purrr::reduce(dplyr::bind_rows)
  
  # reorder columns
  tibble_with_cluster_info <- tibble_with_cluster_info[, c(2:ncol(tibble_with_cluster_info), 1)]
  
  # reorder the cluster factor for correct facet order
  tibble_with_cluster_info$cluster <- factor(tibble_with_cluster_info$cluster %>% mixedsort, levels = tibble_with_cluster_info$cluster %>% unique %>% mixedsort)
  
  return(tibble_with_cluster_info)
  
} )

```

### generate expression profile map

the goal of this is to get extract timepoint PSI/expr tables according to each consensus cluster

```{r}

### convert the som table to a long form interprable by ggplot

# reshaping into long table
list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, .f = function(.x) {
  
  id.colnames <- setdiff(colnames(.x), c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"))
  
  long_tibble <- reshape2::melt(.x, id.vars = id.colnames, variable.name = "timepoint", value.name = "scaled_PSI.expr_value") %>% as_tibble
  
  return(long_tibble)
  
} )

# GGPLOT
purrr::pmap(.l = list(list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, 
                      names(list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered),
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~ggplot(..1, aes(x = timepoint, y = scaled_PSI.expr_value)) +
  geom_line(aes(group = gene_identifier_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("OBseries consensus SOM of ", nrow(..3), " exons, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", pvalue_or_FDR, pvalue_cutoff, " dPSI greaterthan ", dpsi_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI or expr. Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm", limitsize = FALSE))

purrr::pmap(.l = list(list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, 
                      names(list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered),
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~write.table(x = ..1, file = paste(R_processing_results_dir, "consensus_som_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Gene ontology of each SOM cluster, separate and summed PSI

#### preparation of separate data frames containing gene sets of each cluster

```{r}

# create list of SOM clusters
list_of_SOM_clusters <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, .f = ~.x$cluster %>% paste %>% unique %>% array_tree)

list_of_tibble_consensus.SOM_separate.PSI_subset_by_cluster <- purrr::map2(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, .y = list_of_SOM_clusters, .f = function(.x, .y) {
  
  wide_tibble_summary <- .x %>% mutate_if(is.factor, as.character)
  SOM_clusters <- .y
  
  list_of_subset_tibbles_by_cluster <- purrr::map(.x = SOM_clusters, .f = ~wide_tibble_summary[wide_tibble_summary$cluster == .x, ]) %>% set_names(SOM_clusters)
  
} ) %>% set_names(c(paste("separate.PSI_expr_", wide_table_of_final_SOM_summary_5_by_5_OBseries_separate$matched_gene_names %>% unique %>% length, sep = ""), 
                    paste("sum.PSI_expr_", wide_table_of_final_SOM_summary_5_by_5_OBseries_sum$matched_gene_names %>% unique %>% length, sep = "")))

# take gene set for each cluster - all expr and PSI genes
list_of_vectors_genesets_per_consensus.SOM_cluster_all <- purrr::map_depth(.x = list_of_tibble_consensus.SOM_separate.PSI_subset_by_cluster, .depth = 2, .ragged = FALSE, .f = ~.x$matched_gene_names %>% unique)

# take gene set for each cluster - all PSI genes only
list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly <- purrr::map_depth(.x = list_of_tibble_consensus.SOM_separate.PSI_subset_by_cluster, .depth = 2, .ragged = FALSE, .f = ~.x[.x$splicemode != "RNASeq", "matched_gene_names"] %>% unlist %>% unique)

```

#### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_consensus.SOM_genes_and_GOterms <- cross2(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_consensus.SOM_genes_and_GOterms_names <- cross2(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly %>% names, .y = list("MF", "BP", "CC"))

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map(.x = list_of_combinations_of_consensus.SOM_genes_and_GOterms, .f = ~purrr::map2(.x = .x[[1]], .y = .x[[2]], .f = ~GOHyperGAll(catdb = catdb, gocat = .y, Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble), .progress = TRUE)

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise, .f = ~purrr::map(.x = .x, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 10)))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# ggplot, separate PSI
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# Quality checks

## Set directory

```{r}

qualitycheck_results_dir <- paste(R_processing_results_dir, "qualitycheck/", sep = "")

if(! dir.exists(qualitycheck_results_dir) ) {
     dir.create(qualitycheck_results_dir, recursive = TRUE)}

```

## graph distributions of p-values

```{r}

# plot pvalue
pdf(paste(qualitycheck_results_dir, "qualityplot_pvalues_density.distribution.pdf", sep = "")) 
  
  plot(density(long_tibble_of_psisigma_DEXSeq_results[, "DEXSeq_pvalue"] %>% na.omit %>% unlist), xlab = "DEXSeq_pvalue", ylab = "frequency density", main = "PSI-Sigma/DEXSeq p-value density distribution")
  
dev.off()

pdf(paste(qualitycheck_results_dir, "qualityplot_pvalues_CDF.pdf", sep = "")) 
  
  plot(ecdf(long_tibble_of_psisigma_DEXSeq_results[, "DEXSeq_pvalue"] %>% na.omit %>% unlist), xlab = "DEXSeq_pvalue", ylab = "cumulative frequency", main = "PSI-Sigma/DEXSeq p-value CDF")
  
dev.off()
  
vector_col.index_absolute.psi.comparison.1 <- grep(x = colnames(long_tibble_of_psisigma_DEXSeq_results), pattern = "comparison.1_")
vector_col.index_absolute.psi.comparison.2 <- grep(x = colnames(long_tibble_of_psisigma_DEXSeq_results), pattern = "comparison.2_")

# plot qvalue
pdf(paste(qualitycheck_results_dir, "qualityplot_FDR_density.distribution.pdf", sep = "")) 
  
  plot(density(long_tibble_of_psisigma_DEXSeq_results[, "DEXSeq_padj"] %>% na.omit %>% unlist), xlab = "DEXSeq_padj", ylab = "frequency density", main = "PSI-Sigma/DEXSeq FDR density distribution")
  
dev.off()

pdf(paste(qualitycheck_results_dir, "qualityplot_FDR_CDF.pdf", sep = "")) 
  
  plot(ecdf(long_tibble_of_psisigma_DEXSeq_results[, "DEXSeq_padj"] %>% na.omit %>% unlist), xlab = "DEXSeq_padj", ylab = "cumulative frequency", main = "PSI-Sigma/DEXSeq FDR CDF")
  
dev.off()
  
# plot all the absolute PSI values
# plot(density(long_tibble_of_psisigma_DEXSeq_results[long_tibble_of_psisigma_DEXSeq_results$comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_12h" & long_tibble_of_psisigma_DEXSeq_results$pvalue < 0.4 & long_tibble_of_psisigma_DEXSeq_results$pvalue > 0.35, c(1, vector_col.index_absolute.psi.comparison.1, vector_col.index_absolute.psi.comparison.2)] %>% melt(.,id.vars = "database_ID", variable.name = "comparison.replicate", value.name = "absolute.psi") %>% .$absolute.psi %>% na.omit), main = "distribution of PSI values for comparisons with a p value of \n between 0.35 and 0.4")
  
# plot dpsi distribution
pdf(paste(qualitycheck_results_dir, "qualityplot_dpsi_density.distribution.pdf", sep = "")) 
  
  plot(density(long_tibble_of_psisigma_DEXSeq_results[, "dpsi"] %>% na.omit %>% unlist), xlab = "dpsi", ylab = "frequency density", main = "PSI-Sigma dpsi frequency density")
  
dev.off()

pdf(paste(qualitycheck_results_dir, "qualityplot_dpsi_CDF.pdf", sep = "")) 
  
  plot(ecdf(long_tibble_of_psisigma_DEXSeq_results[, "dpsi"] %>% na.omit %>% unlist), xlab = "dpsi", ylab = "cumulative frequency", main = "PSI-Sigma dpsi CDF")
  
dev.off()

```

## check the concordance between the ref and recon gtf first/last exon and NMD

```{r}

# wide_tibble_of_psisigma_results_allcomparisons_final_no.IR <- long_tibble_of_psisigma_DEXSeq_results[grep(x = long_tibble_of_psisigma_DEXSeq_results$splicemode, pattern = "IR"), ]

# get row indices of first/last exon and NMD annotations.
## first exon
row.indices_first_exon_ref <- grep(x = long_tibble_of_psisigma_DEXSeq_results$first_or_last_exon_reference, pattern = "first_exon")
row.indices_first_exon_recon <- grep(x = long_tibble_of_psisigma_DEXSeq_results$first_or_last_exon_recon, pattern = "first_exon")

row.indices_first_exon_ref.recon.intersection <- intersect(row.indices_first_exon_ref, row.indices_first_exon_recon)
row.indices_first_exon_ref.recon.union <- union(row.indices_first_exon_ref, row.indices_first_exon_recon)

message("number of first exons in the reference: ", row.indices_first_exon_ref %>% length)
message("number of first exons in the recon: ", row.indices_first_exon_recon %>% length)
message("number of first exons in BOTH recon and reference: ", row.indices_first_exon_ref.recon.intersection %>% length)
message("first exons jaccard similarity: ", (row.indices_first_exon_ref.recon.intersection %>% length)/(row.indices_first_exon_ref.recon.union %>% length))

## last exon
row.indices_last_exon_ref <- grep(x = long_tibble_of_psisigma_DEXSeq_results$first_or_last_exon_reference, pattern = "last_exon")
row.indices_last_exon_recon <- grep(x = long_tibble_of_psisigma_DEXSeq_results$first_or_last_exon_recon, pattern = "last_exon")

row.indices_last_exon_ref.recon.intersection <- intersect(row.indices_last_exon_ref, row.indices_last_exon_recon)
row.indices_last_exon_ref.recon.union <- union(row.indices_last_exon_ref, row.indices_last_exon_recon)

message("number of last exons in the reference: ", row.indices_last_exon_ref %>% length)
message("number of last exons in the recon: ", row.indices_last_exon_recon %>% length)
message("number of last exons in BOTH recon and reference: ", row.indices_last_exon_ref.recon.intersection %>% length)
message("last exons jaccard similarity: ", (row.indices_last_exon_ref.recon.intersection %>% length)/(row.indices_last_exon_ref.recon.union %>% length))

## NMD
row.indices_NMD_ref <- grep(x = long_tibble_of_psisigma_DEXSeq_results$NMD_biotype_reference, pattern = "TRUE")
row.indices_NMD_recon <- grep(x = long_tibble_of_psisigma_DEXSeq_results$NMD_flagged_recon, pattern = "TRUE")

row.indices_NMD_ref.recon.intersection <- intersect(row.indices_NMD_ref, row.indices_NMD_recon)
row.indices_NMD_ref.recon.union <- union(row.indices_NMD_ref, row.indices_NMD_recon)

message("number of NMD in the reference: ", row.indices_NMD_ref %>% length)
message("number of NMD in the recon: ", row.indices_NMD_recon %>% length)
message("number of NMD in BOTH recon and reference: ", row.indices_NMD_ref.recon.intersection %>% length)
message("NMD jaccard similarity: ", (row.indices_NMD_ref.recon.intersection %>% length)/(row.indices_NMD_ref.recon.union %>% length))

```

## frequency distribution of no. exons detected/gene

### ALL exons

```{r}

avg_exons_per_gene_all <- (long_tibble_of_psisigma_DEXSeq_results$diff_exon_coords %>% unique %>% length)/(long_tibble_of_psisigma_DEXSeq_results$matched_gene_names %>% unique %>% length)

print(paste("There are", avg_exons_per_gene_all, "unique exons/gene detected overall"))

tibble_all_exons_per_gene_freq <- long_tibble_of_psisigma_DEXSeq_results %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons = n())

tibble_all_exons_per_gene_freq_2 <- tibble_all_exons_per_gene_freq %>% group_by(no_exons) %>% summarise(NumberOfGenesWithExonNumber = n())

# ggplot
ggplot(tibble_all_exons_per_gene_freq_2) + 
  geom_col(aes(y = NumberOfGenesWithExonNumber, x = no_exons)) +
  geom_text(data = tibble_all_exons_per_gene_freq_2, aes(label = NumberOfGenesWithExonNumber, y = NumberOfGenesWithExonNumber + 20, x = no_exons), position = position_nudge(y = 300), angle = 90) +
  ggtitle(paste("frequency distribution of exons per gene\n1:2 ratio = ", tibble_all_exons_per_gene_freq_2[1, 2]/tibble_all_exons_per_gene_freq_2[2, 2], "\naverage ", avg_exons_per_gene_all, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  ylim(c(0, max(tibble_all_exons_per_gene_freq_2$NumberOfGenesWithExonNumber) + 500)) +
  scale_x_continuous(limits = c(0, 11), breaks = 1:11) +
  xlab("number of exons/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_all.pdf", sep = ""), device = "pdf", dpi = 600, width = 8, height = 8, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_all.svg", sep = ""), device = "svg", dpi = 600, width = 8, height = 8, units = "cm") 

# print(paste("Ratio of number of 1 exon genes : 2 exon genes =", tibble_all_exons_per_gene_freq_2[1, 2]/tibble_all_exons_per_gene_freq_2[2, 2]))

```

### all constitutive exons

```{r}

avg_exons_per_gene_constitutive <- (tibble_constitutive_LIV_info$diff_exon_coords %>% unique %>% length)/(tibble_constitutive_LIV_info$matched_gene_names %>% unique %>% length)

print(paste("There are", avg_exons_per_gene_constitutive, "unique constitutive exons/gene detected"))

tibble_constitutive_exons_per_gene_freq <- tibble_constitutive_LIV_info %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons = n())

tibble_constitutive_exons_per_gene_freq_2 <- tibble_constitutive_exons_per_gene_freq %>% group_by(no_exons) %>% summarise(NumberOfGenesWithExonNumber = n())

# ggplot
ggplot(tibble_constitutive_exons_per_gene_freq_2) + 
  geom_col(aes(y = NumberOfGenesWithExonNumber, x = no_exons)) +
  geom_text(data = tibble_constitutive_exons_per_gene_freq_2, aes(label = NumberOfGenesWithExonNumber, y = NumberOfGenesWithExonNumber + 20, x = no_exons), position = position_nudge(y = 300), angle = 90) +
  ggtitle(paste("frequency distribution of exons per gene\n1:2 ratio = ", tibble_constitutive_exons_per_gene_freq_2[1, 2]/tibble_constitutive_exons_per_gene_freq_2[2, 2], "\naverage ", avg_exons_per_gene_constitutive, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  ylim(c(0, max(tibble_constitutive_exons_per_gene_freq_2$NumberOfGenesWithExonNumber) + 500)) +
  scale_x_continuous(limits = c(0, 11), breaks = 1:11) +
  xlab("number of exons/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_constitutive.pdf", sep = ""), device = "pdf", dpi = 600, width = 8, height = 8, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_constitutive.svg", sep = ""), device = "svg", dpi = 600, width = 8, height = 8, units = "cm") 

# print(paste("Ratio of number of 1 exon genes : 2 exon genes =", tibble_constitutive_exons_per_gene_freq_2[1, 2]/tibble_constitutive_exons_per_gene_freq_2[2, 2]))

```

### all differential exons

```{r}

avg_exons_per_gene_differential <- (wide_tibble_of_psisigma_results_allcomparisons_differential$diff_exon_coords %>% unique %>% length)/(wide_tibble_of_psisigma_results_allcomparisons_differential$matched_gene_names %>% unique %>% length)

print(paste("There are", avg_exons_per_gene_differential, "unique differential exons/gene detected"))

tibble_differential_exons_per_gene_freq <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons = n())

tibble_differential_exons_per_gene_freq_2 <- tibble_differential_exons_per_gene_freq %>% group_by(no_exons) %>% summarise(NumberOfGenesWithExonNumber = n())

# ggplot
ggplot(tibble_differential_exons_per_gene_freq_2) + 
  geom_col(aes(y = NumberOfGenesWithExonNumber, x = no_exons)) +
  geom_text(data = tibble_differential_exons_per_gene_freq_2, aes(label = NumberOfGenesWithExonNumber, y = NumberOfGenesWithExonNumber + 20, x = no_exons), position = position_nudge(y = 100), angle = 90) +
  ggtitle(paste("frequency distribution of exons per gene\n1:2 ratio = ", tibble_differential_exons_per_gene_freq_2[1, 2]/tibble_differential_exons_per_gene_freq_2[2, 2], "\naverage ", avg_exons_per_gene_differential, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  ylim(c(0, max(tibble_differential_exons_per_gene_freq_2$NumberOfGenesWithExonNumber) + 200)) +
  scale_x_continuous(limits = c(0, 11), breaks = 1:11) +
  xlab("number of exons/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_differential.pdf", sep = ""), device = "pdf", dpi = 600, width = 8, height = 8, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_differential.svg", sep = ""), device = "svg", dpi = 600, width = 8, height = 8, units = "cm") 

# print(paste("Ratio of number of 1 exon genes : 2 exon genes =", tibble_differential_exons_per_gene_freq_2[1, 2]/tibble_differential_exons_per_gene_freq_2[2, 2]))

```

## frequency distribution of no. exons detected per category

incl. NMD, first/last exon.

```{r}

# band-aid: add columns for reference first/last exon.
long_tibble_of_psisigma_DEXSeq_results_first.last.reference <- long_tibble_of_psisigma_DEXSeq_results %>% 
  add_column("first_exon_reference" = grepl(x = long_tibble_of_psisigma_DEXSeq_results$first_or_last_exon_reference, pattern = "first_exon"),
             "last_exon_reference" = grepl(x = long_tibble_of_psisigma_DEXSeq_results$first_or_last_exon_reference, pattern = "last_exon"))

tibble_constitutive_LIV_info_first.last.reference <- tibble_constitutive_LIV_info %>% 
  add_column("first_exon_reference" = grepl(x = tibble_constitutive_LIV_info$first_or_last_exon_reference, pattern = "first_exon"),
             "last_exon_reference" = grepl(x = tibble_constitutive_LIV_info$first_or_last_exon_reference, pattern = "last_exon"))

wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_first.last.reference <- wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV %>% 
  add_column("first_exon_reference" = grepl(x = wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV$first_or_last_exon_reference, pattern = "first_exon"),
             "last_exon_reference" = grepl(x = wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV$first_or_last_exon_reference, pattern = "last_exon"))

# category means splicemode + NMD status + first/last exon
# also clean up the splicemode column
tibble_exons_per_category_all <- long_tibble_of_psisigma_DEXSeq_results_first.last.reference %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2", perl = TRUE)} ) %>% dplyr::distinct(., event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% 
  # , any_NMD
  group_by(splicemode, NMD_flagged_recon, introduces_PTC_for_all_matched_transcripts, alters_frame_for_all_matched_transcripts, first_exon_reference, last_exon_reference) %>% summarise(no_exons_all = n())

all_exons_count <- tibble_exons_per_category_all$no_exons_all %>% sum(na.rm = TRUE)
number_NMD_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$NMD_flagged_recon == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
# number_poison_exon_candidate_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$poison_exon_candidate_ref == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
number_introduces_PTC_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$introduces_PTC_for_all_matched_transcripts == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
number_alters_frame_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$alters_frame_for_all_matched_transcripts == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
number_first_exon_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$first_exon_reference == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
number_last_exon_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$last_exon_reference == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)

message("There are ", number_NMD_all_exons*100/all_exons_count, "% NMD exons overall from reconstructed transcriptome")
# message("There are ", number_poison_exon_candidate_all_exons*100/all_exons_count, "% poison exon candidates overall.")
message("There are ", number_introduces_PTC_all_exons*100/all_exons_count, "% PTC introducing exons overall.")
message("There are ", number_alters_frame_all_exons*100/all_exons_count, "% frame-altering exons overall.")
message("There are ", number_first_exon_all_exons*100/all_exons_count, "% first exons overall.")
message("There are ", number_last_exon_all_exons*100/all_exons_count, "% last exons overall.")

tibble_exons_per_category_constitutive <- tibble_constitutive_LIV_info_first.last.reference %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% group_by(splicemode, NMD_flagged_recon, introduces_PTC_for_all_matched_transcripts, alters_frame_for_all_matched_transcripts, first_exon_reference, last_exon_reference) %>% summarise(no_exons_constitutive = n())

constitutive_exons_count <- tibble_exons_per_category_constitutive$no_exons_constitutive %>% sum(na.rm = TRUE)
number_NMD_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$NMD_flagged_recon == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
# number_poison_exon_candidate_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$poison_exon_candidate_ref == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
number_introduces_PTC_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$introduces_PTC_for_all_matched_transcripts == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
number_alters_frame_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$alters_frame_for_all_matched_transcripts == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
number_first_exon_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$first_exon_reference == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
number_last_exon_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$last_exon_reference == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)

message("There are ", number_NMD_constitutive_exons*100/constitutive_exons_count, "% NMD exons constitutive from reconstructed transcriptome.")
# message("There are ", number_poison_exon_candidate_constitutive_exons*100/constitutive_exons_count, "% poison exon candidates constitutive.")
message("There are ", number_introduces_PTC_constitutive_exons*100/constitutive_exons_count, "% PTC introducing exons constitutive.")
message("There are ", number_alters_frame_constitutive_exons*100/constitutive_exons_count, "% frame-altering exons constitutive.")
message("There are ", number_first_exon_constitutive_exons*100/constitutive_exons_count, "% first exons constitutive.")
message("There are ", number_last_exon_constitutive_exons*100/constitutive_exons_count, "% last exons constitutive.")

tibble_exons_per_category_differential <- wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_first.last.reference %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% group_by(splicemode, NMD_flagged_recon, introduces_PTC_for_all_matched_transcripts, alters_frame_for_all_matched_transcripts, first_exon_reference, last_exon_reference) %>% summarise(no_exons_differential = n())

differential_exons_count <- tibble_exons_per_category_differential$no_exons_differential %>% sum(na.rm = TRUE)
number_NMD_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$NMD_flagged_recon == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
# number_poison_exon_candidate_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$poison_exon_candidate_ref == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
number_introduces_PTC_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$introduces_PTC_for_all_matched_transcripts == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
number_alters_frame_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$alters_frame_for_all_matched_transcripts == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
number_first_exon_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$first_exon_reference == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
number_last_exon_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$last_exon_reference == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)

message("There are ", number_NMD_differential_exons*100/differential_exons_count, "% NMD exons differential from reconstructed transcriptome.")
# message("There are ", number_poison_exon_candidate_differential_exons*100/differential_exons_count, "% poison exon candidates differential.")
message("There are ", number_introduces_PTC_differential_exons*100/differential_exons_count, "% PTC introducing exons differential.")
message("There are ", number_alters_frame_differential_exons*100/differential_exons_count, "% frame-altering exons differential.")
message("There are ", number_first_exon_differential_exons*100/differential_exons_count, "% first exons differential.")
message("There are ", number_last_exon_differential_exons*100/differential_exons_count, "% last exons differential.")

# BAR/UPSET PLOTS
tibble_exons_per_category_summary <- list(tibble_exons_per_category_all, tibble_exons_per_category_constitutive, tibble_exons_per_category_differential) %>% purrr::reduce(dplyr::full_join)

# complete each factor combination of splicemode~TRUE/FALSE~TRUE/FALSE~... to make implicit missing rows explicit
tibble_complete_grid <- tidyr::expand_grid(
  "splicemode" = tibble_exons_per_category_summary$splicemode %>% unique,
  "NMD_flagged_recon" = tibble_exons_per_category_summary$NMD_flagged_recon %>% unique,
  "introduces_PTC_for_all_matched_transcripts" = tibble_exons_per_category_summary$introduces_PTC_for_all_matched_transcripts %>% unique, 
  "alters_frame_for_all_matched_transcripts" = tibble_exons_per_category_summary$alters_frame_for_all_matched_transcripts %>% unique, 
  "first_exon_reference" = tibble_exons_per_category_summary$first_exon_reference %>% unique, 
  "last_exon_reference" = tibble_exons_per_category_summary$last_exon_reference %>% unique
)

# dplyr::left_join onto the complete grid. this will reveal all the missing as NA.
tibble_exons_per_category_summary_completed <- dplyr::left_join(tibble_complete_grid, tibble_exons_per_category_summary)

# now set all NA to zero.
tibble_exons_per_category_summary_completed[is.na(tibble_exons_per_category_summary_completed)] <- 0

# melt the sample
long_tibble_exons_per_category_summary <- reshape2::melt(tibble_exons_per_category_summary_completed, id.vars = c("splicemode", "NMD_flagged_recon", "introduces_PTC_for_all_matched_transcripts", "alters_frame_for_all_matched_transcripts", "first_exon_reference", "last_exon_reference"), variable.name = "sample", value.name = "number_of_exons_per_category") %>% as_tibble %>% 
  # add the overall counts for each splicemode
  dplyr::group_by(splicemode, sample) %>% dplyr::mutate("number_of_exons_per_splicemode" = sum(number_of_exons_per_category %>% na.omit))

# melt the category
long_tibble_exons_per_category_summary_2 <- reshape2::melt(long_tibble_exons_per_category_summary, id.vars = c("splicemode", "sample", "number_of_exons_per_category", "number_of_exons_per_splicemode"), variable.name = "NMD_first_last_exon", value.name = "NMD_first_last_exon_value") %>% as_tibble %>% 
  # add the overall counts for each unique category
  dplyr::group_by(splicemode, sample, NMD_first_last_exon, NMD_first_last_exon_value) %>% dplyr::mutate("number_of_exons_per_category" = sum(number_of_exons_per_category %>% na.omit)) %>% unique %>%
  # add the percentage for each category/splicemode
  dplyr::mutate("percentage_exons_per_category" = number_of_exons_per_category*100/number_of_exons_per_splicemode)

max_number_of_exons_per_splicemode <- max(long_tibble_exons_per_category_summary_2$number_of_exons_per_splicemode)
max_percentage_exons_per_category <- max(long_tibble_exons_per_category_summary_2[long_tibble_exons_per_category_summary_2$NMD_first_last_exon_value == TRUE, ] %>% .$percentage_exons_per_category %>% na.omit)
max_number_of_exons_per_splicemode_for_plot <- max_number_of_exons_per_splicemode + 3000

# write the table
write.table(long_tibble_exons_per_category_summary_2, file = paste(R_processing_results_dir, "frequency_distribution_of_exons_per_category_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".txt", sep = ""), row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t")

# ggplot
ggplot() + 
  geom_col(data = long_tibble_exons_per_category_summary_2[, c("splicemode", "sample", "number_of_exons_per_splicemode")] %>% dplyr::distinct(splicemode, sample, .keep_all = TRUE), aes(y = number_of_exons_per_splicemode, x = splicemode)) +
  facet_wrap(~sample, scales = "free", labeller = labeller(sample = c(no_exons_all = "All exons", no_exons_constitutive = "Constitutive", no_exons_differential = "Differential"))) +
  geom_text(data = long_tibble_exons_per_category_summary_2[, c("splicemode", "sample", "number_of_exons_per_splicemode")]  %>% dplyr::distinct(splicemode, sample, .keep_all = TRUE), aes(label = number_of_exons_per_splicemode, y = number_of_exons_per_splicemode, x = splicemode), angle = 90, position = position_nudge(x = 0, y = 2000)) +
  geom_point(data = long_tibble_exons_per_category_summary_2[long_tibble_exons_per_category_summary_2$NMD_first_last_exon_value == TRUE, ], aes(x = splicemode, y = percentage_exons_per_category * max_number_of_exons_per_splicemode_for_plot / 100 , shape = NMD_first_last_exon, colour = NMD_first_last_exon), width = 0.1, height = 0) + ggtitle(paste("Frequency distribution of exons per category 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  xlab("Splicemode") +
  scale_y_continuous(name = "Number of exons", limits = c(0, max_number_of_exons_per_splicemode_for_plot), sec.axis = sec_axis(trans = ~. * 100/max_number_of_exons_per_splicemode_for_plot, (name = "Percentage category per splicemode"), breaks = seq(0, 100, 20))) +
  scale_shape_manual(name = "Category", limits = c("first_exon_reference", "last_exon_reference", "introduces_PTC_for_all_matched_transcripts", "alters_frame_for_all_matched_transcripts", "NMD_flagged_recon"), labels = c("First exon", "Last exon", "Poison exon", "Alters frame", "NMD\n(predicted)"), values = c(15, 19, 8, 11, 6)) +
  scale_colour_brewer(name = "Category", type = "seq", limits = c("first_exon_reference", "last_exon_reference", "introduces_PTC_for_all_matched_transcripts", "alters_frame_for_all_matched_transcripts", "NMD_flagged_recon"), labels = c("First exon", "Last exon", "Poison exon", "Alters frame", "NMD\n(predicted)"), palette = "Set2") +
  # scale_shape_manual(name = "Category", limits = c("any_NMD", "first_exon_reference", "last_exon_reference"), labels = c("NMD candidate", "First exon", "Last exon"), values = c(1, 4, 19)) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "frequency_distribution_of_exons_per_category_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 8, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "frequency_distribution_of_exons_per_category_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 8, units = "cm") 

# upset plot
message("all exons")
df <- long_tibble_of_psisigma_DEXSeq_results_first.last.reference %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% .[, c("event_region_coords", "diff_exon_coords", "splicemode", "NMD_flagged_recon", "introduces_PTC_for_all_matched_transcripts", "alters_frame_for_all_matched_transcripts", "first_exon_reference", "last_exon_reference")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = event_region_coords + diff_exon_coords + splicemode + NMD_flagged_recon + introduces_PTC_for_all_matched_transcripts + alters_frame_for_all_matched_transcripts + first_exon_reference + last_exon_reference ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -event_region_coords, -diff_exon_coords), row.names = paste(df$event_region_coords, df$diff_exon_coords, sep = "_")) %>% make_comb_mat(mode = "intersect")

print(set_size(upset_combs))

pdf(file = paste(R_processing_results_dir, "upset_plot_of_intersections_exons_per_NMD.first.last.exon_per_splicemode_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_allexons.pdf", sep = ""), height = 4, width = 20)

ht <- ComplexHeatmap::UpSet(upset_combs, 
                                 comb_order = order(-comb_size(upset_combs)), 
                                 left_annotation = rowAnnotation("Set Type" = c("NMD_flagged_recon" = "Exon ontology",
                                                                                "introduces_PTC_for_all_matched_transcripts" = "Exon ontology",
                                                                                "alters_frame_for_all_matched_transcripts" = "Exon ontology",
                                                                                "first_exon_reference" = "Exon ontology",
                                                                                "last_exon_reference" = "Exon ontology",
                                                                                "A3SS" = "Splicemode",
                                                                                "A5SS" = "Splicemode",
                                                                                "IR" = "Splicemode",
                                                                                "MES" = "Splicemode",
                                                                                "MXS" = "Splicemode",
                                                                                "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                                 col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                 ),
                                 row_labels =  c("NMD (recon)", "Poison exon", "Alters frame", "First exon", "Last exon", "A3SS", "A5SS", "IR", "MES", "MXS", "SES")
)

ro <- row_order(ht)
sz <- set_size(upset_combs)

ht <- draw(ComplexHeatmap::UpSet(upset_combs, 
                                 comb_order = order(-comb_size(upset_combs)), 
                                 left_annotation = rowAnnotation("Set Type" = c("NMD_flagged_recon" = "Exon ontology",
                                                                                "introduces_PTC_for_all_matched_transcripts" = "Exon ontology",
                                                                                "alters_frame_for_all_matched_transcripts" = "Exon ontology",
                                                                                "first_exon_reference" = "Exon ontology",
                                                                                "last_exon_reference" = "Exon ontology",
                                                                                "A3SS" = "Splicemode",
                                                                                "A5SS" = "Splicemode",
                                                                                "IR" = "Splicemode",
                                                                                "MES" = "Splicemode",
                                                                                "MXS" = "Splicemode",
                                                                                "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                                 col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                 ),
                                 row_labels =  c("NMD (recon)", "Poison exon", "Alters frame", "First exon", "Last exon", "A3SS", "A5SS", "IR", "MES", "MXS", "SES")
) +
  rowAnnotation(labels = anno_text(sz, which = "row", just = c("left", "centre"), gp = gpar(fontsize = 9)), 
                width = max(grobWidth(textGrob(sz))))
)

co <- column_order(ht)
cs <- comb_size(upset_combs)

decorate_annotation("Intersection\nsize", {
  grid.text(cs[co], x = seq_along(cs), y = unit(cs[co], "native") + unit(2, "pt"), 
            default.units = "native", just = c("left", "centre"), gp = gpar(fontsize = 9), rot = 90)
  
} )

dev.off()

message("all constitutive")
df <- tibble_constitutive_LIV_info_first.last.reference %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% .[, c("event_region_coords", "diff_exon_coords", "splicemode", "NMD_flagged_recon", "introduces_PTC_for_all_matched_transcripts", "alters_frame_for_all_matched_transcripts", "first_exon_reference", "last_exon_reference")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = event_region_coords + diff_exon_coords + splicemode + NMD_flagged_recon + introduces_PTC_for_all_matched_transcripts + alters_frame_for_all_matched_transcripts + first_exon_reference + last_exon_reference ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -event_region_coords, -diff_exon_coords), row.names = paste(df$event_region_coords, df$diff_exon_coords, sep = "_")) %>% make_comb_mat(mode = "intersect")

print(set_size(upset_combs))

pdf(file = paste(R_processing_results_dir, "upset_plot_of_intersections_exons_per_NMD.first.last.exon_per_splicemode_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_constitutive.pdf", sep = ""), height = 4, width = 20)

ht <- ComplexHeatmap::UpSet(upset_combs, 
                                 comb_order = order(-comb_size(upset_combs)), 
                                 left_annotation = rowAnnotation("Set Type" = c("NMD_flagged_recon" = "Exon ontology",
                                                                                "introduces_PTC_for_all_matched_transcripts" = "Exon ontology",
                                                                                "alters_frame_for_all_matched_transcripts" = "Exon ontology",
                                                                                "first_exon_reference" = "Exon ontology",
                                                                                "last_exon_reference" = "Exon ontology",
                                                                                "A3SS" = "Splicemode",
                                                                                "A5SS" = "Splicemode",
                                                                                "IR" = "Splicemode",
                                                                                "MES" = "Splicemode",
                                                                                "MXS" = "Splicemode",
                                                                                "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                                 col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                 ),
                                 row_labels =  c("NMD (recon)", "Poison exon", "Alters frame", "First exon", "Last exon", "A3SS", "A5SS", "IR", "MES", "MXS", "SES")
)

ro <- row_order(ht)
sz <- set_size(upset_combs)

ht <- draw(ComplexHeatmap::UpSet(upset_combs, 
                                 comb_order = order(-comb_size(upset_combs)), 
                                 left_annotation = rowAnnotation("Set Type" = c("NMD_flagged_recon" = "Exon ontology",
                                                                                "introduces_PTC_for_all_matched_transcripts" = "Exon ontology",
                                                                                "alters_frame_for_all_matched_transcripts" = "Exon ontology",
                                                                                "first_exon_reference" = "Exon ontology",
                                                                                "last_exon_reference" = "Exon ontology",
                                                                                "A3SS" = "Splicemode",
                                                                                "A5SS" = "Splicemode",
                                                                                "IR" = "Splicemode",
                                                                                "MES" = "Splicemode",
                                                                                "MXS" = "Splicemode",
                                                                                "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                                 col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                 ),
                                 row_labels =  c("NMD (recon)", "Poison exon", "Alters frame", "First exon", "Last exon", "A3SS", "A5SS", "IR", "MES", "MXS", "SES")
) +
  rowAnnotation(labels = anno_text(sz, which = "row", just = c("left", "centre"), gp = gpar(fontsize = 9)), 
                width = max(grobWidth(textGrob(sz))))
)

co <- column_order(ht)
cs <- comb_size(upset_combs)

decorate_annotation("Intersection\nsize", {
  grid.text(cs[co], x = seq_along(cs), y = unit(cs[co], "native") + unit(2, "pt"), 
            default.units = "native", just = c("left", "centre"), gp = gpar(fontsize = 9), rot = 90)
  
} )

dev.off()

message("all differential")
df <- wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_first.last.reference %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% .[, c("event_region_coords", "diff_exon_coords", "splicemode", "NMD_flagged_recon", "introduces_PTC_for_all_matched_transcripts", "alters_frame_for_all_matched_transcripts", "first_exon_reference", "last_exon_reference")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = event_region_coords + diff_exon_coords + splicemode + NMD_flagged_recon + introduces_PTC_for_all_matched_transcripts + alters_frame_for_all_matched_transcripts + first_exon_reference + last_exon_reference ~ splicemode, value.var = "dummy") %>% as_tibble 
# , "any_NMD"
 # + any_NMD

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -event_region_coords, -diff_exon_coords), row.names = paste(df$event_region_coords, df$diff_exon_coords, sep = "_")) %>% make_comb_mat(mode = "intersect")

print(set_size(upset_combs))

pdf(file = paste(R_processing_results_dir, "upset_plot_of_intersections_exons_per_NMD.first.last.exon_per_splicemode_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_differential.pdf", sep = ""), height = 4, width = 20)

ht <- ComplexHeatmap::UpSet(upset_combs, 
                                 comb_order = order(-comb_size(upset_combs)), 
                                 left_annotation = rowAnnotation("Set Type" = c("NMD_flagged_recon" = "Exon ontology",
                                                                                "introduces_PTC_for_all_matched_transcripts" = "Exon ontology",
                                                                                "alters_frame_for_all_matched_transcripts" = "Exon ontology",
                                                                                "first_exon_reference" = "Exon ontology",
                                                                                "last_exon_reference" = "Exon ontology",
                                                                                "A3SS" = "Splicemode",
                                                                                "A5SS" = "Splicemode",
                                                                                "IR" = "Splicemode",
                                                                                "MES" = "Splicemode",
                                                                                "MXS" = "Splicemode",
                                                                                "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                                 col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                 ),
                                 row_labels =  c("NMD (recon)", "Poison exon", "Alters frame", "First exon", "Last exon", "A3SS", "A5SS", "IR", "MES", "MXS", "SES")
)

ro <- row_order(ht)
sz <- set_size(upset_combs)

ht <- draw(ComplexHeatmap::UpSet(upset_combs, 
                                 comb_order = order(-comb_size(upset_combs)), 
                                 left_annotation = rowAnnotation("Set Type" = c("NMD_flagged_recon" = "Exon ontology",
                                                                                "introduces_PTC_for_all_matched_transcripts" = "Exon ontology",
                                                                                "alters_frame_for_all_matched_transcripts" = "Exon ontology",
                                                                                "first_exon_reference" = "Exon ontology",
                                                                                "last_exon_reference" = "Exon ontology",
                                                                                "A3SS" = "Splicemode",
                                                                                "A5SS" = "Splicemode",
                                                                                "IR" = "Splicemode",
                                                                                "MES" = "Splicemode",
                                                                                "MXS" = "Splicemode",
                                                                                "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                                 col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                 ),
                                 row_labels =  c("NMD (recon)", "Poison exon", "Alters frame", "First exon", "Last exon", "A3SS", "A5SS", "IR", "MES", "MXS", "SES")
) +
  rowAnnotation(labels = anno_text(sz, which = "row", just = c("left", "centre"), gp = gpar(fontsize = 9)), 
                width = max(grobWidth(textGrob(sz))))
)

co <- column_order(ht)
cs <- comb_size(upset_combs)

decorate_annotation("Intersection\nsize", {
  grid.text(cs[co], x = seq_along(cs), y = unit(cs[co], "native") + unit(2, "pt"), 
            default.units = "native", just = c("left", "centre"), gp = gpar(fontsize = 9), rot = 90)
  
} )

dev.off()

```

## graph the no. of exons detected vs. maximum transcript length

### fetch max. transcript lengths for genes in biomart

```{r}

tibble_max_transcript_length_per_gene <- getBM(attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart) %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length	)) %>% 
  setNames(c("matched_gene_names", "maxtranscriptlength"))

```

```{r}

exons_per_gene_constitutive <- tibble_constitutive_LIV_info_first.last.reference %>% 
  dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons_constitutive = n())

exons_per_gene_differential <- wide_tibble_of_psisigma_results_allcomparisons_differential_info_LIV_first.last.reference %>% 
  dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons_differential = n())

exons_per_gene_merged <- dplyr::full_join(exons_per_gene_constitutive, exons_per_gene_differential, by = "matched_gene_names")

wide_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength <- dplyr::right_join(tibble_max_transcript_length_per_gene, exons_per_gene_merged, by = "matched_gene_names") %>% setNames(., c("Gene", "maxtranscriptlength", "no_exons_constitutive", "no_exons_differential"))

long_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength <- reshape2::melt(wide_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength, 
                                                                                    id = c("Gene", "maxtranscriptlength"), variable.name = "filteringstep",
                                                                                    value.name = "no_exons") %>% as_tibble %>% type_convert

# no. junctions detected vs. maximum annotated transcript length
ggplot(long_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength) + 
  geom_point(aes(y = no_exons, x = maxtranscriptlength)) +
  geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_exons, x = maxtranscriptlength)) +
  # annotate(geom = "text", aes(x = 2e5, y = 20, label = paste(cor(x = comparison_1_value, y = comparison_2_value, method = "pearson"))), size = 5) +
  facet_wrap(~filteringstep, scales = "free") +
  ggtitle(paste("scatterplot of the number of unique exons detected per gene against max. annotated transcipt length 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  xlab("maximum annotated transcript length") +
  ylab("number of exons detected") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no._exons_vs_max_transcript_length_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no._exons_vs_max_transcript_length_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

## Plot PCA to check for technical variation in absolute PSI values

### can use the raw table. Convert it to wide.

```{r}

long_tibble_raw_counts_PSI_for_PCA <- wide_tibble_of_psisigma_results_allcomparisons_final_with_denominator_numerator_filtered_5_in_at_least_3[, c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "comparison.1_absolute.psi_1", "comparison.1_absolute.psi_2", "comparison.1_absolute.psi_3", "comparison.2_absolute.psi_1", "comparison.2_absolute.psi_2", "comparison.2_absolute.psi_3", "comparison")]  %>% 
  # rename the comparison column
  dplyr::mutate_at(.vars = "comparison", .funs = function(x) {gsub(x = x, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_(.*)", replacement = "\\1")} )

# group split and left join
list_of_tibble_raw_counts_PSI_for_PCA_by_comparison <- long_tibble_raw_counts_PSI_for_PCA %>% dplyr::group_split(comparison)

names(list_of_tibble_raw_counts_PSI_for_PCA_by_comparison) <- list_of_tibble_raw_counts_PSI_for_PCA_by_comparison %>% purrr::map(~.x$comparison %>% unique) %>% unlist

# rename tibbles to be timepoint-specific
list_of_tibble_raw_counts_PSI_for_PCA_by_comparison <- purrr::map2(.x = list_of_tibble_raw_counts_PSI_for_PCA_by_comparison,
                                                                   .y = names(list_of_tibble_raw_counts_PSI_for_PCA_by_comparison),
                                                                   .f = ~.x %>% dplyr::select(-comparison) %>% setNames(c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", paste(.y, c("|r1", "|r2", "|r3"), sep = ""), paste("MSC", c("|r1", "|r2", "|r3"), sep = ""))) %>% na.omit %>% dplyr::distinct())

# reduce into a left join
wide_tibble_raw_counts_PSI_for_PCA <- list_of_tibble_raw_counts_PSI_for_PCA_by_comparison %>% purrr::reduce(.f = inner_join , by = c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", paste("MSC", c("|r1", "|r2", "|r3"), sep = ""))) %>% dplyr::distinct()

```

### rename columns and plot PCA

colnames should be timepoint|replicate.

```{r}

plot_PCA_for_timepoint_and_replicate(wide_tibble_raw_counts_PSI_for_PCA %>% dplyr::select(-database_ID, -event_region_coords, -diff_exon_coords, -splicemode), 
                                     timepoint_order = vector_OBseries_timepoints_edited, 
                                     replicate_order = c("r1", "r2", "r3"), 
                                     PCA_depths_y = c(1, 2, 3), 
                                     PCA_depths_x = c(2, 3, 4), 
                                     save_dir = R_processing_results_dir, 
                                     save_name = "PSISigma_raw_PSI", 
                                     graph_title = "PCA plot of PSI values, PSI-Sigma", 
                                     width = 14, 
                                     height = 12)

```

### conduct RUV normalisation and re-check the PCA clustering

```{r}

library(RUVSeq)
library(BBmisc)

 pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVs_absolute.PSI_raw.pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% as.matrix, outline = FALSE, col = factor(gsub(x = colnames(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi]), pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1")), las = 2, main = paste("RLE plot of RUVs absolute PSI (raw)"), margins = c(10, 5))
  
  dev.off() 

k.value <- 3
 
replicate_colnumbers <- tribble(~rep1, ~rep2, ~rep3,
            1,     2,     3,
            4,     5,     6,
            7,     8,     9,
            10,    11,    12,
            13,    14,    15,
            16,    17,    18,
            19,    20,    21,
            22,    23,    24) %>% as.matrix

# RUVs

nsYs <- RUVs(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit %>% as.matrix, scIdx = replicate_colnumbers, k = k.value, isLog = TRUE)
 
tibble_absolute.PSI_OBseries_RUVs <- wide_tibble_of_psisigma_result_tibbles_processed_ud.only %>% na.omit

## rescale ranges
target_min.psi <- min(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit)
target_max.psi <- max(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit)

current_min.psi <- min(nsYs$normalizedCounts)
current_max.psi <- max(nsYs$normalizedCounts)

matrix_unscaled_counts <-nsYs$normalizedCounts

matrix_rescaled_counts <- (matrix_unscaled_counts - (current_min.psi - target_min.psi))
matrix_rescaled_counts <- matrix_rescaled_counts*(target_max.psi/max(matrix_rescaled_counts))

tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi] <- matrix_rescaled_counts %>% as_tibble

max(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi])
min(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi])
  
  pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVs_absolute.PSI_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi] %>% as.matrix, outline = FALSE, col = factor(gsub(x = colnames(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi]), pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1")), las = 2, main = paste("RLE plot of RUVs absolute PSI, k =", k.value))
  
  dev.off() 
  

```

### plot PCA using only all intact values, normalised RUVs

```{r}

# PCA analysis

PCA_combined_count <- prcomp(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi])

# plot standard deviations 

PCA_stdev <- tibble(PC = 1:(PCA_combined_count[["sdev"]] %>% length), stdev = PCA_combined_count[["sdev"]])
PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)

ggplot(PCA_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on absolute PSI (RUVs)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_absolute_PSI_RUVs.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_absolute_PSI_RUVs.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings <- PCA_combined_count[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings <- add_column(PCA_loadings, timepoint = gsub(x = PCA_loadings$sample, pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1"))
PCA_loadings <- add_column(PCA_loadings, replicatenumber = gsub(x = PCA_loadings$sample, pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\2"))

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PC2 vs. PC1 loadings based on absolute PSI (RUVs)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  scale_color_manual(breaks = vector_OBseries_timepoints_edited, limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited, values = brewer.pal(8, "Spectral")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_absolute_PSI_RUVs.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_absolute_PSI_RUVs.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 15, units = "cm")

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PC3 vs. PC2 loadings based on absolute PSI (RUVs)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  scale_color_manual(breaks = vector_OBseries_timepoints_edited, limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited, values = brewer.pal(8, "Spectral")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_absolute_PSI_RUVs.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_absolute_PSI_RUVs.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 15, units = "cm")

```

# EXON ONTOLOGY

## retrieve whole biomart domain annotations from server and save

```{r}

# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

```

```{r eval=FALSE, include=FALSE}

# query biomart
# list_of_tibbles_biomart_domain_annotation <- future_map(.x = list_of_attributes_to_retrieve, .f = ~getBM(attributes = .x, mart = ensembl_mart, curl = RCurl::getCurlMultiHandle()) %>% as_tibble %>% na.omit, .progress = TRUE, .options = future_options(globals = c("getBM", "ensembl_mart")))

# write tables
# future_map2(.x = list_of_tibbles_biomart_domain_annotation, .y = names(list_of_tibbles_biomart_domain_annotation), .f = ~write.table(.x, file = paste(shared_dir, "table_biomart_ENSP_to_", .y, "_38.98.txt", sep = ""), row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t"), .progress = TRUE, .options = future_options(globals = FALSE))

```

```{r}

# read tables
list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(shared_dir, "table_biomart_ENSP_to_", .x, "_38.98.txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

```

## retrieve whole biomart ENSP to uniprotkb entry ID mapping

```{r}

tibble_ENSP_to_uniprotkb <- biomaRt::getBM(attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
  type_convert %>% 
  as_tibble %>%
  na.omit

```

## import GTF and process it into a nice table containing only character and numeric types

```{r eval=FALSE, include=FALSE}

# IMPORT GTF ANNOTATION OF TRANSCRIPT/EXON/PROTEIN CODING REGIONS ETC...

library(rtracklayer)

tibble_ref_gtf_original <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(tibble_ref_gtf_original) <- c("seqnames", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES
# tibble_PTM_combined <- dplyr::bind_rows(tibble_dbPTM_allhuman_annotations, tibble_phosphositeplus_allhuman_phosphosites)
tibble_PTM_combined <- tibble_dbPTM_allhuman_annotations

```

## Import all the non-homolog and non-superfamily entries from Interpro

```{r}

tibble_non_family_interpro_entries <- c("interpro_active.site_entries.tsv", "interpro_binding.site_entries.tsv", "interpro_conserved.site_entries.tsv", "interpro_domain_entries.tsv", "interpro_PTM_entries.tsv", "interpro_repeat_entries.tsv") %>% 
  purrr::map(.f = ~read.delim(paste(shared_dir, .x, sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble) %>% rbindlist %>% as_tibble

```

## transcript and domain analyses! :)

NEW METHOD - USING ONLY EXONS MATCHED TO THE REFERENCE GTF

now, PSI-sigma considers long and short forms of A3SS/A5SS exons to be distinct.

We just consider differential regions to be any differential exon.

```{r message=FALSE, warning=FALSE}

query_name <- "all_differential"

plan(multiprocess)
options(mc.cores = 16)

intron_retention_string <- "IR"

# identifier table
tibble_alternative_exons_identifier <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::select(event_region_coords, diff_exon_coords, splicemode, matched_gene_names) %>% setNames(c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")) %>% unique
# chr start end strand table
vector_event_region_chr <- gsub(x = tibble_alternative_exons_identifier$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\1")
vector_event_region_start <- purrr::map2(.x = gsub(x = tibble_alternative_exons_identifier$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert,
                                .y = gsub(x = tibble_alternative_exons_identifier$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert,
                                .f = ~min(.x, .y)) %>% unlist
vector_event_region_end <- purrr::map2(.x = gsub(x = tibble_alternative_exons_identifier$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert,
                              .y = gsub(x = tibble_alternative_exons_identifier$event_region_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert,
                              .f = ~max(.x, .y)) %>% unlist

vector_diff_exon_start <- purrr::map2(.x = gsub(x = tibble_alternative_exons_identifier$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert,
                                             .y = gsub(x = tibble_alternative_exons_identifier$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert,
                                             .f = ~min(.x, .y)) %>% unlist
vector_diff_exon_end <- purrr::map2(.x = gsub(x = tibble_alternative_exons_identifier$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2") %>% type.convert,
                                           .y = gsub(x = tibble_alternative_exons_identifier$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3") %>% type.convert,
                                           .f = ~max(.x, .y)) %>% unlist

tibble_alternative_exons_chr_start_end_strand <- tibble(
  "event_region_coords" = tibble_alternative_exons_identifier$event_region_coords,
  "diff_exon_coords" = tibble_alternative_exons_identifier$diff_exon_coords,
  "splicemode" = tibble_alternative_exons_identifier$splicemode,
  "matched_gene_names" = tibble_alternative_exons_identifier$matched_gene_names,
  "chr" = vector_event_region_chr,
  "strand" = "*",
  "event_region_start" = vector_event_region_start,
  "event_region_end" = vector_event_region_end,
  "diff_exon_start" = vector_diff_exon_start,
  "diff_exon_end" = vector_diff_exon_end)

# subset the recon GTF and exon table by chromosomes in common so that we can map2 over them
## split exon table by chromosome
list_alternative_exons_by_chr <- tibble_alternative_exons_chr_start_end_strand %>% 
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
## split GTF table by chromosome
list_ref_gtf_subset_by_chr <- tibble_ref_gtf_original %>% 
  dplyr::group_split(seqnames) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$seqnames %>% unique) %>% unlist)
## get and filter for only chromosomes in common
vector_chr_in_commmon <- intersect(names(list_ref_gtf_subset_by_chr), names(list_alternative_exons_by_chr))

list_alternative_exons_by_chr <- list_alternative_exons_by_chr[vector_chr_in_commmon]
list_ref_gtf_subset_by_chr <- list_ref_gtf_subset_by_chr[vector_chr_in_commmon]

cat("match VSRs to reference transcriptome\n")
list_ref_entries_matched_to_exons <- future_map2(
  .x = list_alternative_exons_by_chr,
  .y = list_ref_gtf_subset_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_alternative_exons_by_chr[[1]]
    # a2 <- list_ref_gtf_subset_by_chr[[1]]
    ##########
    
    # message(a1$chr %>% unique)
    
    list_per_chromosome <- future_imap(
      .x = a1 %>% array_tree,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[18]]
        ###########
        
        # message(b2)
        
        # detect exon extension/skipping
        ## get vector of VSR and exon coords
        vector_VSR_exon_coords <- b1[c("event_region_start", "event_region_end", "diff_exon_start", "diff_exon_end")] %>% unlist %>% type.convert
        ## if no. of unique VSR + alt. exon coords = 4, then it's exon skipping. If 3, then partial exon extension.
        # IR EVENTS
        if (grepl(x = b1$splicemode, pattern = intron_retention_string) == TRUE) {
          
          # VSR MATCHING
          # match transcripts to the IR region
          list_matched_GTF_exon_entries <- extract_overlapping.exons(query_chr = b1$chr, query_start = b1$event_region_start %>% type.convert, query_end = b1$event_region_end %>% type.convert, query_strand = b1$strand, tibble_gtf_table = a2, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon") %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          # get parent transcript entries
          list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~a2[which(a2$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          
          # INEXACT MATCHING IF VSR MATCHING FAILS
          if (list_matched_GTF_exon_entries %>% length == 0) {
            list_GTF_entries_matched_to_IR_junction <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = b1$diff_exon_start %>% type.convert, query_end = b1$diff_exon_end %>% type.convert, query_strand = b1$strand, tibble_gtf_table = a2, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon")
            # extract overlapping, same strand, (and maybe) same gene_name/gene_id transcripts.
            tibble_IR_junction_parent_transcript_entries <- a2[which(a2$transcript_id %in% names(list_GTF_entries_matched_to_IR_junction) &
                                                               a2$type == "transcript"), ]
            # get overlapping/samestrand/same gene_id transcript entries
            ## determine if it's called "gene_name" or "gene_id"
            tibble_gene_name <- a2 %>% head %>% dplyr::select(contains("gene_id"), contains("gene_name"))
            gene_name_or_gene_id <- colnames(tibble_gene_name[, 1])
            
            if (a2 %>% dplyr::select(contains("gene_id"), contains("gene_name")) %>% ncol != 0) {
              tibble_transcript_entries_overlapping_IR_junction_transcripts <- 
                a2[which(a2$type == "transcript" &
                     a2$start <= (tibble_IR_junction_parent_transcript_entries$end %>% max) &
                     a2$end >= (tibble_IR_junction_parent_transcript_entries$start %>% min) & 
                     a2$strand %in% (tibble_IR_junction_parent_transcript_entries$strand %>% unique) &
                     (a2[, gene_name_or_gene_id] %>% unlist) %in% (tibble_IR_junction_parent_transcript_entries[, gene_name_or_gene_id] %>% unlist)), ]
            } else if (a2 %>% dplyr::select(contains("gene_id"), contains("gene_name")) %>% ncol == 0) {
              tibble_transcript_entries_overlapping_IR_junction_transcripts <- 
                a2[which(a2$type == "transcript" &
                     a2$start <= (tibble_IR_junction_parent_transcript_entries$end %>% max) &
                     a2$end >= (tibble_IR_junction_parent_transcript_entries$start %>% min) & 
                     a2$strand %in% (tibble_IR_junction_parent_transcript_entries$strand %>% unique)), ]
            }
            
            # retrieve the full entries of overlapping transcripts
            tibble_all_candidate_overlapping_full_entries <- a2[which(a2$transcript_id %in% tibble_transcript_entries_overlapping_IR_junction_transcripts$transcript_id), ]
            
            # extract only transcripts with encapsulating exons. These are the final exon matches.
            list_matched_GTF_exon_entries <- 
              tibble_all_candidate_overlapping_full_entries[tibble_all_candidate_overlapping_full_entries$type == "exon" &
                                                         tibble_all_candidate_overlapping_full_entries$start <= b1$diff_exon_start %>% type.convert &
                                                         tibble_all_candidate_overlapping_full_entries$end >= b1$diff_exon_end %>% type.convert, ] %>% 
              dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            # get parent transcript entries
            list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~tibble_all_candidate_overlapping_full_entries[which(tibble_all_candidate_overlapping_full_entries$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          }
          
          ### EXON SKIPPING
        } else if (vector_VSR_exon_coords %>% unique %>% length == 4) {
          
          # exact exon match
          list_matched_GTF_exon_entries <- extract_overlapping.exons(query_chr = b1$chr, query_start = b1$diff_exon_start %>% type.convert, query_end = b1$diff_exon_end %>% type.convert, query_strand = b1$strand, tibble_gtf_table = a2, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon") %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          # get parent transcript entries
          list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~a2[which(a2$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          
          ### PARTIAL EXON EXTENSIONS
        } else if (vector_VSR_exon_coords %>% unique %>% length == 3) {
          
          # ENHANCED EXON EXTENSION MATCHING
          # Strategy: 
          # 1. Determine the common VSR and exon coord.
          # 2. Calculate the genomic coord of the DR + 1 nucleotide.
          # This is done using the equation: genome_coord_first_nucleotide_extending_into_common_region = common + (common_coord-VSR_only_coord)/(abs(common_coord-VSR_only_coord))
          # 3. Find the CONSTITUTIVE (native, non-extended) exon by requiring no overlap with the DR but has either the start or end coord = the DR + 1 nucleotide.
          # 4. The exonic matches are any exon which overlaps the region of the constitutive span AND contains the WHOLE DR on the same strand.
          common_coord <- intersect(c(b1$event_region_start %>% type.convert, b1$event_region_end %>% type.convert), 
                                    c(b1$diff_exon_start %>% type.convert, b1$diff_exon_end %>% type.convert))
          event_region_only_coord <- setdiff(c(b1$event_region_start %>% type.convert, b1$event_region_end %>% type.convert), common_coord)
          exon_only_coord <- setdiff(c(b1$diff_exon_start %>% type.convert, b1$diff_exon_end %>% type.convert), common_coord)
          genome_coord_first_nucleotide_extending_into_common_region = common_coord + ((common_coord - event_region_only_coord)/(abs(common_coord - event_region_only_coord)))
          
          tibble_GTF_exons_with_DR_plus_one_nucleotide <- 
            a2[(which(a2$type == "exon" &
                        (a2$start == genome_coord_first_nucleotide_extending_into_common_region |
                           a2$end == genome_coord_first_nucleotide_extending_into_common_region))), ]
          # require no overlap with DR
          tibble_constitutive_exons <- 
            tibble_GTF_exons_with_DR_plus_one_nucleotide[!(tibble_GTF_exons_with_DR_plus_one_nucleotide$start <= max(common_coord, exon_only_coord) &
                                                             tibble_GTF_exons_with_DR_plus_one_nucleotide$end >= min(common_coord, exon_only_coord)), ]
          
          # find exons overlapping with the constitutive and containing the whole DR regions.
          list_matched_GTF_exon_entries <- 
            a2[which(a2$type == "exon" &
                       a2$strand %in% (tibble_constitutive_exons$strand %>% unique) &
                       # constitutive region overlap
                       a2$start <= max(tibble_constitutive_exons$start %>% max, tibble_constitutive_exons$end %>% max) &
                       a2$end >= min(tibble_constitutive_exons$start %>% min, tibble_constitutive_exons$end %>% min) &
                       # DR encapsulation
                       a2$start <= min(common_coord, exon_only_coord) &
                       a2$end >= max(common_coord, exon_only_coord)), ] %>%
            dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          
          # get parent transcript entries
          list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~a2[which(a2$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          
        } # END CONDITIONS ###
        
        # rbind and tibblise the list_matched_GTF_exon_entries
        ref_matched_exons <- list_matched_GTF_exon_entries %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble
        
        # extract the matched transcript_ids
        vector_matched_transcript_ids <- ref_matched_exons$transcript_id %>% unique
        
        # GET STRAND ###
        list_matched_strand <- list_parent_GTF_transcript_entries %>% purrr::map(~.x$strand %>% unique)
        
        return(purrr::splice(
          b1,
          "ref_matched_exons" = ref_matched_exons %>% list,
          "vector_matched_transcript_ids" = vector_matched_transcript_ids %>% list,
          "list_parent_GTF_transcript_entries" = list_parent_GTF_transcript_entries %>% list,
          "matched_strand" = list_matched_strand %>% unlist %>% unique
        ))
        
      }, .progress = TRUE)
    
    # keep elements that didn't have any matches to GTF
    list_per_chromosome_unmatched <- list_per_chromosome %>% purrr::keep(.p = ~.x$ref_matched_exons %>% nrow == 0)
    # prune elements that didn't have any matches to GTF
    list_per_chromosome_pruned <- list_per_chromosome %>% purrr::discard(.p = ~.x$ref_matched_exons %>% nrow == 0)
    
    return(list("unmatched_list" = list_per_chromosome_unmatched,
                "pruned_list" = list_per_chromosome_pruned))
    
  }, .progress = TRUE)

# write the entries that didn't have any matches to the reference GTF.
tibble_ref_entries_matched_to_exons_unmatched <- list_ref_entries_matched_to_exons %>% purrr::map(~.x$unmatched_list) %>% flatten %>% purrr::map(~.x[c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names", "chr", "strand", "event_region_start", "event_region_end", "diff_exon_start", "diff_exon_end")] %>% as_tibble) %>% rbindlist %>% as_tibble
# write
write.table(x = tibble_ref_entries_matched_to_exons_unmatched, file = paste(R_processing_results_dir, "table_exon_ontology_unmatched_exons_", query_name, ".txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# extract the pruned entries and flatten
list_ref_entries_matched_to_exons_pruned <- list_ref_entries_matched_to_exons %>% purrr::map(~.x$pruned_list) %>% flatten

plan(multiprocess)
options(mc.cores = 8)

# add the matched CDS from the exon number and transcript ids of matched exons
list_ref_entries_matched_to_exons.and.CDS <- list_ref_entries_matched_to_exons_pruned %>% future_map(
  .f = ~purrr::splice(.x,
                      "ref_matched_CDS" = dplyr::semi_join(tibble_ref_gtf_original[tibble_ref_gtf_original$type == "CDS", ], .x$ref_matched_exons %>% .[, c("transcript_id", "exon_number")], by = c("transcript_id", "exon_number"))
  ), 
  .progress = TRUE, 
  .options = future_options(globals = c("tibble_ref_gtf_original")))


# GENERATE GENOME-RELATIVE COORDS FOR EVERY DIFFERENTIAL POSITION.
# also generate genome-relative coords for every CDS position of transcripts with a matched exon. this is necessary because we need to deal with gaps.
list_genome_relative_exonic.and.CDS_coords <- future_imap(.x = list_ref_entries_matched_to_exons.and.CDS, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- list_ref_entries_matched_to_exons.and.CDS[[9]]
  ###########
  
  # cat("\nprocessing entry number: ", a2)
  
    # retrieve the genomic coords of the differential exonic region (just start:end)
    vector_genomic_coords_of_all_differential_exon_positions <- (a1$diff_exon_start %>% type.convert):(a1$diff_exon_end %>% type.convert)
    
    # find the overlapping features from the parent transcripts (from the matched exons)
    ## get parent transcript entries
    tibble_parent_transcript_entries <- dplyr::semi_join(tibble_ref_gtf_original, a1$ref_matched_exons, by = "transcript_id")
    ## find overlapping features
    tibble_overlapping_parent_transcript_features <- tibble_parent_transcript_entries[which(tibble_parent_transcript_entries$start <= a1$diff_exon_end %>% type.convert & tibble_parent_transcript_entries$end >= a1$diff_exon_start %>% type.convert), ]
    
    # retrieve the genomic coords of the differential CDS region
    ## we have to intersect each (genome-relative) CDS region with the genomic coords of differential exon positions
    ## list-ify the matched CDS entries by transcript_id
    list_matched_CDS_by_transcript_id <- a1$ref_matched_CDS %>% 
      dplyr::group_split(transcript_id) %>% 
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
    ## list out all the positions for each CDS entry and intersect with the differential exon's positions
    list_all_genome_relative_matched_CDS_positions <- purrr::map(
      .x = list_matched_CDS_by_transcript_id,
      .f = ~purrr::map2(.x = .x$start, .y = .x$end, .f = ~.x:.y) %>% unlist)
    ## intersect for differential CDS positions
    list_differential_CDS_positions <- purrr::map(.x = list_all_genome_relative_matched_CDS_positions, .f = ~intersect(.x, vector_genomic_coords_of_all_differential_exon_positions))
  
  return(splice(
    a1,
    "vector_genomic_coords_of_all_differential_exon_positions" = vector_genomic_coords_of_all_differential_exon_positions %>% list,
    "tibble_overlapping_parent_transcript_features" = tibble_overlapping_parent_transcript_features %>% list,
    "list_differential_CDS_positions" = list_differential_CDS_positions %>% list
  ))
    
    }, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf_original", "as_tibble", "tibble::enframe")) ) %>%
    
    # drop exons that don't have any differential regions.
    purrr::discard(.x = ., .p = ~(nrow(.x$ref_matched_exons) == 0))

# CALCULATE THE PROTEIN-RELATIVE COORDS FROM GENOME-RELATIVE DIFFERENTIAL CDS POSITIONS
list_protein_relative_differential_coords <- future_imap(.x = list_genome_relative_exonic.and.CDS_coords, .f = function(a1, a2) {
  
  # message("now processing junction number: ", .y)
  
  # DEBUG ###
  # a1 <- list_genome_relative_exonic.and.CDS_coords[[5]]
  ###########
  
  # get current strand - this is necessary for getting CDS-relative coords.
  current_strand <- a1$ref_matched_exons$strand %>% unique
    
  # retrieve all the genome-relative positions of the parent CDS
  # NOTE: CDS might not always be available. we account for this.
  if (a1$ref_matched_CDS %>% nrow != 0) {
    
    list_vector_genome_relative_coords_parent_CDS <- purrr::map(
    .x = a1$ref_matched_CDS$transcript_id,
    .f = function(b1) {
      
      # DEBUG ###
      # b1 <- a1$ref_matched_CDS$transcript_id %>% .[[1]]
      ###########
      
      tibble_ref_gtf_matching_transcript_id <- tibble_ref_gtf_original[tibble_ref_gtf_original$transcript_id == b1 & tibble_ref_gtf_original$type == "CDS", ]
      # create genome-relative positions
      vector_genome_relative_positions <- purrr::map2(.x = tibble_ref_gtf_matching_transcript_id$start,
                                                      .y = tibble_ref_gtf_matching_transcript_id$end,
                                                      .f = ~.x:.y) %>% unlist %>% unique %>% sort(decreasing = FALSE)
      return(vector_genome_relative_positions)
    } ) %>% set_names(a1$ref_matched_CDS$transcript_id)
    
    # get protein_id for later on
    vector_protein_ids <- a1$ref_matched_CDS$transcript_id %>% purrr::map(.f = ~a1$ref_matched_CDS %>% dplyr::filter(transcript_id == .x) %>% .$protein_id) %>% unlist
    
    # rename the list_differential_CDS_positions to be the same order as the list_vector_CDS_relative_coords
    a1$list_differential_CDS_positions <- a1$list_differential_CDS_positions[list_vector_genome_relative_coords_parent_CDS %>% names]
    
    # calculate CDS-relative diff CDS coords
    list_vector_CDS_relative_coords <- purrr::map2(.x = a1$list_differential_CDS_positions,
                                                   .y = list_vector_genome_relative_coords_parent_CDS,
                                                   .f = function(b1, b2) {
                                                     
                                                     if (current_strand == "+") {
                                                      which(b2 %in% b1) %>% return 
                                                     } else if (current_strand == "-") {
                                                      which((b2 %>% rev) %in% b1) %>% return 
                                                     }
                                                     
                                                   } ) %>% 
      # set protein_id as names
      set_names(vector_protein_ids)
    
    # name list_differential_CDS_positions to have protein ids as well
    names(a1$list_differential_CDS_positions) <- vector_protein_ids
    
    # finally get the protein-relative coords.
    # protein-relative coords are simply the ceiling of a third of the transcript-relative coords
    protein_relative_differential_coords <- purrr::map(.x = list_vector_CDS_relative_coords,
                                                       .f = ~ceiling(.x / 3) %>% unlist %>% unique)
    
  } else {
    
    protein_relative_differential_coords <- NULL
    
  }
  
  return(splice(
    a1,
    "protein_relative_differential_coords" = protein_relative_differential_coords %>% list
  ))
  
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf_original")))

# MATCH THE DIFFERENTIAL TRANSCRIPT-RELATIVE COORDS TO THE ENSEMBL GTF
# MATCH THE DIFFERENTIAL PROTEIN-RELATIVE COORDS TO THE FETCHED BIOMART LIST AS WELL AS THE PTMS
list_matched_annotation <- future_map(.x = list_protein_relative_differential_coords, .f = function(a1) {
  
  # WARNING!! FIX THIS WHEN NAMING THE FUNCTION!
  # list_of_tibbles_biomart_domain_annotation <<- list_of_tibbles_biomart_domain_annotation
  
  # tibble_ENSP_to_uniprotkb <<- tibble_ENSP_to_uniprotkb
  # tibble_PTM_combined <<- tibble_PTM_combined
  # tibble_ref_gtf_original <<- tibble_ref_gtf_original
  ############################################
  
  # DEBUG ###
  # a1 <- list_protein_relative_differential_coords[[1]]
  ###########
  
  list_biomart_annotations <- purrr::map2(
    .x = a1$protein_relative_differential_coords, 
    .y = names(a1$protein_relative_differential_coords), .f = function(b1, b2) {
      
      # DEBUG ###
      # b1 <- a1$protein_relative_differential_coords %>% .[[1]]
      # b2 <- names(a1$protein_relative_differential_coords) %>% .[1]
      ###########
      
      CDS.relative.coords <- b1
      protein.id <- b2
      
      # find domains which overlapped with the differential positions at the protein-relative level
      list_matched_biomart_annotations <- purrr::map2(.x = list_of_tibbles_biomart_domain_annotation, 
                                                      .y = names(list_of_tibbles_biomart_domain_annotation),
                                                      .f = function(c1, c2) {
                                                        
                                                        # DEBUG ###
                                                        # c1 <- list_of_tibbles_biomart_domain_annotation[[1]]
                                                        ###########
                                                        
                                                        tibble_domain_subset <- c1[c1$ensembl_peptide_id == protein.id, ]
                                                        
                                                        if (nrow(tibble_domain_subset) != 0) {
                                                          
                                                          # test matched_domain_entriesfor which differential positions lie between a domain
                                                          
                                                          row.indices_of_overlaps_with_differential_positions <- which(purrr::map2(
                                                            .x = tibble_domain_subset$start, 
                                                            .y = tibble_domain_subset$end, 
                                                            .f = ~any(.x < CDS.relative.coords &
                                                                        .y > CDS.relative.coords)) %>% unlist)
                                                          
                                                          # extract matched GTF entries
                                                          tibble_matched_domain_entries <- tibble_domain_subset[row.indices_of_overlaps_with_differential_positions, ]
                                                          
                                                        } else if (nrow(tibble_domain_subset) == 0) {
                                                          
                                                          tibble_matched_domain_entries <- tibble_domain_subset
                                                          
                                                        }
                                                        
                                                        # calculate the degree of overlap
                                                        tibble_matched_domain_entries <- tibble_matched_domain_entries %>% dplyr::mutate("percentage_overlap" = purrr::map2(.x = tibble_matched_domain_entries$start, .y = tibble_matched_domain_entries$end, .f = function(a1, a2) {(intersect(a1:a2, CDS.relative.coords) %>% length)/((a1:a2) %>% length)} ) %>% unlist)
                                                        
                                                        # rename the columns back to being domain-type specific
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "start", replacement = paste(c2, "_", "start", sep = ""))
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "end", replacement = paste(c2, "_", "end", sep = ""))
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "percentage_overlap", replacement = paste(c2, "_", "percentage_overlap", sep = ""))
                                                        
                                                        return(tibble_matched_domain_entries)
                                                        
                                                      } )
      
      # reduce into tibble by full join
      tibble_matched_biomart_annotations <- list_matched_biomart_annotations %>% purrr::reduce(dplyr::full_join)
      
      return(tibble_matched_biomart_annotations)
      
    } )
  
  list_PTM_annotations <- purrr::map2(
    .x = a1$protein_relative_differential_coords, 
    .y = names(a1$protein_relative_differential_coords), .f = function(b1, b2) {
      
      # DEBUG ###
      # .x <- input_list$CDS_relative_differential_coords %>% .[[6]]
      # .y <- names(input_list$CDS_relative_differential_coords) %>% .[6]
      ###########
      
      tibble_uniprotkb_entries_from_ENSP <- tibble_ENSP_to_uniprotkb[tibble_ENSP_to_uniprotkb$ensembl_peptide_id == b2, ]
      
      tibble_combined_PTM_matching_entries <- tibble_uniprotkb_entries_from_ENSP %>% dplyr::left_join(., tibble_PTM_combined, by = "uniprotkb_entry") %>%
        
        .[.$modified_residue_position %in% b1, ]
      
      return(tibble_combined_PTM_matching_entries)
      
    } )
  
  return(purrr::splice(
    a1,
    "biomart_annotations" = list_biomart_annotations %>% rbindlist(fill = TRUE) %>% as_tibble %>% list,
    "PTMs" = list_PTM_annotations %>% rbindlist(fill = TRUE) %>% as_tibble %>% list
  ))
  
}, .progress = TRUE, .options = future_options(globals = c("rbindlist", "list_of_tibbles_biomart_domain_annotation", "tibble_ENSP_to_uniprotkb", "tibble_PTM_combined", "tibble_ref_gtf_original", "as_tibble")))

# save the raw list
save(list_matched_annotation, file = paste(R_processing_results_dir, "list_matched_annotation.Rlist", sep = ""))

# TIDY AND WRAP UP ALL THE ANNOTATIONS.
# prepare for export
list_tidied_annotation <- list_matched_annotation %>% 
  future_map(.f = ~
               # concatenate all bare vectors 
               modify_at(.x, .at = "vector_genomic_coords_of_all_differential_exon_positions", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = "vector_matched_transcript_ids", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = c("list_differential_CDS_positions", "protein_relative_differential_coords"), .f = ~purrr::map(.x = .x, .f = ~.x %>% paste(collapse = ","))) %>%
               # extract just the type and transcript_biotype from the overlapping parent transcript features
               modify_at(.x, .at = "tibble_overlapping_parent_transcript_features", .f = ~.x[, c("type", "transcript_biotype")] %>% unlist %>% unique %>% sort %>% paste(collapse = ",")), .progress = TRUE, .options = future_options(globals = c("rbindlist", "as_tibble")))

# extract the transcript features and tibblise 
tibble_final_transcript_feature_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("event_region_coords", "diff_exon_coords", "matched_strand", "splicemode", "vector_matched_transcript_ids", "tibble_overlapping_parent_transcript_features")] %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble %>%
  setNames(c("event_region_coords", "diff_exon_coords", "matched_strand", "splicemode", "vector_matched_transcript_ids", "tibble_overlapping_parent_transcript_features")) %>% 
  ## add in gene symbols
  dplyr::right_join(tibble_ref_matching_exon_entries_all[, c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")] %>% na.omit %>% unique, ., by = c("event_region_coords", "diff_exon_coords", "splicemode"))
# write table
write.table(x = tibble_final_transcript_feature_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_transcript_features_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# extract the biomart results and tibblise 
tibble_final_biomart_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("event_region_coords", "diff_exon_coords", "matched_strand", "splicemode", "biomart_annotations")] ) %>%
  purrr::discard(.p = ~.x$biomart_annotations %>% nrow == 0) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "biomart_annotations", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble) %>%
  rbindlist(fill = TRUE) %>% 
  type_convert %>%
  as_tibble %>% 
  ## add in gene symbols
  dplyr::right_join(tibble_ref_matching_exon_entries_all[, c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")] %>% na.omit %>% unique, ., by = c("event_region_coords", "diff_exon_coords", "splicemode"))
# write table
write.table(x = tibble_final_biomart_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_biomart_domains_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# extract the PTM results and tibblise 
tibble_final_PTM_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("event_region_coords", "diff_exon_coords", "matched_strand", "splicemode", "PTMs")] ) %>%
  purrr::discard(.p = ~.x$PTMs %>% nrow == 0) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "PTMs", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble %>% 
  ## add in gene symbols
  dplyr::right_join(tibble_ref_matching_exon_entries_all[, c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")] %>% na.omit %>% unique, ., by = c("event_region_coords", "diff_exon_coords", "splicemode"))
# write table
write.table(x = tibble_final_PTM_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_PTMs_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# extract the other supporting information and tibblise
tibble_final_annotation_supp <- list_tidied_annotation %>% 
  purrr::map(~.x[c("event_region_coords", "diff_exon_coords", "matched_strand", "splicemode", "vector_genomic_coords_of_all_differential_exon_positions", "list_differential_CDS_positions", "vector_matched_transcript_ids", "protein_relative_differential_coords")]) %>%
  purrr::map_if(.p = ~.x$protein_relative_differential_coords %>% length != 0, .f = ~.x %>% (function(x) {
    purrr::splice(x, 
                  "tibble" = x[c("protein_relative_differential_coords", "list_differential_CDS_positions")] %>% purrr::map_depth(.depth = 2, .f = ~paste(.x, collapse = ",")) %>% purrr::map2(.x = ., .y = names(.), .f = ~.x %>% as_tibble %>% t %>% as_tibble(rownames = "ensembl_peptide_id") %>% setNames(c("ensembl_peptide_id", .y))) %>% purrr::reduce(dplyr::full_join, by = "ensembl_peptide_id")) %>% return}) ) %>%
  purrr::map_if(.p = ~.x$protein_relative_differential_coords %>% length == 0, .f = ~purrr::modify_at(.x = .x, .at = "protein_relative_differential_coords", .f = function(.x) {return("NA")} ) %>% splice("ensembl_peptide_id" = "NA")) %>%
  purrr::map(.f = ~.x[-which(names(.x) %in% c("protein_relative_differential_coords", "list_differential_CDS_positions"))]) %>%
  purrr::map(~.x %>% flatten %>% as_tibble) %>%
  purrr::discard(.p = ~.x %>% nrow == 0) %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble %>% 
  ## add in gene symbols
  dplyr::right_join(tibble_ref_matching_exon_entries_all[, c("event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names")] %>% na.omit %>% unique, ., by = c("event_region_coords", "diff_exon_coords", "splicemode"))
# write table
write.table(x = tibble_final_annotation_supp, file = paste(R_processing_results_dir, "table_exon_ontology_supporting_info_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

## stats summary of exon ontology

```{r}

# transcript-level ###
message("total number of unique differential exons with any sort of transcript-level annotation: ", tibble_final_transcript_feature_annotation$diff_exon_coords %>% length)

message("percent of differential regions matched to protein coding transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "protein_coding") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to an lncRNA transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "lncRNA") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a miRNA transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "miRNA") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))


message("percent of differential regions overlapping a start codon: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "start_codon") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions overlapping a stop codon: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "stop_codon") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a 3' UTR region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "three_prime_utr") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a 5' UTR region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "five_prime_utr") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a CDS region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$tibble_overlapping_parent_transcript_features, pattern = "CDS") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))

# PROTEIN-LEVEL ###
# vector_unique_interpro_ids <- intersect(tibble_final_biomart_annotation$interpro %>% na.omit %>% unique, tibble_non_family_interpro_entries$Accession)

tibble_protein_level_summary_count <- tibble_final_biomart_annotation %>% dplyr::group_by(diff_exon_coords) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per diff_exon_coords
tibble_interpro_id_tally_per_diff.exon <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% .[order(.$tally), ] %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_final_biomart_annotation %>% dplyr::group_by(interpro) %>% dplyr::summarise("genes" = paste(matched_gene_names %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched AS_event_ID mapping
tibble_interpro_ID_to_matched_diff_exon_coords_mapping <- tibble_final_biomart_annotation %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("diff_exon_coords" = paste(diff_exon_coords %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "diff_exon_coords"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble join
tibble_interpro_id_tally_per_diff.exon <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_diff.exon, by = "interpro_id")
tibble_interpro_id_tally_per_diff.exon <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_diff.exon, by = "interpro_id")
tibble_interpro_id_tally_per_diff.exon <- dplyr::right_join(tibble_interpro_ID_to_matched_diff_exon_coords_mapping, tibble_interpro_id_tally_per_diff.exon, by = "interpro_id")
# plot
ggplot(tibble_interpro_id_tally_per_diff.exon %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of differential exons", dpsi_cutoff, "and any sig", pvalue_or_FDR, pvalue_cutoff, "encompassing", nrow(tibble_protein_level_summary_count), "exons")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) + ggsave(filename = paste(R_processing_results_dir, "tally_overlapping_interpro_domains_differential_exons_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "tally_overlapping_interpro_domains_differential_exons_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_diff.exon %>% dplyr::arrange(desc(tally)), file = paste(R_processing_results_dir, "tally_overlapping_interpro_domains_differential_exons_", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique exons with any sort of protein-level annotation: ", tibble_final_biomart_annotation$diff_exon_coords %>% unique %>% length, " (", tibble_final_biomart_annotation$diff_exon_coords %>% unique %>% length *100/nrow(tibble_final_transcript_feature_annotation), "% of those which have any transcript annotation)")

message("total percent of unique exons overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique exons matching a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons matching a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons matching a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons matching a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons matching a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

```

### count PTM overlap numbers

```{r}

tibble_PTM_tally <- tibble_final_PTM_annotation %>% dplyr::distinct(diff_exon_coords, splicemode, modified_residue_position, PTM_type) %>% na.omit %>% dplyr::group_by(PTM_type) %>% dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_tally, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nPSI-Sigma")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_tally$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "tally_overlapping_PTMs_differential_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "tally_overlapping_PTMs_differential_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

write.table(x = tibble_PTM_tally, file = paste(R_processing_results_dir, "tally_overlapping_PTMs_differential_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```