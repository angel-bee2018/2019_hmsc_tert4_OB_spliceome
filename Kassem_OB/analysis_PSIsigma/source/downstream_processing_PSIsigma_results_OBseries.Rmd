---
title: "Downstream processing of PSI-Sigma analysis results (OBseries)"
author: "Angel Liang"
date: "02/03/2020"
output: html_document
---

# A note on table processing:

## The tables are sequentially filtered at each step in order to gather useful information. The scheme is as follows:

ALL TABLES (RAW) ----> Wide table of absolute PSI (no NA at all) (n = 3) ----> PCA
|
Filter out unreliable timepoints with less than 2 observations (n >= 2)
|
v
Long table of all comparisons (has NA/timepoint, replicate) ----> Differential exons (with na)
|
v
Wide table of absolute PSI with any na (using ud) - (separate/sum) -----> Exon switching
|
v
Wide table of absolute PSI (complete timepoints) - (separate/sum) -----> SOM


# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)
library(data.table)

library(genefilter)

library(future.apply)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)

library(rtracklayer)
library(qualV)

library(ggplot2)
library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
# library(svglite)
# library(scales)
library(ComplexHeatmap)

library(biomaRt)
ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", mirror = "asia")
# , version = 98

library(systemPipeR)
# library(GOstats)
library(PFAM.db)
# library(bc3net)
# 
# library(ggdendro)
# library(Rfast)

# shared_dir <- "/media/Ubuntu/sharedfolder/"
shared_dir <- "Z:/"

psisigma_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/"
# psisigma_results_dir <- "/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/"

R_processing_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/"
# R_processing_results_dir <- "/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/"

if(! dir.exists(R_processing_results_dir) ) {
  dir.create(R_processing_results_dir, recursive = TRUE)}

# R_processing_results_figures_dir <- paste(R_processing_results_dir, "figures/", sep = "")
# 
# if(! dir.exists(R_processing_results_figures_dir) ) {
#      dir.create(R_processing_results_figures_dir, recursive = TRUE)}

vector_OBseries_timepoints <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

vector_of_comparisons_final <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/list_of_timepoint_comparisons_final.txt", sep = "\t", header = FALSE, stringsAsFactors = FALSE) %>% unlist
# vector_of_comparisons_final <- read.delim("/media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/list_of_timepoint_comparisons_final.txt", sep = "\t", header = FALSE, stringsAsFactors = FALSE) %>% unlist

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

```

## define functions

Enrichment/Gene Ontology

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch != 0, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes != 0, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

```

```{r}

# FUNCTION to extract the information from matched GTF entries.
# input: a list containing ref + recon GTF entries, a single element of a list of all the matches for each exon.
# things to annotate: gene name, strand, all exons are NMD in the reference GTF, first/last/only exon in reference or recon. GTF

annotate_differential_exon <- function(list_matched_ref_recon_gtf) {
  
  # DEBUG ######
  
  # list_matched_ref_recon_gtf <- list_ref_matching_exon_entries[[2]]
  
  ##############
  
  # gene name
  matched_gene_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    matched_gene_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$gene_name %>% unique, collapse = ",")
    
  }
  
  # transcript name (ref)
  matched_ref_transcript_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    matched_ref_transcript_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$transcript_id %>% unique, collapse = ",")
    
  }
  
  # transcript name (recon)
  matched_recon_transcript_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    matched_recon_transcript_names <- paste(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$transcript_id %>% unique, collapse = ",")
    
  }
  
  # strand - match the ref GTF first before going to the recon. GTF
  matched_strand <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    if (length(list_matched_ref_recon_gtf[["reference_gtf_match"]]$strand %>% unique) == 1) {
      
      matched_strand <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$strand %>% unique)
      
    }
    
  } else if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    if (length(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$strand %>% unique) == 1) {
      
      matched_strand <- paste(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$strand %>% unique)
      
    }
    
  }
  
  # NMD - reference
  NMD_reference <- FALSE
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    if (all(list_matched_ref_recon_gtf[["reference_gtf_match"]]$transcript_biotype == "nonsense_mediated_decay")) {
      
      NMD_reference <- TRUE 
      
    }
    
  }
  
  # NMD - recon
  NMD_recon <- FALSE
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    if (all(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$NMD_candidate == TRUE)) {
      
      NMD_recon <- TRUE 
      
    }
    
  } 
  
  # first/last/only exon - reference and recon
  first_or_last_exon_reference <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    first_or_last_exon_reference_temp <- list_matched_ref_recon_gtf[["reference_gtf_match"]]$first_or_last_exon %>% unique 
    
    if (all(is.na(first_or_last_exon_reference_temp)) != TRUE) {
      
      first_or_last_exon_reference <- first_or_last_exon_reference_temp %>% na.omit %>% paste(collapse = ",")
      
    }
    
  }
  
  first_or_last_exon_recon <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    first_or_last_exon_recon_temp <- list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$first_or_last_exon %>% unique 
    
    if (all(is.na(first_or_last_exon_recon_temp)) != TRUE) {
      
      first_or_last_exon_recon <- first_or_last_exon_recon_temp %>% na.omit %>% paste(collapse = ",")
      
    }
    
  }
  
  return(list("diff_exon_coords" = list_matched_ref_recon_gtf$diff_exon_coords,
              "splicemode" = list_matched_ref_recon_gtf$splicemode,
              "matched_gene_names" = matched_gene_names,
              "matched_ref_transcript_names" = matched_ref_transcript_names,
              "matched_recon_transcript_names" = matched_recon_transcript_names,
              "matched_strand" = matched_strand,
              "diff_exon_chr" = list_matched_ref_recon_gtf$diff_exon_chr,
              "diff_exon_start" = list_matched_ref_recon_gtf$diff_exon_start,
              "diff_exon_end" = list_matched_ref_recon_gtf$diff_exon_end,
              "NMD_reference" = NMD_reference,
              "NMD_recon" = NMD_recon,
              "first_or_last_exon_reference" = first_or_last_exon_reference,
              "first_or_last_exon_recon" = first_or_last_exon_recon))
  
}

```

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $diff_exon_chr, $diff_exon_start, $diff_exon_end
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons <- function(spliceregion_list, tibble_gtf_table, index) {
  
  # DEBUG ###################

  # index <- 1
  # spliceregion_list <- wide_tibble_of_all_unique_exon_coords_array.tree[[3]]
  # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_alltimepoints_reconstructed_gtf
  
  ###########################

  print(paste("now processing junction number", index))
  
  # +/- 1 nt tolerance
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$diff_exon_chr %>% trimws, ] %>% 
      .[.$start <= ((spliceregion_list$diff_exon_end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$diff_exon_start %>% as.numeric) - 2), ] %>% 
      .[!(.$start <= ((spliceregion_list$diff_exon_end %>% as.numeric) - 1) & .$end >= ((spliceregion_list$diff_exon_start %>% as.numeric) + 1)), ] %>% 
      .[.$type == "exon", ]
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks the junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
    
    tibbles_all_flanking_exon_gtf.entries_per_transcript <- list_of_tibbles_flanking_exon_gtf.entries_per_transcript %>% rbindlist %>% as_tibble
  
  return(tibbles_all_flanking_exon_gtf.entries_per_transcript)
  
}

```

```{r}

# FUNCTION TO EXTRACT REFERENCE EXONS WHICH OVERLAP EXACTLY WITH QUERY EXONS
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $diff_exon_chr, $diff_exon_start, $diff_exon_end
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_overlapping.exons <- function(spliceregion_list, tibble_gtf_table, stranded = FALSE) {
  
  # DEBUG ###################
# 
#   index <- 1
#   spliceregion_list <- wide_tibble_of_all_unique_exon_coords_array.tree[[index]]
#   # tibble_gtf_table <- tibble_ref_gtf
#   tibble_gtf_table <- tibble_alltimepoints_reconstructed_gtf
  
  ###########################

  # print(paste("now processing junction number", index))
  
  if (stranded == FALSE) {
    
    # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$diff_exon_chr %>% trimws, ] %>% 
      .[.$start > ((spliceregion_list$diff_exon_start %>% as.numeric) - 2) & .$end < ((spliceregion_list$diff_exon_end %>% as.numeric) + 2), ] %>% 
      .[(.$start < ((spliceregion_list$diff_exon_start %>% as.numeric) + 2) & .$end > ((spliceregion_list$diff_exon_end %>% as.numeric) - 2)), ] %>% 
      .[.$type == "exon", ]
    
  } else if (stranded == TRUE) {
    
    # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$diff_exon_chr %>% trimws &
                                                              tibble_gtf_table$strand == spliceregion_list$matched_strand %>% trimws, ] %>% 
      .[.$start > ((spliceregion_list$diff_exon_start %>% as.numeric) - 2) & .$end < ((spliceregion_list$diff_exon_end %>% as.numeric) + 2), ] %>% 
      .[(.$start < ((spliceregion_list$diff_exon_start %>% as.numeric) + 2) & .$end > ((spliceregion_list$diff_exon_end %>% as.numeric) - 2)), ] %>% 
      .[.$type == "exon", ]
    
  }
  
  return(tibble_gtf_subset_overlapping_exons)
  
}

```

```{r}

# FUNCTION TO EXTRACT COMMON STRING FROM TWO INPUT STRINGS IN ONE STEP, A SIMPLIFICATION OF QUALV

extract_common_string <- function(input_string_a, input_string_b) {
  
  # debug ###
  # 
  # input_string_a <- "ud_absolute.psi_1"
  # input_string_b <- "ud_absolute.psi_2"
  
  ###########
  
  vector_of_letters_a <- strsplit(input_string_a, "") %>% unlist
  vector_of_letters_b <- strsplit(input_string_b, "") %>% unlist 

  raw_LCS <- qualV::LCS(vector_of_letters_a, vector_of_letters_b)
  vector_common_string <- raw_LCS$LCS %>% paste(collapse = "")
  
  return(vector_common_string)
    
}

# END extract_common_string()

# FUNCTION TO TAKE THE AVERAGE VALUE OF A MATRIX OF TIMEPOINTS WITH THREE REPLICATES EACH (3 column compartments at a time)
## replicates of the same timepoint must be all grouped together.
calculate_average_values_from_replicate_columns <- function(input_matrix, number_of_replicates, append_average_to_column_name = TRUE) {
  
  # DEBUG ######
  
  # input_matrix <- wide_tibble_of_psisigma_results_allcomparisons_final_ud.only[, col_indices_observations]
  # number_of_replicates <- 3
  
  ##############
  
  # sanity check - if the number of columns is not an integer multiple of the number of replicates, there's something wrong
  if (ncol(input_matrix) %% number_of_replicates != 0) {
    
    stop("the number of columns in the matrix is not an integer multiple of the number of replicates specified. please check the matrix and try again.")
    
  }
  
  # get the row numbers to subset
  ## start of each compartment
  a <- seq(1, (ncol(input_matrix) - number_of_replicates + 1), number_of_replicates)
  ## end of each compartment
  b <- seq(number_of_replicates, ncol(input_matrix), number_of_replicates)
  # create list of compartments
  c <- purrr::map2(.x = a, .y = b, .f = ~.x:.y)
  # map each column into each compartment
  d <- purrr::map(.x = c, .f = ~input_matrix[, .x])
  # apply the average
  e <- purrr::map(.x = d, .f = ~apply(X = .x, MARGIN = 1, FUN = function(X){mean(X, na.rm = TRUE)}))
  # retrieve the column names of each compartment
  column_names <- purrr::map(.x = d, .f = ~colnames(.x) %>% purrr::reduce(extract_common_string))
  
  if (append_average_to_column_name == TRUE) {
    
    column_names <- paste(column_names, "average", sep = "")
    
  }
  
  # reframe into tibble, return
  f <- e %>% set_names(column_names) %>% as_tibble
  
}

# END calculate_average_values_from_replicate_columns()

```

## functions for transcript and domain matching

```{r}

# this will take the result of genomic-to-protein mapping (i.e. ENSP ids) and feed it through biomart. The result is a list of protein domain accessions/ids that overlap (AT THE MOMENT FULL OVERLAP ONLY) with the query interval
# expected input: a list of lists. max level = 2.
# NOTE2: COLUMNS EXPECTED: $1 (ENSP) "names", $2 "start", $3 "width", $4 "end"

tibble_of_mapped_protein_positions_to_list_of_domains_PTMs <- function(list_of_mapped_proteinID, ensemblmart) {
  
  # DEBUG ###
  # list_of_mapped_proteinID <- mapped_aminoacid_positions
  ###########
  
  # extract all query ENSP ids
  vec_all_ENSP_ids <- list_of_mapped_proteinID %>% flatten %>% rbindlist %>% .$names
  
  # create a list of attributes to retrieve from biomart. we will loop thru this.
  list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                         "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                         "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                         "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                         "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                         "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                         "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))
  
  # search biomart
  list_biomart_result_per_attribute <- future_map(.x = list_of_attributes_to_retrieve, .f = ~getBM(filters = "ensembl_peptide_id", values =  vec_all_ENSP_ids %>% unique, attributes = .x, mart = ensemblmart), .progress = TRUE, .options = future_options(globals = c("vec_all_ENSP_ids", "getBM", "ensemblmart")))
  
  # remove na values from biomart result
  list_biomart_result_per_attribute_processed <- purrr::map(.x = list_biomart_result_per_attribute, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_biomart_result_per_attribute[[1]]
    ###########
    
    tibble_of_single_attribute <- .x %>% as_tibble
    
    # fetch na or blank row indices
    row.indices_na_values <- tibble_of_single_attribute %>% apply(MARGIN = 1, FUN = function(X) {any(is.na(X) == TRUE | X == "")}) %>% which
    tibble_of_single_attribute <- tibble_of_single_attribute[-row.indices_na_values, ]
    
    # rename columns start and end to be generic
    colnames(tibble_of_single_attribute)[grep(x = colnames(tibble_of_single_attribute), pattern = "start")] <- "start"
    colnames(tibble_of_single_attribute)[grep(x = colnames(tibble_of_single_attribute), pattern = "end")] <- "end"
    
    return(tibble_of_single_attribute)
    
  } )

  # ALL DOMAIN ANNOTATIONS FROM BIOMART ARE FINISHED HERE ######
  
  # get ENSP to uniprot entry mapping
  table_ENSP_to_uniprot_entry_mapping <- biomaRt::getBM(filters = "ensembl_peptide_id", values = vec_all_ENSP_ids, attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
  (# remove NA/blank rows
    function(x) {
      
      # debug ###
      # x <- table_ENSP_to_uniprot_entry_mapping
      ###########
      
      row.indices_na_or_blank_values <- x %>% apply(MARGIN = 1, FUN = function(X) {any(is.na(X) | X == "")} ) %>% which
      
      table <- x[-row.indices_na_or_blank_values, ]
      
      return(table)
      
    } )
  
  # for each query interval associated with an ENSP id, extract overlapping biomart result entries.
  list_extracted_overlapping_biomart_results <- future_map(.x = list_of_mapped_proteinID, .f = 
                                                             ~purrr::map(.x = .x, .f = 
                                                                           function(.x) {
                                                                             
                                                                             # DEBUG ###
                                                                             # .x <- list_of_mapped_proteinID[[1]][[1]]
                                                                             ###########
                                                                             
                                                                             query_ENSP <- .x$names
                                                                             query_start <- .x$start
                                                                             query_end <- .x$end
                                                                             list_of_mapped_proteinID
                                                                             matching_tibble_entries_biomart <- purrr::map(.x = list_biomart_result_per_attribute_processed, 
                                                                                                                   .f = ~.x[.x$ensembl_peptide_id == query_ENSP & 
                                                                                                                              .x$start < query_end &
                                                                                                                              .x$end > query_start, ])
                                                                             
                                                                             # retrieve equivalent UniProt entry name 
                                                                             vec_uniprot_entry_IDs <- table_ENSP_to_uniprot_entry_mapping[table_ENSP_to_uniprot_entry_mapping$ensembl_peptide_id == query_ENSP, ] %>% .$uniprotkb_entry %>% unique %>% tibble::enframe(name = NULL, value = "uniprotkb_entry")
                                                                             # get overlapping dbPTM entries ###
                                                                             tibble_matching_entries_dbPTM <- dplyr::semi_join(dbPTM_allhuman_annotations, vec_uniprot_entry_IDs, by = "uniprotkb_entry")
                                                                             tibble_matching_entries_dbPTM <- tibble_matching_entries_dbPTM[tibble_matching_entries_dbPTM$modified_residue_position %in% (query_start:query_end) %>% which, ]
                                                                             # get overlapping phosphositeplus entries ###
                                                                             tibble_matching_entries_phosphositeplus <- dplyr::semi_join(phosphosite_allhuman_phosphosites, vec_uniprot_entry_IDs, by = "uniprotkb_entry")
                                                                             tibble_matching_entries_phosphositeplus <- tibble_matching_entries_phosphositeplus[tibble_matching_entries_phosphositeplus$modified_residue_position %in% (query_start:query_end) %>% which, ]
                                                                             
                                                                             matching_tibble_entries_all <- purrr::splice(list("ensembl_peptide_id" = query_ENSP), 
                                                                                                                          matching_tibble_entries_biomart, 
                                                                                                                          "dbPTM" = tibble_matching_entries_dbPTM,
                                                                                                                          "phosphositeplus" = tibble_matching_entries_phosphositeplus)
                                                                             
                                                                             return(matching_tibble_entries_all)
                                                                             
                                                                           } ), .progress = TRUE, .options = future_options(globals = c("list_biomart_result_per_attribute_processed", "table_ENSP_to_uniprot_entry_mapping", "dbPTM_allhuman_annotations", "phosphosite_allhuman_phosphosites")))

return(list_extracted_overlapping_biomart_results)

}

# END tibble_of_mapped_protein_positions_to_list_of_domains_PTMs()

# this will help us deal with ranges with partial overlap. I classify into 3 cases: 1. query start and end positions both lie in the CDS region 2. start is missing 3. end is missing 4. both missing.
# in the case of missing start/end, it's simple. we use the fact that always start > end.
# we will use the closest number between start and end which actually lies in the CDS region as a proxy for the missing value.
match_query_startend_with_vectors_of_CDSpositions <- function(vector_of_sorted_CDSpositions, ENSP_id, input_query_start, input_query_end) {
  
  # # case if none missing
  # if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 1 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 1) {
  # 
  #   proxy_query_start <- input_query_start
  #   proxy_query_end <- input_query_end
  #   
  # # case if input start missing
  # } else if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 0 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 1) {
  # 
  #   proxy_query_start <- min(vector_of_sorted_CDSpositions[which(input_query_start < vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions < input_query_end)])
  #   proxy_query_end <- input_query_end
  #   
  # # case if input end missing
  # } else if (intersect(vector_of_sorted_CDSpositions, input_query_start) %>% length == 1 & intersect(vector_of_sorted_CDSpositions, input_query_end) %>% length == 0) {

  # DEBUG ###
  # vector_of_sorted_CDSpositions <- list_overlapping_protein_CDS_positions_tibbles[[2]][[2]]
  # gtf_table <- tibble_ref_gtf_simplified
  # ensemblmart <- ensembl_mart
  # ENSP_id <- list_overlapping_protein_CDS_exons_tibbles[[2]][[1]]$protein_id %>% unique
  # input_query_start <- 37022080
  # input_query_end <- 37023044
  # tibble_queryisoforms_chr_strand_start_end
  ###########
  
    proxy_query_start <- min(vector_of_sorted_CDSpositions[which(input_query_start <= vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions <= input_query_end)])
    proxy_query_end <- max(vector_of_sorted_CDSpositions[which(input_query_start <= vector_of_sorted_CDSpositions & vector_of_sorted_CDSpositions <= input_query_end)])

  # }

  # NOTICE: I DELIBERATELY EXPANDED THE END RANGE BY 1 TO ACCOUNT FOR N-TERMINAL METHIONINE EXCISION. THIS IS, AFTER ALL, A CATCH-ALL.

  protein_coordinate_start <-((which(vector_of_sorted_CDSpositions == proxy_query_start) - 1) %/% 3) + 1
  protein_coordinate_end <- ((which(vector_of_sorted_CDSpositions == proxy_query_end) - 1) %/% 3) + 1 + 1
  protein_coordinate_width <- protein_coordinate_end - protein_coordinate_start + 1

  tibble_of_mapped_protein_coordinates <- tribble(~names, ~start, ~width, ~end,
                                                    ENSP_id,
                                                    protein_coordinate_start,
                                                    protein_coordinate_width,
                                                    protein_coordinate_end)

  return(tibble_of_mapped_protein_coordinates)
  
  # debug
  # return(list(vector_of_sorted_CDSpositions, ENSP_id, input_query_start, input_query_end, proxy_query_start, proxy_query_end))
  
}

# END match_query_startend_with_vectors_of_CDSpositions

# FILTER THE GTF TABLE BY ANNOTATIONS OVERLAPPING WITH THE QUERY INTERVAL(S)

# possible modes that this function can operate in: 1. "AS region" and 2. "BED_file" 
# AS region mode is for finding all the overlapping gtf annotations of a given AS event
# BED file mode is for annotating a BED file (especially from CLIP-SEQ/RIP-seq/parclip) 
# target level is the filter for the "type" in gtf table. one of: "gene", "transcript", "exon", "CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr", "Selenocysteine"

map_genome_coordinate_to_transcriptandprotein <- function(chr_strand_start_end_tibble, gtf_table, mode, targetlevel = NULL) {
  
  # DEBUG ###
  # chr_strand_start_end_tibble <- tibble_queryisoforms_chr_strand_start_end
  # gtf_table <- tibble_ref_gtf_simplified
  # mode = "AS region"
  ###########
  
  if (mode == "AS region") {
  
  list_of_query_AS_ID <- chr_strand_start_end_tibble$diff_exon_coords %>% array_tree

list_of_all_overlapping_annotations <- future_imap(.x = list_of_query_AS_ID, .f = function(.x, .y) {
  
  # message("Now processing entry number: ", .y)
  
  overlapping_gtf_entries <- gtf_table[(gtf_table$chr == chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "chr"] %>% unique %>% paste %>% as.character) &
    (gtf_table$strand == chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "strand"] %>% unique %>% paste %>% as.character), ] %>% 
    .[(.$start < chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "end"] %>% unique %>% paste %>% as.numeric) & 
        (.$end > chr_strand_start_end_tibble[chr_strand_start_end_tibble$diff_exon_coords == .x, "start"] %>% unique %>% paste %>% as.numeric), ]
  
  return(overlapping_gtf_entries)
  
}, .progress = TRUE, .options = future_options(globals = c("gtf_table", "chr_strand_start_end_tibble")))

names(list_of_all_overlapping_annotations) <- chr_strand_start_end_tibble$Gene


  } else if (mode == "BED_file") {
  
    bed_chr_strand_start_end <- chr_strand_start_end_tibble
    
    colnames(bed_chr_strand_start_end) <- c("feature_chr", "feature_strand", "feature_start", "feature_end", "ClusterID", "ClusterSequence", "ReadCount", "ModeLocation", "ModeScore", "ConversionLocationCount", "ConversionEventCount", "NonConversionEventCount")

gtf_table_targetlevel <- gtf_table[gtf_table$type == targetlevel, ]

colnames(gtf_table_targetlevel) <- c("annotation_chr", "annotation_start", "annotation_end", "annotation_width", "annotation_strand", "annotation_type", "annotation_annotation_phase", "annotation_gene_id", "annotation_gene_name", "annotation_gene_biotype", "annotation_transcript_id", "annotation_transcript_name", "annotation_transcript_biotype", "annotation_exon_number", "annotation_exon_id", "annotation_protein_id")

gtf_entries_overlapping_with_bed <- purrr::pmap(.l = list(bed_chr_strand_start_end[["feature_chr"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_strand"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_start"]] %>% as.list, 
                                                             bed_chr_strand_start_end[["feature_end"]]) %>% as.list, 
                                                   .f = ~gtf_table_targetlevel %>%
                                                     .[.$annotation_chr == ..1 %>% lapply(as.character) %>% paste, ] %>% 
                                                       .[.$annotation_strand == ..2 %>% lapply(as.character) %>% paste, ] %>% 
                                                     .[(.$annotation_start < ..4 %>% as.numeric %>% paste) & 
                                                         (.$annotation_end > ..3 %>% as.numeric %>% paste), ]) %>% compact

unannotated_bed_file_arraytree <- bed_chr_strand_start_end %>% array_tree %>% purrr::map(~as_tibble(.x))

peaks_with_annotation <- which(purrr::map(gtf_entries_overlapping_with_bed, ~nrow(.x)) %>% unlist != 0)

annotated_bed_file <- purrr::map2(.x = unannotated_bed_file_arraytree[peaks_with_annotation], 
                                  .y = gtf_entries_overlapping_with_bed[peaks_with_annotation], 
                                  .f = ~cbind(.x, .y))

# not actually a list. actually a wide table.

list_of_all_overlapping_annotations <- annotated_bed_file %>% purrr::reduce(bind_rows)

}

return(list_of_all_overlapping_annotations)
  
}

# END map_genome_coordinate_to_transcriptandprotein

# sort lists of protein CDS positions by descending/ascending order depending if ORF is on + or - strand
##  function to look at a tibble containing the CDS positions and see whether you need to sort by increasing or decreasing order

sort_tibble_according_to_strand <- function(tibble_to_be_sorted) {
  
  if (data.class(tibble_to_be_sorted) != "tbl_df") {
    
    CDS_list_out <- tibble_to_be_sorted
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "+") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = FALSE)
    
  } else if (data.class(tibble_to_be_sorted) == "tbl_df" & tibble_to_be_sorted$strand %>% lapply(as.character) %>% unique %>% paste == "-") {
    
    CDS_list_out <- purrr::map2(.x = tibble_to_be_sorted$start, .y = tibble_to_be_sorted$end, .f = ~.x:.y) %>% unlist %>% unique %>% sort(., decreasing = TRUE)
    
  }
  
  return(CDS_list_out)
  
}

# END sort_according_to_strand

# THE MAIN FUNCTION TO CONVERT THE TIDIED CHR STRAND START END TIBBLE TO LISTS OF OVERLAPPING ANNOTATION AND PROTEIN DOMAINS
# inputs: 1. table containing regions to be queried. columns must be: Gene, AS event ID, chr, strand, start, end; 2. GTF table, preferably from rtracklayer::import, 3. ensembl mart of choice

tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain <- function(tibble_queryisoforms_chr_strand_start_end, gtf_table, ensemblmart) {
  
  # DEBUG ###
  # tibble_queryisoforms_chr_strand_start_end <- tibble_all_diff_exons_chr_strand_start_end
  # gtf_table <- tibble_ref_gtf_simplified
  # ensemblmart <- ensembl_mart
  ###########
    
  message("Now mapping the specified AS coords to transcript- and protein-relative coords")
  
  gtf_table <- gtf_table
  list_queryisoforms_overlapping_annotations_tibbles <- tibble_queryisoforms_chr_strand_start_end %>% map_genome_coordinate_to_transcriptandprotein(., gtf_table = gtf_table, mode = "AS region") 
  
  # set level 1 list names as the exon coords
  names(list_queryisoforms_overlapping_annotations_tibbles) <- tibble_queryisoforms_chr_strand_start_end$diff_exon_coords
  
  message("Extract the individual CDS regions of each protein overlapping the AS regions")
  list_overlapping_protein_CDS_exons_tibbles <- future_map(.x = list_queryisoforms_overlapping_annotations_tibbles, .f = ~.x$protein_id %>% na.omit %>% unique %>% as.list %>% purrr::map(.x = ., .f = ~gtf_table[gtf_table$protein_id == .x & gtf_table$type == "CDS", ] %>% .[apply(X = ., MARGIN = 1, FUN = function(X) {all(is.na(X)) == FALSE}), ]), .progress = TRUE, .options = future_options(globals = c("gtf_table")))
  
  message("Extract the individual genome-relative CDS nucleotide positions")
  list_overlapping_protein_CDS_positions_tibbles <- future_map(.x = list_overlapping_protein_CDS_exons_tibbles, .f = ~purrr::map(.x = .x, .f = ~sort_tibble_according_to_strand(.x)), .progress = TRUE, .options = future_options(globals = c("sort_tibble_according_to_strand")))
  
  message("Now generate a table of sorted protein relative coordinates for each genomic start and end associated with each unique AS region.")
  # provided functions: 
  # 1. list_overlapping_protein_CDS_positions_tibbles: list of genes corresponding to isoform enriched > list of vectors of genomic positions of CDS for each ENSP, 
  # 2. 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% as.list: level 1 indices, 
  # 3. list_overlapping_protein_CDS_exons_tibbles: list of genes corresponding to isoform enriched > list of subsets of GTF table for each unique ENSP caught by query range. used for ENSP id mapping 
  # NOTE: width < 0 if the ORF is on the - strand
  mapped_aminoacid_positions <- purrr::pmap(.l = list("A" = list_overlapping_protein_CDS_positions_tibbles, 
                                                      "B" = 1:length(list_overlapping_protein_CDS_positions_tibbles) %>% array_tree,
                                                      "C" = list_overlapping_protein_CDS_exons_tibbles), .f = function(A, B, C) {
                                                        
                                                        level_one_index <- B
                                                        
                                                        message("now processing entry number: ", level_one_index)
                                                        
                                                        purrr::map2(.x = A, .y = C, .f = function(.x, .y) {
                                                          
                                                          # print(paste(".x = ", .x %>% head))
                                                          # print(paste(.y))
                                                          
                                                          match_query_startend_with_vectors_of_CDSpositions(vector_of_sorted_CDSpositions = .x,
                                                                                                            ENSP_id = paste(.y$protein_id %>% unique),
                                                                                                            input_query_start = paste(tibble_queryisoforms_chr_strand_start_end[level_one_index, "start"]) %>% as.numeric,
                                                                                                            input_query_end = paste(tibble_queryisoforms_chr_strand_start_end[level_one_index, "end"]) %>% as.numeric)
                                                          
                                                          } )
                                                        } )
  
  # FINALLY! PROTEIN DOMAIN MATCHING!
  
  # get rid of empty genes with no match
  mapped_aminoacid_positions <- purrr::discard(.x = mapped_aminoacid_positions, .p = ~length(.x) == 0)
  
  # retrieve all the domain and PTM annotations
  coinciding_domains_PTMs <- tibble_of_mapped_protein_positzions_to_list_of_domains_PTMs(mapped_aminoacid_positions, ensemblmart)
  
  # summarise protein and transcript-level analyses
  ## for the transcript level, only extract the "type" and "transcript_biotype" columns
  list_of_tibbles_transcript_level_results <- list_queryisoforms_overlapping_annotations_tibbles %>% purrr::map(~.x[, c("type", "transcript_biotype")] %>% unique)
  ## add in the exon coords from the level 1 list and rbind
  tibble_transcript_level_results <- purrr::map2(.x = list_of_tibbles_transcript_level_results, .y = names(list_of_tibbles_transcript_level_results), .f = ~add_column(.x, "diff_exon_coords" = .y, .before = 1)) %>% rbindlist %>% as_tibble
  
  ## for the protein/domain etc. level, extract and collapse OR convert to logical indicating the presence/absence of a feature.
  list_of_tibbles_protein_level_results <- purrr::map2(.x = coinciding_domains_PTMs, .y = names(coinciding_domains_PTMs), .f = function(.x, .y) {
    
    # DEBUG ###
    # .x <- coinciding_domains_PTMs[[1]]
    # .y <- names(coinciding_domains_PTMs) %>% .[[1]]
    ###########
    
    list_L2 <- .x
    L1_id <- .y
    
    # convert ncoils, seg, signalp, tmhmm, mobidblite to logical.
    list_L2_processed <- purrr::map(.x = list_L2, .f = ~purrr::modify_at(.x = .x, .at = c("ncoils", "seg", "signalp", "tmhmm", "mobidblite"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(TRUE)
        
      }
      
      return(annotation_exists)
      
    } ))
    
    # collapse interpro annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("interpro"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(paste(.x$interpro, collapse = ";"))
        
      }
      
    } ))
    
    # collapse sifts annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("sifts"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(FALSE)
        
      } else if (nrow(.x) != 0) {
        
        return(paste(.x$sifts_import, collapse = ";"))
        
      }
      
    } ))
    
    # collapse dbPTM annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("dbPTM"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(tibble("dbPTM_uniprotkb_entry" = NA,
                      "dbPTM_modified_residue_position" = NA,
                      "dbPTM_PTM_type" = NA))
        
      } else if (nrow(.x) != 0) {
        
        return(tibble("dbPTM_uniprotkb_entry" = paste(.x$uniprotkb_entry, collapse = ";"),
                      "dbPTM_modified_residue_position" = paste(.x$modified_residue_position, collapse = ";"),
                      "dbPTM_PTM_type" = paste(.x$PTM_type, collapse = ";")))
        
      }
      
    } ))
    
    # collapse phosphositeplus annotation
    list_L2_processed <- purrr::map(.x = list_L2_processed, .f = ~purrr::modify_at(.x = .x, .at = c("phosphositeplus"), .f = function(.x) {
      
      if (nrow(.x) == 0) {
        
        return(tibble("phosphositeplus_uniprotkb_entry" = NA,
                      "phosphositeplus_modified_residue_position" = NA))
        
      } else if (nrow(.x) != 0) {
        
        return(tibble("phosphositeplus_uniprotkb_entry" = paste(.x$uniprotkb_entry, collapse = ";"),
                      "phosphositeplus_modified_residue_position" = paste(.x$modified_residue_position, collapse = ";")))
        
      }
      
    } ))
    
    # splice in the level 1 list name (in this case, it's diff_exon_coords)
    list_L2_final <- purrr::map(.x = list_L2_processed, .f = ~purrr::splice(list("diff_exon_coords" = L1_id), 
                                                                            .x))
    
    return(list_L2_final)
    
  })
  ## flatten, tibblise within each element then rbind. 
  tibble_protein_level_results <- list_of_tibbles_protein_level_results %>% flatten 
  names(tibble_protein_level_results) <- NULL
  tibble_protein_level_results <- tibble_protein_level_results %>% purrr::map(~flatten(.x) %>% as_tibble) %>% rbindlist %>% as_tibble
  
  return(list("transcript_level_results" = tibble_transcript_level_results,
              "protein_level_results" = tibble_protein_level_results))

}

# END tibble_queryisoforms_chr_strand_start_end_to_annotation_and_proteindomain

```

# Read the ir.sorted files into environment

## create file list and import using purrr

```{r}

list_of_comparisons_final <- vector_of_comparisons_final %>% array_tree

list_of_psisigma_result_tibbles_raw <- future_map(.x = list_of_comparisons_final, .f = ~read.delim(paste(psisigma_results_dir, .x, "/", .x, "_r5_ir3.sorted.txt", sep = "")) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble")))

```

## process column names, split the absolute PSI values and append comparison info

```{r}

list_of_psisigma_result_tibbles_processed <- purrr::map(.x = list_of_psisigma_result_tibbles_raw, .f = 
                                                          # rename all columns
                                                          ~setNames(.x, c("event_region_coords", "psisigma_gene.symbol", "diff_exon_coords", "splicemode", "num.replicates_comparison.1", "num.replicates_comparison.2", "psisigma_exon_type", "psisigma_reference.transcript", "dpsi", "pvalue", "FDR", "psi_comparison.1", "psi_comparison.2", "database_ID")) %>%
                                                          # separate absolute PSI columns
                                                          tidyr::separate(., col = psi_comparison.1, sep = "\\|", into = c("comparison.1_absolute.psi_1", "comparison.1_absolute.psi_2", "comparison.1_absolute.psi_3")) %>% 
                                                          # separate absolute PSI columns
                                                          tidyr::separate(., col = psi_comparison.2, sep = "\\|", into = c("comparison.2_absolute.psi_1", "comparison.2_absolute.psi_2", "comparison.2_absolute.psi_3")) %>%
                                                          # separate the co-ordinates of the differential exon in preparation for matching
                                                          add_column("diff_exon_chr" = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\1"), 
                                                                     "diff_exon_start" = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\2"), 
                                                                     "diff_exon_end" = gsub(x = .$diff_exon_coords, pattern = "(.*):(\\d+)-(.*)", replacement = "\\3")))
# add column indicating what comparison the tibble is from
list_of_psisigma_result_tibbles_processed <- map2(.x = list_of_psisigma_result_tibbles_processed, .y = list_of_comparisons_final, .f = ~add_column(.x, "comparison" = .y))

# collapse into a wide tibble
wide_tibble_of_psisigma_results_allcomparisons_processed <- list_of_psisigma_result_tibbles_processed %>% rbindlist %>% as_tibble %>% type_convert

# re-sort each of the three absolute psi values per comparison so that we have no mis-matching when we recast the table
## get the column incides of the timepoint and ud absolute psi values
vector_col.index_absolute.psi.comparison.1 <- grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_processed), pattern = "comparison.1_absolute.psi")
vector_col.index_absolute.psi.comparison.2 <- grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_processed), pattern = "comparison.2_absolute.psi")

## sort each compartment of 3 columns each
wide_tibble_of_psisigma_results_allcomparisons_processed[, vector_col.index_absolute.psi.comparison.1] <- future_apply(X = wide_tibble_of_psisigma_results_allcomparisons_processed[, vector_col.index_absolute.psi.comparison.1], MARGIN = 1, FUN = function(X) {sort(X, na.last = TRUE)}, future.globals = FALSE) %>% t %>% as_tibble

wide_tibble_of_psisigma_results_allcomparisons_processed[, vector_col.index_absolute.psi.comparison.2] <- future_apply(X = wide_tibble_of_psisigma_results_allcomparisons_processed[, vector_col.index_absolute.psi.comparison.2], MARGIN = 1, FUN = function(X) {sort(X, na.last = TRUE)}, future.globals = FALSE) %>% t %>% as_tibble

# remove all special characters from the splicemode column
wide_tibble_of_psisigma_results_allcomparisons_processed[, "splicemode"] <- gsub(x = wide_tibble_of_psisigma_results_allcomparisons_processed$splicemode, pattern = "(.*)overlapping(.*)", replacement = "IR_overlapping_region")

```

## re-label the gene/strand/first.last.only exon etc.

### match exons/junctions with the reference GTF

PSI-Sigma does a horrible job of getting the gene/strand information from the reference GTF. We will replace the existing annotation by doing our exact matching.

While we're at it, also match with the reconstructed GTF if matching to reference GTF is not possible.

NOTE: the reference GTF must have already had first/last/only exon info appended.

#### match to junctions for IR and exons to non-IR

```{r}

wide_tibble_of_all_unique_exon_coords <- wide_tibble_of_psisigma_results_allcomparisons_processed[, c("splicemode", "diff_exon_coords", "diff_exon_chr", "diff_exon_start", "diff_exon_end")] %>% unique

# split exon co-ords by whether it's IR or not
wide_tibble_of_all_unique_exon_coords_array.tree_IR <- wide_tibble_of_all_unique_exon_coords[grep(x = wide_tibble_of_all_unique_exon_coords$splicemode, pattern = "IR"), ] %>% array_tree
wide_tibble_of_all_unique_exon_coords_array.tree_not_IR <- wide_tibble_of_all_unique_exon_coords[-grep(x = wide_tibble_of_all_unique_exon_coords$splicemode, pattern = "IR"), ] %>% array_tree

# junction-flanking exon matches for IR events
list_ref_matching_exon_entries_IR <- future_imap(.x = wide_tibble_of_all_unique_exon_coords_array.tree_IR, .f = ~list(
  "reference_gtf_match" = extract_junction.flanking.exons(.x, tibble_ref_gtf, .y), 
  "reconstructed_gtf_match" = extract_junction.flanking.exons(.x, tibble_recon_gtf, .y), 
  "diff_exon_coords" = .x$diff_exon_coords,
  "diff_exon_chr" = .x$diff_exon_chr,
  "diff_exon_start" = .x$diff_exon_start,
  "diff_exon_end" = .x$diff_exon_end,
  "splicemode" = .x$splicemode), 
  .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_recon_gtf", "extract_junction.flanking.exons")))

list_ref_matching_exon_entries_IR_annotated <- future_imap(.x = list_ref_matching_exon_entries_IR, .f = ~annotate_differential_exon(.x) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("annotate_differential_exon", "as_tibble")))

# for non-IR events, match exons.
list_ref_matching_exon_entries_not_IR <- future_imap(.x = wide_tibble_of_all_unique_exon_coords_array.tree_not_IR, .f = ~list(
  "reference_gtf_match" = extract_overlapping.exons(.x, tibble_ref_gtf, .y), 
  "reconstructed_gtf_match" = extract_overlapping.exons(.x, tibble_recon_gtf, .y), 
  "diff_exon_coords" = .x$diff_exon_coords,
  "diff_exon_chr" = .x$diff_exon_chr,
  "diff_exon_start" = .x$diff_exon_start,
  "diff_exon_end" = .x$diff_exon_end,
  "splicemode" = .x$splicemode), 
  .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_recon_gtf", "extract_overlapping.exons")))

list_ref_matching_exon_entries_not_IR_annotated <- future_imap(.x = list_ref_matching_exon_entries_not_IR, .f = ~annotate_differential_exon(.x) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("annotate_differential_exon", "as_tibble")))

tibble_ref_matching_exon_entries_all <- dplyr::bind_rows(list_ref_matching_exon_entries_IR_annotated %>% rbindlist, list_ref_matching_exon_entries_not_IR_annotated %>% rbindlist) %>% as_tibble

write.table(tibble_ref_matching_exon_entries_all, file = paste(R_processing_results_dir, "table_all_exons_reference_match_info.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

#### SUMMARISE NON-IR ENTRIES (SIMPLE)

Summarise for first/last exon, NMD.

behaviour: if annotation appears in at least ONE match in either reference or recon, then TRUE (union)

```{r}

# read the table of annotation
tibble_ref_matching_exon_entries_all <- read.delim(file = paste(R_processing_results_dir, "table_all_exons_reference_match_info.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE) %>% type_convert %>% as_tibble

# extract the row indices of IR event entries from the tibble_ref_matching_exon_entries_all
row.indices_IR_events <- grep(x = tibble_ref_matching_exon_entries_all$splicemode, pattern = "IR")

# subset exon annotation table for non IR events
tibble_ref_matching_exon_entries_all_not.IR <- tibble_ref_matching_exon_entries_all[-row.indices_IR_events, ]

# summarise annotation
## initialise columns
tibble_ref_matching_exon_entries_all_not.IR_summarised <- tibble_ref_matching_exon_entries_all_not.IR %>% 
  add_column("any_first_exon" = FALSE,
             "any_last_exon" = FALSE,
             "any_NMD" = FALSE)

tibble_ref_matching_exon_entries_all_not.IR_summarised[union(grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_reference, pattern = "first_exon"),
                                                               grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_recon, pattern = "first_exon")), "any_first_exon"] <- TRUE

tibble_ref_matching_exon_entries_all_not.IR_summarised[union(grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_reference, pattern = "last_exon"),
                                                               grep(x = tibble_ref_matching_exon_entries_all_not.IR_summarised$first_or_last_exon_recon, pattern = "last_exon")), "any_last_exon"] <- TRUE

tibble_ref_matching_exon_entries_all_not.IR_summarised[which(tibble_ref_matching_exon_entries_all_not.IR_summarised$NMD_reference == TRUE | tibble_ref_matching_exon_entries_all_not.IR_summarised$NMD_recon == TRUE), "any_NMD"] <- TRUE

```

#### REANNOTATE AND SUMMARISE IR ENTRIES (COMPLICATED)

```{r}

# re-match the IR events to the reference annotation
# for IR event entries, complicated. First retrieve the matched/recon transcripts. then find transcripts with overlapping exons.
# These IR-spanning transcripts must have at least ONE start/end coord/gene name in common with the junction-matched transcripts.
# return their corresponding annotations.
# NOTE: it seems like JUM only associates one junction ID with each IR event (which makes sense). However, my small sample size of 52 IR junctions isn't enough to fully conclude this is the case.
## array tree-ify the AS_event_IDs for looping
list_ref_matching_exon_entries_all_array.tree_IR <- tibble_ref_matching_exon_entries_all[row.indices_IR_events, ] %>% array_tree

## look up the annotation tibble for each AS_event_ID, summarise.
list_ref_matching_exon_entries_all_array.tree_IR_reannotated <- future_imap(.x = list_ref_matching_exon_entries_all_array.tree_IR, .f = function(.x, .y) {
  
  # message("now processing entry number: ", .y)
  
  # DEBUG ###
  .x <- list_ref_matching_exon_entries_all_array.tree_IR[[216]]
  tibble_ref_gtf <- tibble_ref_gtf
  tibble_recon_gtf <- tibble_recon_gtf
  ###########
  
  tibble_ref_gtf <<- tibble_ref_gtf
  tibble_recon_gtf <<- tibble_recon_gtf
  
  chr <- .x$diff_exon_chr %>% paste %>% trimws
  start <- .x$diff_exon_start %>% paste %>% trimws %>% type.convert
  end <- .x$diff_exon_end %>% paste %>% trimws %>% type.convert
  strand <- .x$matched_strand %>% paste %>% trimws
  vec_ref_transcripts_matched_to_junction <- .x$matched_ref_transcript_names %>% strsplit(split = ",") %>% unlist %>% tibble::enframe(name = NULL, value = "transcript_id")
  vec_recon_transcripts_matched_to_junction <- .x$matched_recon_transcript_names %>% strsplit(split = ",") %>% unlist %>% tibble::enframe(name = NULL, value = "transcript_id")
  
  # check reference annotation - but only if the junction was matched to reference in the first place.
  tibble_all_confirmed_IR_entries_ref <- "uninit"
  
  if (all(is.na(vec_ref_transcripts_matched_to_junction)) != TRUE) {
    
    # match IR region to reference
    tibble_ref_gtf_subset_IR_overlap <- tibble_ref_gtf[tibble_ref_gtf$seqnames == chr %>% trimws, ] %>% .[.$strand == strand %>% trimws, ] %>% .[.$start <= ((start %>% as.numeric) - 2) & .$end >= ((end %>% as.numeric) + 2), ] %>% .[.$type == "exon", ]
  
    # get all the entries which matched to the junction
    tibble_ref_gtf_subset_junction_matching_entries <- dplyr::semi_join(tibble_ref_gtf[tibble_ref_gtf$type == "exon", ], vec_ref_transcripts_matched_to_junction, by = "transcript_id")
    
    # extract all the start coords of the junction-matched entries
    vector_junction_matched_start_coords <- tibble_ref_gtf_subset_junction_matching_entries[, "start"]
    # find which IR matched entry has any same start coord
    tibble_ref_gtf_subset_IR_overlap_start.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_start_coords)
    
    # extract all the end coords of the junction-matched entries
    vector_junction_matched_end_coords <- tibble_ref_gtf_subset_junction_matching_entries[, "end"]
    # find which IR matched entry has any same end coord
    tibble_ref_gtf_subset_IR_overlap_end.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_end_coords)
    
    # extract all the gene names of the junction-matched entries
    vector_junction_matched_gene_names <- tibble_ref_gtf_subset_junction_matching_entries[, "gene_name"]
    # find which IR matched entry has any same end coord
    tibble_ref_gtf_subset_IR_overlap_gene.name.matched <- dplyr::semi_join(tibble_ref_gtf_subset_IR_overlap, vector_junction_matched_gene_names)
    
    tibble_union_start.and.end.matched <- list(tibble_ref_gtf_subset_IR_overlap_start.matched, 
                                            tibble_ref_gtf_subset_IR_overlap_end.matched,
                                            tibble_ref_gtf_subset_IR_overlap_gene.name.matched) %>% purrr::reduce(dplyr::union)
    
    if (nrow(tibble_union_start.and.end.matched) == 0) {
      
      tibble_all_confirmed_IR_entries_ref <- "uninit"
      
    } else if (nrow(tibble_union_start.and.end.matched) > 0) {
      
      tibble_all_confirmed_IR_entries_ref <- tibble_union_start.and.end.matched
      
    }
    
  }
  
  # check recon annotation - but only if the junction was matched to recon in the first place.
  tibble_all_confirmed_IR_entries_recon <- "uninit"
  
  if (all(is.na(vec_recon_transcripts_matched_to_junction)) != TRUE) {
    
    # match IR region to recon GTF
    tibble_recon_gtf_subset_IR_overlap <- tibble_recon_gtf[tibble_recon_gtf$seqnames == chr %>% trimws, ] %>% .[.$strand == strand %>% trimws, ] %>% .[.$start <= ((start %>% as.numeric) - 2) & .$end >= ((end %>% as.numeric) + 2), ] %>% .[.$type == "exon", ]
  
    # get all the entries which matched to the junction
    tibble_recon_gtf_subset_junction_matching_entries <- dplyr::semi_join(tibble_recon_gtf[tibble_recon_gtf$type == "exon", ], vec_recon_transcripts_matched_to_junction, by = "transcript_id")
    
    # extract all the start coords of the junction-matched entries
    vector_junction_matched_start_coords <- tibble_recon_gtf_subset_junction_matching_entries[, "start"]
    # find which IR matched entry has any same start coord
    tibble_recon_gtf_subset_IR_overlap_start.matched <- dplyr::semi_join(tibble_recon_gtf_subset_IR_overlap, vector_junction_matched_start_coords)
    
    # extract all the end coords of the junction-matched entries
    vector_junction_matched_end_coords <- tibble_recon_gtf_subset_junction_matching_entries[, "end"]
    # find which IR matched entry has any same end coord
    tibble_recon_gtf_subset_IR_overlap_end.matched <- dplyr::semi_join(tibble_recon_gtf_subset_IR_overlap, vector_junction_matched_end_coords, by = "end")
    
    tibble_union_start.and.end.matched <- list(tibble_recon_gtf_subset_IR_overlap_start.matched, 
                                            tibble_recon_gtf_subset_IR_overlap_end.matched) %>% purrr::reduce(dplyr::union)
    
    if (nrow(tibble_union_start.and.end.matched) == 0) {
      
      tibble_all_confirmed_IR_entries_recon <- "uninit"
      
    } else if (nrow(tibble_union_start.and.end.matched) > 0) {
      
      tibble_all_confirmed_IR_entries_recon <- tibble_union_start.and.end.matched
      
    }
    
  }
  
  # we now have enough info. to write up the final summary
  summarised_tibble_annotation <- .x %>% as_tibble
  
  # refresh the matched ref and recon transcript names
  summarised_tibble_annotation[, "matched_ref_transcript_names"] <- if (tibble_all_confirmed_IR_entries_ref != "uninit") {
    tibble_all_confirmed_IR_entries_ref$transcript_id %>% paste(collapse = ",")
  }
  
  summarised_tibble_annotation[, "matched_recon_transcript_names"] <- if (tibble_all_confirmed_IR_entries_recon != "uninit") {
    tibble_all_confirmed_IR_entries_recon$transcript_id %>% paste(collapse = ",")
  }
  
  summarised_tibble_annotation[, "NMD_reference"] <- if (tibble_all_confirmed_IR_entries_ref == "uninit") {
    FALSE
    } else {
      any(tibble_all_confirmed_IR_entries_ref$transcript_biotype == "nonsense_mediated_decay")
    }
  
   summarised_tibble_annotation[, "NMD_recon"] <- if (tibble_all_confirmed_IR_entries_recon == "uninit") {
     FALSE
     } else {
       all(tibble_all_confirmed_IR_entries_recon$NMD_candidate == TRUE)
     }
   
   summarised_tibble_annotation[, "first_or_last_exon_reference"] <- if (tibble_all_confirmed_IR_entries_ref == "uninit") {
     .x$first_or_last_exon_reference %>% paste(collapse = ";")
     } else {
       tibble_all_confirmed_IR_entries_ref$first_or_last_exon %>% paste(collapse = ";")
     }
   
   summarised_tibble_annotation[, "first_or_last_exon_recon"] <- if (tibble_all_confirmed_IR_entries_recon == "uninit") {
     .x$first_or_last_exon_recon %>% paste(collapse = ";")
     } else {
       tibble_all_confirmed_IR_entries_recon$first_or_last_exon %>% paste(collapse = ";")
     }
   
   summarised_tibble_annotation <- summarised_tibble_annotation %>% add_column(
     "any_first_exon" = any(c(grep(x = .$first_or_last_exon_reference, pattern = "first_exon") %>% na.omit, 
                              grep(x = .$first_or_last_exon_recon, pattern = "first_exon") %>% na.omit)),
     "any_last_exon" = any(c(grep(x = .$first_or_last_exon_reference, pattern = "last_exon") %>% na.omit, 
                             grep(x = .$first_or_last_exon_recon, pattern = "last_exon") %>% na.omit)),
     "any_NMD" = any(c(grep(x = .$NMD_reference, pattern = "TRUE") %>% na.omit,
                       grep(x = .$NMD_recon, pattern = "TRUE") %>% na.omit)), .after = "NMD_recon")
  
  return(summarised_tibble_annotation)
  
}, .progress = TRUE, .options = future_options(globals = c("as_tibble", "tibble_ref_gtf", "tibble_recon_gtf")))

# tibblize
tibble_as.event.id_with_summarised_annotation_IR <- list_ref_matching_exon_entries_all_array.tree_IR_reannotated %>% rbindlist %>% as_tibble

```

### bind rows for final summarised exon reference annotation

```{r}

tibble_ref_matching_exon_entries_all_summarised <- dplyr::bind_rows(tibble_as.event.id_with_summarised_annotation_IR %>% type_convert %>% type_convert, 
                                                                    # look at this shit LOL
                                                                    tibble_ref_matching_exon_entries_all_not.IR_summarised %>% type_convert %>% type_convert)

# left join of the annotated exon info onto the PSI-Sigma result tables
wide_tibble_of_psisigma_results_allcomparisons_final <- dplyr::left_join(wide_tibble_of_psisigma_results_allcomparisons_processed, tibble_ref_matching_exon_entries_all_summarised, by = c("diff_exon_coords", "splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end")) %>% dplyr::mutate_if(is.factor, as.character)

# reorder columns
wide_tibble_of_psisigma_results_allcomparisons_final <- wide_tibble_of_psisigma_results_allcomparisons_final[, c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "psisigma_gene.symbol", "psisigma_reference.transcript", "psisigma_exon_type", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_gene_names", "matched_recon_transcript_names", "matched_ref_transcript_names", "matched_strand", "NMD_reference", "NMD_recon", "any_NMD", "first_or_last_exon_reference", "first_or_last_exon_recon", "any_first_exon", "any_last_exon", "num.replicates_comparison.1", "num.replicates_comparison.2", "pvalue", "FDR", "dpsi", "comparison.1_absolute.psi_1", "comparison.1_absolute.psi_2", "comparison.1_absolute.psi_3", "comparison.2_absolute.psi_1", "comparison.2_absolute.psi_2", "comparison.2_absolute.psi_3", "comparison")]

cat("There are", wide_tibble_of_psisigma_results_allcomparisons_final[, c("event_region_coords", "diff_exon_coords")] %>% unique %>% nrow, "exons detected in total (at least one observation across the entire time series)")

# remove exons which have less than 2 observations in both comparisons
wide_tibble_of_psisigma_results_allcomparisons_final <- wide_tibble_of_psisigma_results_allcomparisons_final %>% dplyr::filter(., num.replicates_comparison.1 >= 2 & num.replicates_comparison.2 >= 2) %>% mutate_if(is.factor, as.character) %>% type_convert

```

### add gene info for those entries which still don't have gene info 
#### if couldn't directly match reference/recon, use the PSI-Sigma gene symbol instead

```{r}

# get row indices of those that do not have strand info
row.indices_na_matched_gene_name <- which(is.na(wide_tibble_of_psisigma_results_allcomparisons_final$matched_gene_names))

# migrate PSI-sigma gene symbols to the match column
wide_tibble_of_psisigma_results_allcomparisons_final[row.indices_na_matched_gene_name, "matched_gene_names"] <- wide_tibble_of_psisigma_results_allcomparisons_final[row.indices_na_matched_gene_name, "psisigma_gene.symbol"]

```

### add strand for those entries which still don't have strand info 
#### if couldn't directly match reference/recon, use the PSI-Sigma gene symbol to get strand info

```{r}

# get row indices of those that do not have strand info
row.indices_na_matched_strand <- which(is.na(wide_tibble_of_psisigma_results_allcomparisons_final$matched_strand))

# purrr::map to look up the reference GTF strand of each row based on psi sigma gene symbol
list_missing_strand_info <- future_map(.x = row.indices_na_matched_strand, .f = ~tibble_ref_gtf[tibble_ref_gtf$gene_name == wide_tibble_of_psisigma_results_allcomparisons_final[.x, "psisigma_gene.symbol"] %>% paste, "strand"] %>% unlist %>% unique %>% paste, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "wide_tibble_of_psisigma_results_allcomparisons_final")))

# rejoin retrieved information with the table
wide_tibble_of_psisigma_results_allcomparisons_final[row.indices_na_matched_strand, "matched_strand"] <- list_missing_strand_info %>% unlist

cat("there are", which(is.na(wide_tibble_of_psisigma_results_allcomparisons_final$matched_strand)) %>% length, "rows with missing strand info\n")

# this is the FINAL tibble of all all comparisons ######
# export #
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_final, file = paste(R_processing_results_dir, "table_of_all_psi.sigma_results.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# write all unique genes as background
vec_all_psi.sigma_genes_genesymbol <- wide_tibble_of_psisigma_results_allcomparisons_final$matched_gene_names %>% unique
write.table(x = vec_all_psi.sigma_genes_genesymbol, file = paste(R_processing_results_dir, "table_of_all_psi.sigma_genes_genesymbol.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
# convert to ENSG
vec_all_psi.sigma_genes_ENSG <- getBM(filters = "external_gene_name", values = vec_all_psi.sigma_genes_genesymbol, attributes = "ensembl_gene_id", mart = ensembl_mart)
write.table(x = vec_all_psi.sigma_genes_ENSG, file = paste(R_processing_results_dir, "table_of_all_psi.sigma_genes_ENSG.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

```

# Filter for differential exons

## set filter criteria, dpsi and pvalue

```{r}

wide_tibble_of_psisigma_results_allcomparisons_final <- read.delim(paste(R_processing_results_dir, "table_of_all_psi.sigma_results.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# 2 choices: "pvalue" or "FDR"
pvalue_or_FDR <- "pvalue"

dpsi_cutoff <- 10

pvalue_cutoff <- 0.01

```

## filter, return the co-ordinates of the differential exons.

```{r}

# filter dpsi, pvalue and also remove exons which have less than 2 observations in both comparisons
wide_tibble_of_psisigma_results_allcomparisons_differential <- wide_tibble_of_psisigma_results_allcomparisons_final %>% dplyr::filter(., !!as.name(pvalue_or_FDR) <= pvalue_cutoff & abs(dpsi) >= dpsi_cutoff & num.replicates_comparison.1 >= 2 & num.replicates_comparison.2 >= 2)

number.of.LSVs_differential_anysig_with_na <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode, diff_exon_chr, diff_exon_start, diff_exon_end, matched_strand) %>% nrow
number.of.exons_differential_anysig_with_na <- wide_tibble_of_psisigma_results_allcomparisons_differential$diff_exon_coords %>% unique %>% length

message("There are ", number.of.LSVs_differential_anysig_with_na, " differential LSVs using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)
message("There are ", number.of.exons_differential_anysig_with_na, " differential exons using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)

# write table of all differential exons info
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_differential, file = paste(R_processing_results_dir, "long_table_of_all_differential_exons_info_dpsi_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.exons_differential_anysig_with_na, "_exons_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# export associated gene set
write.table(x = wide_tibble_of_psisigma_results_allcomparisons_differential$matched_gene_names %>% unique %>% na.omit, file = paste(R_processing_results_dir, "geneset_of_differential_results_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", wide_tibble_of_psisigma_results_allcomparisons_differential$matched_gene_names %>% unique %>% na.omit %>% length, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

# filter for tibble of unique differential LSVs only***
## tibble_differential_exon_coords <- wide_tibble_of_psisigma_results_allcomparisons_differential[, c("event_region_coords", "diff_exon_coords", "splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_strand")] %>% unique
tibble_unique_differential_LSVs <- wide_tibble_of_psisigma_results_allcomparisons_differential[, c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_strand")] %>% unique

# write table of unique differential exons co-ordinates only - for 3FT etc...
write.table(x = tibble_unique_differential_LSVs[, c("splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_strand")] %>% setNames(c("splicemode", "chr", "start", "end", "strand")) %>% unique, file = paste(R_processing_results_dir, "table_of_all_differential_exons_coords_dpsi_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.exons_differential_anysig_with_na, "_exons_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# also write table of differential information for 12d vs. ud.
tibble_differential_results_12d_vs_ud <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::filter(comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_ud" & abs(dpsi) >= dpsi_cutoff)
# write table
write.table(x = tibble_differential_results_12d_vs_ud, file = paste(R_processing_results_dir, "table_of_differential_results_12d_vs_ud_only_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% na.omit %>% length, "_exons_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# export associated gene set
write.table(x = tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% na.omit, file = paste(R_processing_results_dir, "geneset_of_differential_results_12d_vs_ud_only_dpsi", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% na.omit %>% length, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)

cat("There are", tibble_differential_results_12d_vs_ud$matched_gene_names %>% unique %>% na.omit %>% length, "differential genes between ud and 12d only, using the specified cutoff of", pvalue_or_FDR, "<", pvalue_cutoff, "and dpsi > ", dpsi_cutoff)

```

## filter for constitutive exons only

In order to apply the constitutive cutoff (which requires that ALL timepoints must be)

```{r}

# to fetch the unique LSVs which are constitutive:
## group all unique LSVs together
wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV <- wide_tibble_of_psisigma_results_allcomparisons_final %>% dplyr::group_by(database_ID, event_region_coords, diff_exon_coords, splicemode, diff_exon_chr, diff_exon_start, diff_exon_end, matched_strand)
## create logical of whether each LSV has all pvalue and dpsi cutoff AS WELL AS having all comparisons intact (and not missing)
## if return NA, then it's not constitutive.
wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV_constitutive.test <- wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV %>% dplyr::summarise("LSV_is_constitutive" = all(!!as.name(pvalue_or_FDR) > pvalue_cutoff & abs(dpsi) < dpsi_cutoff & num.replicates_comparison.1 >= 2 & num.replicates_comparison.2 >= 2) & n() == vector_of_comparisons_final %>% length) %>% dplyr::mutate_at("LSV_is_constitutive", .funs = function(x) {
  
  y <- x 
  
  y[which(is.na(y))] <- FALSE
  
  return(y)
  
} )
## subset table for only constitutive LSVs and extract all unique LSVs
wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV_constitutive.only <- wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV_constitutive.test[wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV_constitutive.test$LSV_is_constitutive == TRUE, ]
## extract unique constitutive LSVs
tibble_unique_constitutive_LSVs <- wide_tibble_of_psisigma_results_allcomparisons_final_grouped.by.LSV_constitutive.only %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, splicemode, diff_exon_chr, diff_exon_start, diff_exon_end, matched_strand, .keep_all = TRUE)
## rejoin onto main table
tibble_constitutive_LSV_info <- dplyr::semi_join(wide_tibble_of_psisigma_results_allcomparisons_final, tibble_unique_constitutive_LSVs)

# print numbers
number.of.LSVs_constitutive <- nrow(tibble_unique_constitutive_LSVs)
number.of.exons_constitutive <- tibble_unique_constitutive_LSVs$diff_exon_coords %>% unique %>% length

message("There are ", number.of.LSVs_constitutive, " constitutive LSVs using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)
message("There are ", number.of.exons_constitutive, " constitutive exons using the specified cutoff of ", pvalue_or_FDR, "<", pvalue_cutoff, " and dpsi > ", dpsi_cutoff)

# write table of all constitutive exons info
write.table(x = tibble_constitutive_LSV_info, file = paste(R_processing_results_dir, "long_table_of_all_constitutive_LSVs_info_dpsi_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.LSVs_constitutive, "_LSVs.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter for tibble of unique constitutive exon co-ordinates only
tibble_unique_constitutive_LSVs <- tibble_unique_constitutive_LSVs[, c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_strand")] %>% unique

# write table of unique constitutive exons co-ordinates only - for 3FT etc...
write.table(x = tibble_unique_constitutive_LSVs[, c("splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_strand")] %>% setNames(c("splicemode", "chr", "start", "end", "strand")) %>% unique, file = paste(R_processing_results_dir, "table_of_all_constitutive_exons_coords_dpsi_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.LSVs_constitutive, "_LSVs.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# Exon switching analysis

## Retrieve wide table of absolute PSI with timepoint/replicate NA

### subset the table of comparisons for comparisons to ud timepoint only

Join table separately by local isoform topology.

```{r}

# get a vector containing all the comparison names which have ud in them
vector_of_ud_comparisons <- vector_of_comparisons_final[grep(x = vector_of_comparisons_final, pattern = "ud")]

# subset the wide table of all comparisons for only comparisons which have ud
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp <- dplyr::filter(wide_tibble_of_psisigma_results_allcomparisons_final, comparison %in% vector_of_ud_comparisons, .preserve = TRUE) %>% dplyr::select(., -psisigma_reference.transcript, -psisigma_exon_type, -pvalue, -FDR, -dpsi, -num.replicates_comparison.1, -num.replicates_comparison.2)

# rename the columns. replace "comparison name" with "timepoint", rename the comparison 2 to ud
# >
colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp)[which(colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp) == "comparison")] <- "timepoint"
# >
colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp) <- gsub(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp), pattern = "comparison.2", replacement = "ud")

# replace the actual "comparison name" with "timepoint"
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp[, "timepoint"] <- gsub(x = wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp$timepoint, pattern = "(BM_MSC_to_OB_)(.*)_vs_(BM_MSC_to_OB_)(.*)", replacement = "\\2")

# melt into a long table to shake off the absolute psi columns per timepoint
## filter out comparison 1 from the column names
colnames_no_comparison.1 <- colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp)[grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp), pattern = "^(?!comparison.1).*", perl = TRUE)]
## melt
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp <- reshape2::melt(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp, id.vars = colnames_no_comparison.1, variable.name = "replicate", value.name = "absolute_psi")

# reformat the replicate column to have only numbers
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp[, "replicate"] <- gsub(x = wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp$replicate, pattern = "comparison.1_absolute.psi_", replacement = "")

# recast into a wide tibble
## aggregate function only sums if all values are not all NA. so it preserves values which are all NA.
## wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp[c(2200:2206, 2665:2670), ]
wide_tibble_of_psisigma_results_allcomparisons_final_ud.only <- reshape2::dcast(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only_temp %>% unique, formula =  database_ID + event_region_coords + diff_exon_coords + splicemode + psisigma_gene.symbol + diff_exon_chr + diff_exon_start + diff_exon_end + matched_gene_names + matched_recon_transcript_names + matched_strand + NMD_reference + NMD_recon + any_NMD + first_or_last_exon_reference + first_or_last_exon_recon + any_first_exon + any_last_exon + ud_absolute.psi_1 + ud_absolute.psi_2 + ud_absolute.psi_3 ~ timepoint + replicate, value.var = "absolute_psi") %>% as_tibble

# rename the columns. add "absolute.psi" to the colname.
colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only) <- gsub(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only), pattern = "(\\d+)(d|h)_(\\d)", replacement = "\\1\\2_absolute.psi_\\3")

# reorder columns into chronological order
## get column indices corresponding to observations
col_indices_observations <- grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only), pattern = "absolute.psi")
## reorder columns
wide_tibble_of_absolute_PSI_replicates <- wide_tibble_of_psisigma_results_allcomparisons_final_ud.only[, c(colnames(wide_tibble_of_psisigma_results_allcomparisons_final_ud.only)[-col_indices_observations], "ud_absolute.psi_1", "ud_absolute.psi_2", "ud_absolute.psi_3", "6h_absolute.psi_1", "6h_absolute.psi_2", "6h_absolute.psi_3", "12h_absolute.psi_1", "12h_absolute.psi_2", "12h_absolute.psi_3", "24h_absolute.psi_1", "24h_absolute.psi_2", "24h_absolute.psi_3", "3d_absolute.psi_1", "3d_absolute.psi_2", "3d_absolute.psi_3", "6d_absolute.psi_1", "6d_absolute.psi_2", "6d_absolute.psi_3", "9d_absolute.psi_1", "9d_absolute.psi_2", "9d_absolute.psi_3", "12d_absolute.psi_1", "12d_absolute.psi_2", "12d_absolute.psi_3")]

```

### take the average PSI for every time point - separated PSI

```{r}

wide_tibble_of_absolute_PSI_averages_separate <- dplyr::bind_cols(wide_tibble_of_absolute_PSI_replicates[, -col_indices_observations], wide_tibble_of_absolute_PSI_replicates[, col_indices_observations] %>% calculate_average_values_from_replicate_columns(., 3, append_average_to_column_name = TRUE))

# this is the final chopped table ready for exon switching analysis.

```

### sum exon PSIs for the same splice region/splicemode

```{r}

wide_tibble_of_absolute_PSI_averages_sum_temp <- wide_tibble_of_absolute_PSI_averages_separate %>% dplyr::select(., -database_ID)

# create list of event region, splicemode
list_unique_exon_regions <- wide_tibble_of_absolute_PSI_averages_sum_temp[, c("event_region_coords", "diff_exon_coords", "splicemode")] %>% unique %>% array_tree

# load the tibble of separated PSI averages into list
list_of_tibbles_absolute_PSI_average_subset_by_region <- future_map(.x = list_unique_exon_regions, .f = ~wide_tibble_of_absolute_PSI_averages_sum_temp[wide_tibble_of_absolute_PSI_averages_sum_temp$event_region_coords == (.x[[1]] %>% paste) & wide_tibble_of_absolute_PSI_averages_sum_temp$diff_exon_coords == (.x[[2]] %>% paste) & wide_tibble_of_absolute_PSI_averages_sum_temp$splicemode == (.x[[3]] %>% paste), ], .progress = TRUE, .options = future_options(globals = c("wide_tibble_of_absolute_PSI_averages_sum_temp")))

# take the average PSI of each timepoint
# we assume there are no more bugs which cause identical virtual splice variations to be duplicated. so therefore we do not need to take unique values.
list_of_tibbles_absolute_PSI_average_subset_by_region_sum <- future_map(.x = list_of_tibbles_absolute_PSI_average_subset_by_region, 
                                                                        .f = ~cbind(.x[, -grep(x = colnames(.x), pattern = "absolute.psi")] %>% unique, 
                                                                                    apply(X = .x[, grep(x = colnames(.x), pattern = "absolute.psi")], MARGIN = 2, FUN = function(X) {
                                                                                      if (all(is.na(X))) {
                                                                                        
                                                                                        X[NA_integer_]
                                                                                        
                                                                                        } else {
                                                                                          
                                                                                          sum(X, na.rm = TRUE)
                                                                                          # sum(X %>% unique, na.rm = TRUE)

                                                                                          
                                                                                        } 
                                                                                      
                                                                                      }) %>% t) %>% as_tibble, .progress = TRUE, .options = future_options(globals = FALSE))

wide_tibble_of_absolute_PSI_averages_sum <- list_of_tibbles_absolute_PSI_average_subset_by_region_sum %>% rbindlist %>% as_tibble

```

### separated PSI per local isoform

#### create subset list for every unique exon

```{r}

list_unique_exons_absolute_PSI_levels_exon.switching <- wide_tibble_of_absolute_PSI_averages_separate[, c("event_region_coords", "splicemode")] %>% unique %>% array_tree

list_of_tibbles_absolute_PSI_levels_exon.switching <- future_map(.x = list_unique_exons_absolute_PSI_levels_exon.switching, .f = ~wide_tibble_of_absolute_PSI_averages_separate[wide_tibble_of_absolute_PSI_averages_separate$event_region_coords == (.x[[1]] %>% paste) & wide_tibble_of_absolute_PSI_averages_separate$splicemode == (.x[[2]] %>% paste), ], .progress = TRUE, .options = future_options(globals = c("wide_tibble_of_absolute_PSI_averages_separate")))

```

#### calculate the ranks for every differentially spliced region with more than one exon recorded

```{r}

# calculate ranks
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching, .p = ~nrow(.x) > 1, .f = ~apply(X = .x[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_separate), pattern = "absolute.psi")], MARGIN = 2, FUN = function(X) {
  if (all(is.na(X))) {
    
    vector_rank <- rep(NA, times = length(X))
    
    } else {
      
      vector_rank <- rank(X %>% as.numeric, na.last = TRUE)
      
    }
  
  return(vector_rank)
  
  }) %>% t %>% na.omit %>% t)

remove_consecutive_duplicates_from_data.frame <- function(df) {
  
  # turn dataframe into list
  a <- df %>% array_tree
  # test if each term starting from 2nd element is identical to previous
  b <- purrr::map2(.x = a[1:(length(a) - 1)], .y = a[2:(length(a))], .f = ~identical(.x, .y))
  # get the elements (minus 1) which are not identical to previous
  c <- which(b == FALSE)
  # return filtered list
  d <- a[c(1, c + 1)]
  # re-make into dataframe
  e <- d %>% rbindlist %>% as.data.frame
  row.names(e) <- names(d)
  
  # return filtered dataframe
  return(e %>% t)
  
}

# unique consecutive ranks only
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint, .p = ~nrow(.x) > 1 & ncol(.x) > 1, .f = ~.x %>% t %>% remove_consecutive_duplicates_from_data.frame)

```

#### which elements have more than one column?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique, .p = ~nrow(.x) > 1, .f = ~ncol(.x) > 1)

```

#### for those exons with only one entry, is PSI going back and forth between 50%?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_logical_exon_switched_or_not, .p = ~is.logical(.x) == FALSE, 
                                          .f = ~any(.x[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_separate), pattern = "absolute.psi")] %>% unlist %>% na.omit > 50) & any(.x[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_separate), pattern = "absolute.psi")] %>% unlist %>% na.omit < 50))

```

#### filter the absolute PSI table for exons switched over the time course

```{r}

list_of_tibbles_of_absolute_PSI_averages_exon.switched <- list_of_tibbles_absolute_PSI_levels_exon.switching[which(list_of_logical_exon_switched_or_not %>% unlist == TRUE)]

tibble_of_absolute_PSI_averages_exon.switched_separate <- list_of_tibbles_of_absolute_PSI_averages_exon.switched %>% rbindlist %>% as_tibble

write.table(x = tibble_of_absolute_PSI_averages_exon.switched_separate, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(tibble_of_absolute_PSI_averages_exon.switched_separate), "_switched.exons_LSV.PSI_OB_diff_all.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### filter for differentially switched exons

```{r}

# join by event region and splicemode only because we want all the information in the event regions where differential splicing has occurred.
tibble_of_absolute_PSI_averages_exon.switched_differential_separate <- dplyr::semi_join(tibble_of_absolute_PSI_averages_exon.switched_separate, tibble_unique_differential_LSVs, by = c("event_region_coords", "splicemode"))

# this is the true number of LSVs which have underwent differential switching.
number_of_exons_differentially_switched_separate <- dplyr::semi_join(tibble_of_absolute_PSI_averages_exon.switched_separate, tibble_unique_differential_LSVs, by = c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode")) %>% nrow

cat("there are", number_of_exons_differentially_switched_separate, "LSVs which undergo significant switching over the time course")

write.table(x = tibble_of_absolute_PSI_averages_exon.switched_differential_separate, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(tibble_of_absolute_PSI_averages_exon.switched_differential_separate), "_switched.exons_LSV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### summed PSI per exon

#### create subset list for every unique exon

```{r}

list_unique_exons_absolute_PSI_levels_exon.switching <- wide_tibble_of_absolute_PSI_averages_sum[, c("event_region_coords", "splicemode")] %>% unique %>% array_tree

list_of_tibbles_absolute_PSI_levels_exon.switching <- future_map(.x = list_unique_exons_absolute_PSI_levels_exon.switching, .f = ~wide_tibble_of_absolute_PSI_averages_sum[wide_tibble_of_absolute_PSI_averages_sum$event_region_coords == (.x[[1]] %>% paste) & wide_tibble_of_absolute_PSI_averages_sum$splicemode == (.x[[2]] %>% paste), ], .progress = TRUE, .options = future_options(globals = c("wide_tibble_of_absolute_PSI_averages_sum")))

```

#### calculate the ranks for every differentially spliced region with more than one exon recorded

```{r}

# calculate ranks
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching, .p = ~nrow(.x) > 1, .f = ~apply(X = .x[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_sum), pattern = "absolute.psi")], MARGIN = 2, FUN = function(X) {
  if (all(is.na(X))) {
    
    vector_rank <- rep(NA, times = length(X))
    
    } else {
      
      vector_rank <- rank(X %>% as.numeric, na.last = TRUE)
      
    }
  
  return(vector_rank)
  
  }) %>% t %>% na.omit %>% t)

remove_consecutive_duplicates_from_data.frame <- function(df) {
  
  # turn dataframe into list
  a <- df %>% array_tree
  # test if each term starting from 2nd element is identical to previous
  b <- purrr::map2(.x = a[1:(length(a) - 1)], .y = a[2:(length(a))], .f = ~identical(.x, .y))
  # get the elements (minus 1) which are not identical to previous
  c <- which(b == FALSE)
  # return filtered list
  d <- a[c(1, c + 1)]
  # re-make into dataframe
  e <- d %>% rbindlist %>% as.data.frame
  row.names(e) <- names(d)
  
  # return filtered dataframe
  return(e %>% t)
  
}

# unique consecutive ranks only
list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint, .p = ~nrow(.x) > 1 & ncol(.x) > 1, .f = ~.x %>% t %>% remove_consecutive_duplicates_from_data.frame)

```

#### which elements have more than one column?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_tibbles_absolute_PSI_levels_exon.switching_ranks.per.timepoint_unique, .p = ~nrow(.x) > 1, .f = ~ncol(.x) > 1)

```

#### for those exons with only one entry, is PSI going back and forth between 50%?

```{r}

list_of_logical_exon_switched_or_not <- purrr::map_if(.x = list_of_logical_exon_switched_or_not, .p = ~is.logical(.x) == FALSE, 
                                          .f = ~any(.x[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_sum), pattern = "absolute.psi")] %>% unlist %>% na.omit > 50) & any(.x[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_sum), pattern = "absolute.psi")] %>% unlist %>% na.omit < 50))

```

#### filter the absolute PSI table for exons switched over the time course

```{r}

list_of_tibbles_of_absolute_PSI_averages_exon.switched <- list_of_tibbles_absolute_PSI_levels_exon.switching[which(list_of_logical_exon_switched_or_not %>% unlist == TRUE)]

tibble_of_absolute_PSI_averages_exon.switched_sum <- list_of_tibbles_of_absolute_PSI_averages_exon.switched %>% rbindlist %>% as_tibble

write.table(x = tibble_of_absolute_PSI_averages_exon.switched_sum, file = paste(R_processing_results_dir, "wide_table_of_",  nrow(tibble_of_absolute_PSI_averages_exon.switched_sum), "_switched.exons_exons.PSI_OB_diff_all.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### filter for differentially switched exons

```{r}

# join by event region and splicemode only because we want all the information in the event regions where differential splicing has occurred.
tibble_of_absolute_PSI_averages_exon.switched_differential_sum <- dplyr::semi_join(tibble_of_absolute_PSI_averages_exon.switched_sum, tibble_unique_differential_LSVs, by = c("event_region_coords", "splicemode"))

# this is the true number of exons which have underwent differential switching.
number_of_exons_differentially_switched_sum <- dplyr::semi_join(tibble_of_absolute_PSI_averages_exon.switched_sum, tibble_unique_differential_LSVs, by = c("event_region_coords", "diff_exon_coords", "splicemode")) %>% nrow

cat("there are", number_of_exons_differentially_switched_sum, "exons which undergo significant switching over the time course")

write.table(x = tibble_of_absolute_PSI_averages_exon.switched_differential_sum, file = paste(R_processing_results_dir, "wide_table_of_",  number_of_exons_differentially_switched_sum, "_switched.exons_exons.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# Clustering using self-organising maps

## separate PSI per LSV

### Filter the wide table of absolute PSI for exons with complete timeseries only
#### Then filter for differential exons.

```{r}

# get row indices which have any na.
row.indices_with_na <- apply(X = wide_tibble_of_absolute_PSI_averages_separate[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_separate), pattern = "absolute.psi")], MARGIN = 1, FUN = function(X) {any(is.na(X))})

# remove those rows that are true (that have any na)
wide_tibble_of_absolute_PSI_averages_complete.timeseries <- wide_tibble_of_absolute_PSI_averages_separate[which(row.indices_with_na == FALSE), ]
# filter for differential LSVs
wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate <- dplyr::semi_join(wide_tibble_of_absolute_PSI_averages_complete.timeseries, tibble_unique_differential_LSVs)

no.exons_differentially.spliced_complete.timeseries_separate <- nrow(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate)

cat("There are", no.exons_differentially.spliced_complete.timeseries_separate, "exons with a complete time profile of LSV-based PSI which are differentially spliced.")

# THIS IS THE FINAL TIBBLE OF ALL THE EXONS WITH A COMPLETE TIME-SERIES PSI PROFILE

```

### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# OB series #####

som_5_by_5_OBseries_table_absolute.PSI <- wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate), pattern = "absolute.psi")] %>% setNames(vector_OBseries_timepoints)

som_5_by_5_OBseries_table_scaled.PSI_separate <- som_5_by_5_OBseries_table_absolute.PSI %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_OBseries <- som(som_5_by_5_OBseries_table_scaled.PSI_separate, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries_separate <- cbind(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate[, -grep(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate), pattern = "absolute.psi")], som_5_by_5_OBseries_table_scaled.PSI_separate, "cluster" = somdata_5_by_5_OBseries[["unit.classif"]])

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries_separate <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate, id.vars = c(colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate)[-grep(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate), pattern = "absolute.psi")], "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries_separate[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries_separate[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries_separate[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster_minus_1 %/% 5

```

#### GGPLOT

all the genes

```{r}

# OB series

ggplot(long_table_of_final_SOM_summary_5_by_5_OBseries_separate, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = paste(event_region_coords, diff_exon_coords, splicemode))) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate), "LSV PSI values during OB diff (any", pvalue_or_FDR, 
               " < ", pvalue_cutoff, "any deltaPSI >", dpsi_cutoff, ")")) +
  scale_x_discrete(limits = vector_OBseries_timepoints, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", no.exons_differentially.spliced_complete.timeseries_separate, "_exons_LSV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", no.exons_differentially.spliced_complete.timeseries_separate, "_exons_LSV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries_separate, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", no.exons_differentially.spliced_complete.timeseries_separate, "_exons_LSV.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## summed PSI per exon

### Filter the wide table of absolute PSI for exons with complete timeseries only
#### Then filter for differential exons.

```{r}

# get row indices which have any na.
row.indices_with_na <- apply(X = wide_tibble_of_absolute_PSI_averages_sum[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_sum), pattern = "absolute.psi")], MARGIN = 1, FUN = function(X) {any(is.na(X))})

# remove those rows that are true (that have any na)
wide_tibble_of_absolute_PSI_averages_complete.timeseries <- wide_tibble_of_absolute_PSI_averages_sum[which(row.indices_with_na == FALSE), ]

wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum <- dplyr::semi_join(wide_tibble_of_absolute_PSI_averages_complete.timeseries, tibble_unique_differential_LSVs)

no.exons_differentially.spliced_complete.timeseries_sum <- length(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum$diff_exon_coords)

cat("There are", no.exons_differentially.spliced_complete.timeseries_sum, "exons with a complete time profile of exon-based PSI which are differentially spliced.")

# THIS IS THE FINAL TIBBLE OF ALL THE EXONS WITH A COMPLETE TIME-SERIES PSI PROFILE

```

### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# OB series #####

som_5_by_5_OBseries_table_absolute.PSI <- wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum[, grep(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum), pattern = "absolute.psi")] %>% setNames(vector_OBseries_timepoints)

som_5_by_5_OBseries_table_scaled.PSI_sum <- som_5_by_5_OBseries_table_absolute.PSI %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_OBseries <- som(som_5_by_5_OBseries_table_scaled.PSI_sum, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries_sum <- cbind(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum[, -grep(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum), pattern = "absolute.psi")], som_5_by_5_OBseries_table_scaled.PSI_sum, "cluster" = somdata_5_by_5_OBseries[["unit.classif"]])

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries_sum <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum, id.vars = c(colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)[-grep(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum), pattern = "absolute.psi")], "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value")

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries_sum[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries_sum[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries_sum[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster_minus_1 %/% 5

```

#### GGPLOT

all the genes

```{r}

# OB series

ggplot(long_table_of_final_SOM_summary_5_by_5_OBseries_sum, aes(x = timepoint, y = scaled_PSI_value)) +
  geom_line(aes(group = paste(event_region_coords, diff_exon_coords, splicemode))) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of", nrow(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum), "exon PSI values during OB diff (any", pvalue_or_FDR, 
               " < ", pvalue_cutoff, "any deltaPSI >", dpsi_cutoff, ")")) +
  scale_x_discrete(limits = vector_OBseries_timepoints, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size=0.5, linetype="solid", colour ="black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", no.exons_differentially.spliced_complete.timeseries_sum, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", no.exons_differentially.spliced_complete.timeseries_sum, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries_sum, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", no.exons_differentially.spliced_complete.timeseries_sum, "_exons_exon.PSI_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# GENE ONTOLOGY

## prepare GO catalog for the gene background

running hyperGOall in systempipeR

This gene background shall contain all ensembl protein coding, long noncoding and transcribed genes.

```{r}

# GOTERM
# polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "go_id", "namespace_1003"), mart = ensembl_mart) %>% .[.$namespace_1003 != "",]
#
# polyA_RNAseq_GO_background[, "namespace_1003"] <- as.character(polyA_RNAseq_GO_background[, "namespace_1003"])
#
# write.table(x = polyA_RNAseq_GO_background, file = paste(R_processing_results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

## Create catDB instance (takes a while but needs to be done only once)
# note: you had to save the GO annotation file to disk in the previous steps above
# catdb <- makeCATdb(myfile = paste(R_processing_results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), lib = NULL, org = "", colno = c(2, 1, 3), idconv = NULL)

```

## all exons, anysig with na.

### hypergeometric test for GO terms

```{r}

# create vector of differential genes
vector_differential_genes_anysig_with_na <- wide_tibble_of_psisigma_results_allcomparisons_differential$matched_gene_names %>% unique

# count number of differential genes
number.of.genes_differential_anysig_with_na <- vector_differential_genes_anysig_with_na %>% length

cat(number.of.genes_differential_anysig_with_na, "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation with FDR <", pvalue_cutoff, "\n")

# create list of GO categories
list_GO_categories <- c("MF", "BP", "CC") %>% array_tree

# map GO test
list_of_GO_test_tibbles_anysig_with_na_raw <- purrr::map(.x = list_GO_categories, .f = ~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = vector_differential_genes_anysig_with_na, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% type_convert) %>% set_names(list_GO_categories)

# filter out the top ~30 most significant GO terms for each node
list_of_GO_test_tibbles_anysig_with_na_top.hits <- purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_raw, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 30))

# print out the top hits of the GO enrichment
purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_top.hits, .f = ~.x %>% print)

# collapse into a long tibble for plot
long_tibble_GO_test_anysig_with_na_top.hits <- list_of_GO_test_tibbles_anysig_with_na_top.hits %>% rbindlist %>% as_tibble

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(long_tibble_GO_test_anysig_with_na_top.hits, aes(x = reorder(Term, Phyper), y = SampleMatch)) +
  geom_col(aes(fill = log(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(Ont ~ ., scales = "free") +
  ggtitle(paste("Top 30 significantly over-represented GO terms for OB series for 
                dPSI cutoff of", dpsi_cutoff, "and any sig", pvalue_or_FDR, pvalue_cutoff, "encompassing", number.of.genes_differential_anysig_with_na, "genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype="solid", colour ="black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "top_30_GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "top_30 GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 

# write table of top 30 results
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(R_processing_results_dir, "top_30_GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of every enrichment
write.table(x = list_of_GO_test_tibbles_anysig_with_na_raw %>% purrr::map(~dplyr::arrange(.x, Phyper)) %>% rbindlist, file = paste(R_processing_results_dir, "top_inf_GOterms_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

## Gene ontology of each SOM cluster, separate and summed PSI

### preparation of separate data frames containing gene sets of each cluster

at the end of this, we will get list_of_OB/OBseries_gene_tables_by_SOM_cluster which are lists containing 25 nested data frames

```{r}

# create list of SOM clusters
list_of_SOM_clusters <- 1:number_of_som_clusters %>% array_tree

# load the tibble into list by cluster
list_of_tibble_SOM.separate.PSI_subset_by_cluster <- list(purrr::map(.x = list_of_SOM_clusters, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_separate[wide_table_of_final_SOM_summary_5_by_5_OBseries_separate$cluster == .x, ]) %>% set_names(list_of_SOM_clusters), purrr::map(.x = list_of_SOM_clusters, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_sum[wide_table_of_final_SOM_summary_5_by_5_OBseries_sum$cluster == .x, ]) %>% set_names(list_of_SOM_clusters)) %>% set_names(c(paste("separate.PSI_", wide_table_of_final_SOM_summary_5_by_5_OBseries_separate$matched_gene_names %>% unique %>% length, sep = ""), paste("sum.PSI_", wide_table_of_final_SOM_summary_5_by_5_OBseries_sum$matched_gene_names %>% unique %>% length, sep = "")))

# take gene set for each cluster
list_of_vectors_genesets_per_SOM_cluster <- purrr::map_depth(.x = list_of_tibble_SOM.separate.PSI_subset_by_cluster, .depth = 2, .ragged = FALSE, .f = ~.x$matched_gene_names %>% unique)

```

### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_SOM_genes_and_GOterms <- cross2(.x = list_of_vectors_genesets_per_SOM_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_SOM_genes_and_GOterms_names <- cross2(.x = list_of_vectors_genesets_per_SOM_cluster %>% names, .y = list("MF", "BP", "CC"))

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination
list_of_tibbles_SOM_hyperGOresult_clusterwise <- future_map(.x = list_of_combinations_of_SOM_genes_and_GOterms, .f = ~purrr::map2(.x = .x[[1]], .y = .x[[2]], .f = ~GOHyperGAll(catdb = catdb, gocat = .y, Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble), .progress = TRUE)

# filter gene ontology tables for top hits
list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise, .f = ~purrr::map(.x = .x, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 10)))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# ggplot, separate PSI

# get list indices of the GO result tibbles that house the separate PSI info.

purrr::map2(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[2], "_genes_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[2], "_genes_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[2], "_genes_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Gene Ontology for the isoforms/genes with highest PSIs at every time point (separate + sum PSI)

Plan: 

1. for each OB/OB series, for each time point, filter separately for the isoforms with the top ... 10%? (depends on total no. of isoforms) PSI
2. Generate all 3 GO nodes for each timepoint
3. Append timepoint to their respective GO output tables
4. Bind rows for a total of three massive tables (one for each GO node)
5. GGPLOT

### set PSI cutoff percentages according to scaled PSI values

```{r}

high_scaled.PSI.cutoff <- 0.1

low_scaled.PSI.cutoff <- 0.1

# string to simplify the code
cutoff_string <- paste("H", high_scaled.PSI.cutoff, "L", low_scaled.PSI.cutoff, sep = "")

```

### creation of lists of NORMALISED(SCALED) PSI values of isoforms per time point

```{r}

# column names corresponding to PSI observations are just the OB series timepoints
list_of_tibbles_scaled_PSI_subset_by_timepoint <- list(list(purrr::map(.x = vector_OBseries_timepoints, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_separate[, colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate)[
  c(-which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate) %in% vector_OBseries_timepoints[vector_OBseries_timepoints != .x]), 
    -which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_separate) == "cluster"))]]) %>% set_names(vector_OBseries_timepoints), "PSI_type" = "separate.PSI"), 
                                                       list(purrr::map(.x = vector_OBseries_timepoints, .f = ~wide_table_of_final_SOM_summary_5_by_5_OBseries_sum[, colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum)[
  c(-which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum) %in% vector_OBseries_timepoints[vector_OBseries_timepoints != .x]), 
    -which(colnames(wide_table_of_final_SOM_summary_5_by_5_OBseries_sum) == "cluster"))]]) %>% set_names(vector_OBseries_timepoints), "PSI_type" = "sum.PSI"))

```

### filter for top 10% of isoforms with highest/lowest PSI

```{r}

list_of_tibbles_highest.lowest_PSI_by_timepoint <- purrr::cross2(.x = list_of_tibbles_scaled_PSI_subset_by_timepoint, .y = list("highest_PSI", "lowest_PSI")) %>% purrr::map(.x = ., .f = ~flatten(.x) %>% set_names(c("data", "PSI_type", "highest_or_lowest_PSI")))

# the result: individual tibbles with the PSI type and highest/lowest PSI alongside it
## map the highest PSI tibbles
list_of_tibbles_highest.lowest_PSI_by_timepoint <- purrr::map_if(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .p = ~.x[["highest_or_lowest_PSI"]] == "highest_PSI", .f = ~list("data" = purrr::map2(.x = .x[["data"]], .y = vector_OBseries_timepoints, .f = ~.x[order(.x[, .y], decreasing = TRUE), ] %>% head(.x, n = floor(nrow(.x) * high_scaled.PSI.cutoff))), "PSI_type" = .x[["PSI_type"]], "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))
## map the lowest PSI tibbles
list_of_tibbles_highest.lowest_PSI_by_timepoint <- purrr::map_if(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .p = ~.x[["highest_or_lowest_PSI"]] == "lowest_PSI", .f = ~list("data" = purrr::map2(.x = .x[["data"]], .y = vector_OBseries_timepoints, .f = ~.x[order(.x[, .y], decreasing = FALSE), ] %>% head(.x, n = floor(nrow(.x) * low_scaled.PSI.cutoff))), "PSI_type" = .x[["PSI_type"]], "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))

# write each highest/lowest table for use in cytoscape
future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .f = function(.x) {
  
  data <- .x$data
  timepoint_names <- names(data)
  
  PSI_type <- .x$PSI_type
  highest_or_lowest_PSI <- .x$highest_or_lowest_PSI
  
  purrr::map2(.x = data, .y = timepoint_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "table_top10_", cutoff_string, "_", highest_or_lowest_PSI, "_timepointwise_", .y, "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", PSI_type, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))
  
} )

```

### run gohypergall

```{r}

# take combinations of the so far sum/separate PSI and highest/lowest PSI with GO terms MF BP CC
list_of_tibbles_highest.lowest_PSI_by_timepoint_renamed <- purrr::cross2(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, .y = list("MF", "BP", "CC")) %>% purrr::map(.x = ., .f = ~set_names(.x, c("sum.sep_highest.lowest_data", "GO_category")) %>% flatten)

list_of_tibbles_hyperGOresult_timepointwise <- future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint_renamed, 
                                                              .f = ~list("GO_enrichment" = pmap(.l = list("data" = .x[[1]], 
                                                                                  "PSI_type" = .x[[2]], 
                                                                                  "highest_or_lowest_PSI" = .x[[3]], 
                                                                                  "GO_category" = .x[[4]],
                                                                                  "timepoint" = vector_OBseries_timepoints %>% array_tree), .f = ~GOHyperGAll(catdb = catdb, gocat = ..4, Nannot = 2, sample = ..1$matched_gene_names) %>% GOHyperGAll_benjamini_correction),
                                                                         "PSI_type" = .x[[2]],
                                                                         "highest_or_lowest_PSI" = .x[[3]],
                                                                         "GO_category" = .x[[4]]), .progress = TRUE)

```

### reprocess the list into form ameable to ggplot

```{r}

# append timepoint column to each enrichment result, arrange in ascending pvalue order, rbindlist into a long tibble
list_of_tibbles_hyperGOresult_timepointwise_topten <- purrr::map(.x = list_of_tibbles_hyperGOresult_timepointwise, .f = ~list("GO_enrichment" = map2(.x = .x[["GO_enrichment"]], .y = names(.x[["GO_enrichment"]]), .f = ~.x %>% add_column("timepoint" = .y) %>% dplyr::arrange(., Phyper) %>% head(n = 10)) %>% rbindlist %>% as_tibble, 
                                                                                    "PSI_type" = .x[["PSI_type"]],
                                                                                    "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]],
                                                                                    "GO_category" = .x[["GO_category"]]))

```


#### GGPLOT

```{r}

# a single function to call all 12 plots:
# separate/sum PSI, highest/lowest PSI cutoff, MF/BP/CC categories.

# list_of_data_tibbles <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_timepointwise, .f = ~.x$GO_enrichment)

future_map(.x = list_of_tibbles_hyperGOresult_timepointwise_topten, .f = ~ggplot(.x[["GO_enrichment"]], aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint %>% as.factor %>% fct_relevel(., vector_OBseries_timepoints), scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .x[["GO_category"]], " GO terms for the ", cutoff_string, .x[["highest_or_lowest_PSI"]], " exons in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, .x[["GO_category"]], "_GOterms_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, .x[["GO_category"]], "_GOterms_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm"), .progress = TRUE)

future_map(.x = list_of_tibbles_hyperGOresult_timepointwise_topten, .f = ~write.table(x = .x[["GO_enrichment"]], file = paste(R_processing_results_dir, .x[["GO_category"]], "_GOterms_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# protein family enrichment

goal: to conduct hypergeometric tests of overrepresentation for gene subsets in protein families

## generating enrichment catalog of PFAM protein families

```{r}

# PROTEINFAMILY
polyA_RNAseq_background_pfam <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "pfam"), mart = ensembl_mart) %>% .[.$pfam != "",]

# obtain description(definition, DE) for each PFAM ID

PFAM_all_descriptions <- as.data.frame(PFAMDE[mappedkeys(PFAMDE)]) %>% setNames(., c("pfam", "family_description"))

polyA_RNAseq_background_pfam <- dplyr::left_join(polyA_RNAseq_background_pfam, PFAM_all_descriptions, by = "pfam")

polyA_RNAseq_background_pfam[, "family_description"] <- as.character(polyA_RNAseq_background_pfam[, "family_description"])

write.table(x = polyA_RNAseq_background_pfam, file = paste(R_processing_results_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

# create list of gene UNIVERSE

reference_geneset_universe <- polyA_RNAseq_background_pfam$external_gene_name

# create list containing collections of genes under their according family descriptions

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam_2[, names(polyA_RNAseq_background_pfam_2) != "pfam"]

list_of_pfam_descriptions <- polyA_RNAseq_background_pfam_2$family_description %>% unique %>% as.list

list_of_pfam_gene_family_categories <- purrr::map(.x = list_of_pfam_descriptions, .f = ~as.list(polyA_RNAseq_background_pfam[polyA_RNAseq_background_pfam$family_description == .x, "external_gene_name"]))

names(list_of_pfam_gene_family_categories) <- list_of_pfam_descriptions

list_of_pfam_gene_family_categories <- list_of_pfam_gene_family_categories %>% purrr::map(~unlist(.x))

```

## all exons, anysig with na

### hypergeometric test for protein families

```{r}

# Hypergeometric test
tibble_pfam.enrichment_anysig_with_na_raw <- bc3net::enrichment(genes = vector_differential_genes_anysig_with_na, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], vector_differential_genes_anysig_with_na) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble

# filter out the top ~30 most significant GO terms for each node
tibble_pfam.enrichment_anysig_with_na_top.hits <- dplyr::arrange(tibble_pfam.enrichment_anysig_with_na_raw, pval) %>% head(n = 30)

print(tibble_pfam.enrichment_anysig_with_na_top.hits)

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(tibble_pfam.enrichment_anysig_with_na_top.hits, aes(x = reorder(TermID %>% as.character, pval), y = genes)) +
  geom_col(aes(fill = log(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  ggtitle(paste("Top 30 significantly over-represented PFAM families for OB series for 
                dPSI cutoff of", dpsi_cutoff, "and any sig", pvalue_or_FDR, pvalue_cutoff, "encompassing", number.of.genes_differential_anysig_with_na, "genes")) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "top_30_PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 40, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "top_30 PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 40, height = 15, units = "cm") 

# write the top hits table
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(R_processing_results_dir, "top_30_PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# also write all the hits 
write.table(x = dplyr::arrange(tibble_pfam.enrichment_anysig_with_na_raw, pval), file = paste(R_processing_results_dir, "top_inf_PFAM_families_OB_series_dPSI_", dpsi_cutoff,  "_any", pvalue_or_FDR, pvalue_cutoff, "_", number.of.genes_differential_anysig_with_na, "_genes_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_SOM_family.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_SOM_cluster, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_SOM_family.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Family enrichment for the isoforms/genes with highest PSIs at every time point (separate + sum PSI)

### run family enrichment

```{r}

list_of_tibbles_family.enrichment_timepointwise <- future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, 
                                                              .f = ~list("family_enrichment" = pmap(.l = list("data" = .x[[1]], 
                                                                                  "PSI_type" = .x[[2]], 
                                                                                  "highest_or_lowest_PSI" = .x[[3]],
                                                                                  "timepoint" = vector_OBseries_timepoints %>% array_tree), .f = ~bc3net::enrichment(genes = ..1$matched_gene_names, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], ..1$matched_gene_names) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble),
                                                                         "PSI_type" = .x[[2]],
                                                                         "highest_or_lowest_PSI" = .x[[3]]), .progress = TRUE)

```

### reprocess the list into form ameable to ggplot

```{r}

# append timepoint column to each enrichment result, arrange in ascending pvalue order, rbindlist into a long tibble
list_of_tibbles_family.enrichment_timepointwise_topten <- purrr::map(.x = list_of_tibbles_family.enrichment_timepointwise, .f = ~list("family_enrichment" = map2(.x = .x[["family_enrichment"]], .y = names(.x[["family_enrichment"]]), .f = ~.x %>% add_column("timepoint" = .y) %>% dplyr::arrange(., pval) %>% head(n = 10)) %>% rbindlist %>% as_tibble, 
                                                                                    "PSI_type" = .x[["PSI_type"]],
                                                                                    "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))

```

#### GGPLOT

```{r}

# a single function to call all 12 plots:
# separate/sum PSI, highest/lowest PSI cutoff, MF/BP/CC categories.

# list_of_data_tibbles <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_timepointwise, .f = ~.x$GO_enrichment)

future_map(.x = list_of_tibbles_family.enrichment_timepointwise_topten, .f = ~ggplot(.x[["family_enrichment"]], aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint %>% as.factor %>% fct_relevel(., vector_OBseries_timepoints), scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented protein families for the ", cutoff_string, .x[["highest_or_lowest_PSI"]], " exons in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "family.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "family.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm"), .progress = TRUE)

future_map(.x = list_of_tibbles_family.enrichment_timepointwise_topten, .f = ~write.table(x = .x[["family_enrichment"]], file = paste(R_processing_results_dir, "family.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# ENRICHMENT OF SPLICING FACTORS - didnt work

## Generate table of all the mRNA sequences of all annotated transcripts

- mRNA sequences: UNSPLICED, for,
- Genes: ANYSIG

```{r eval=FALSE, include=FALSE}

anysig_all_mrna_seqs <- getBM(filters = "external_gene_name", values = wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible$Gene, attributes = c("external_gene_name", "ensembl_transcript_id", "transcript_exon_intron"), mart = ensembl_mart) %>% as_tibble

```

## generate lists of target genes containing motifs of splicing factors

use regex lmao

```{r eval=FALSE, include=FALSE}

RBM41_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "(A|T)TAC(A|T)TT")), "external_gene_name"] %>% unique

print(nrow(RBM41_binding_motif_containing_genes))

SRSF2_binding_motif_containing_genes <- anysig_all_mrna_seqs[which(grepl(x = anysig_all_mrna_seqs$transcript_exon_intron, pattern = "AGGAG(A|T)(G|A|T)")), "external_gene_name"] %>% unique

print(nrow(SRSF2_binding_motif_containing_genes))

wide_table_of_final_SOM_summary_5_by_5_OBseries_AS_plausible$Gene %>% unique %>% length %>% print

print("rip")

```

## import MBNL (HiTS-CLiP) and SRSF (FLASH-Seq) data and match with GTF information

### set directories

```{r}

clipseq_dir <- "Z:/isoform_usage_project/CLIPseq_files/"

FLASHseq_dir <- "Y:/2019_FLASHseq/results/R_processing_results/"

```

### prepare geneset categories

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
                                               
  "SRSF1 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR1-SRSF1.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF2 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR5-SRSF2.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF3 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR8-SRSF3.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF4 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR9-SRSF4.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF5 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR10-SRSF5.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF6 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR11-SRSF6.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF7 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR12-SRSF7.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF9 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR13-SRSF9.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF11 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR14-SRSF11.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_SOM_cluster, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[2], "_exons_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## enrichment of upstream RBPs - timepointwise, per gene

### perform enrichment step

```{r}

list_of_tibbles_upstream.RBP.enrichment_timepointwise <- future_map(.x = list_of_tibbles_highest.lowest_PSI_by_timepoint, 
                                                              .f = ~list("family_enrichment" = pmap(.l = list("data" = .x[[1]], 
                                                                                  "PSI_type" = .x[[2]], 
                                                                                  "highest_or_lowest_PSI" = .x[[3]],
                                                                                  "timepoint" = vector_OBseries_timepoints %>% array_tree), .f = ~bc3net::enrichment(genes = ..1$matched_gene_names, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], ..1$matched_gene_names) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble),
                                                                         "PSI_type" = .x[[2]],
                                                                         "highest_or_lowest_PSI" = .x[[3]]), .progress = TRUE)

```

### reprocess the list into form amenable to ggplot

```{r}

# append timepoint column to each enrichment result, arrange in ascending pvalue order, rbindlist into a long tibble
list_of_tibbles_upstream.RBP.enrichment_timepointwise_topten <- purrr::map(.x = list_of_tibbles_upstream.RBP.enrichment_timepointwise, .f = ~list("family_enrichment" = map2(.x = .x[["family_enrichment"]], .y = names(.x[["family_enrichment"]]), .f = ~.x %>% add_column("timepoint" = .y) %>% dplyr::arrange(., pval) %>% head(n = 10)) %>% rbindlist %>% as_tibble, 
                                                                                    "PSI_type" = .x[["PSI_type"]],
                                                                                    "highest_or_lowest_PSI" = .x[["highest_or_lowest_PSI"]]))

```

### ggplot

```{r}

# a single function to call all 12 plots:
# separate/sum PSI, highest/lowest PSI cutoff, MF/BP/CC categories.

# list_of_data_tibbles <- purrr::map(.x = list_of_tibbles_SOM_hyperGOresult_timepointwise, .f = ~.x$GO_enrichment)

future_map(.x = list_of_tibbles_upstream.RBP.enrichment_timepointwise_topten, .f = ~ggplot(.x[["family_enrichment"]], aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P["b-hoch"])), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~timepoint %>% as.factor %>% fct_relevel(., vector_OBseries_timepoints), scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for the ", cutoff_string, .x[["highest_or_lowest_PSI"]], " exons in each OB timepoint")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "upstream.RBP.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "upstream.RBP.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm"), .progress = TRUE)

future_map(.x = list_of_tibbles_upstream.RBP.enrichment_timepointwise_topten, .f = ~write.table(x = .x[["family_enrichment"]], file = paste(R_processing_results_dir, "upstream.RBP.enrichment_top10_", cutoff_string, "_", .x[["highest_or_lowest_PSI"]], "_eachtimepoint_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_", .x[["PSI_type"]], ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# COMBINING GENE EXPRESSION DATA WITH THE SPLICEOMIC DATA HERE

## set environment

set directories

```{r}

# the EXACT path of the file, not its containing directory

logCPM_OBseries_anysig_DEGs_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_2_eRNA/R_processing_results/edgeR_GLM_DEGs_logCPM.txt"

```

define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

## extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

logCPM_OBseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_OBseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_OBseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_OBseries_anysig_DEGs <- dplyr::right_join(ENSG_to_genesymbol_DEGs, logCPM_OBseries_anysig_DEGs_import, by = "ensembl_gene_id") %>% average_counts_from_triplicate(., 2)

# reorder the columns to make them chronological

logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_OB_ud_avg", "logCPM_BM_MSC_to_OB_6h_avg", "logCPM_BM_MSC_to_OB_12h_avg", "logCPM_BM_MSC_to_OB_24h_avg", "logCPM_BM_MSC_to_OB_3d_avg", "logCPM_BM_MSC_to_OB_6d_avg", "logCPM_BM_MSC_to_OB_9d_avg", "logCPM_BM_MSC_to_OB_12d_avg")]

colnames(logCPM_OBseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

# subset CPM table by biological role

  # RBPs
column_RBP_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "RNA binding" | .$name_1006 == "spliceosomal complex", "ensembl_gene_id"]

logCPM_OBseries_RBP <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_RBP_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # lncRNA
column_lncRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("lncRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble

logCPM_OBseries_lncRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_lncRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # snRNA
column_snRNA_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("snRNA", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = "ensembl_gene_id", mart = ensembl_mart) %>% as_tibble %>% mutate_if(is.logical, as.character)

logCPM_OBseries_snRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_snRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # all TF complex 
column_TFcomplex_genes_OBseries <- getBM(filters = c("biotype", "ensembl_gene_id"), values = list("protein_coding", logCPM_OBseries_anysig_DEGs$ensembl_gene_id), attributes = c("ensembl_gene_id", "name_1006"), mart = ensembl_mart) %>% as_tibble %>% .[.$name_1006 == "transcription factor complex", "ensembl_gene_id"]

logCPM_OBseries_TFcomplex <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_TFcomplex_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_OBseries_subset <- dplyr::bind_rows(logCPM_OBseries_RBP, logCPM_OBseries_lncRNA, logCPM_OBseries_snRNA, logCPM_OBseries_TFcomplex)

# get rid of ENSG id
logCPM_OBseries_subset <- logCPM_OBseries_subset[, -1]

# rename column before next join

colnames(logCPM_OBseries_subset)[1] <- "matched_gene_names"

# combine logCPM and PSI values
list_of_tibbles_combinedexpr_logCPM_PSI_unscaled <- list("combinedexpr_logCPM_PSI_separate" = dplyr::bind_rows(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate %>% setNames(gsub(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate), pattern = "_absolute.psi_average", replacement = "")) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character), logCPM_OBseries_subset) %>% add_column("identifier" = paste(.$database_ID, "/", .$event_region_coords, "/", .$splicemode, "/", .$diff_exon_coords, sep = "")),
                                                         "combinedexpr_logCPM_PSI_sum" = dplyr::bind_rows(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum %>% setNames(gsub(x = colnames(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum), pattern = "_absolute.psi_average", replacement = "")) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character), logCPM_OBseries_subset) %>% add_column("identifier" = paste(.$event_region_coords, "/", .$splicemode, "/", .$diff_exon_coords, sep = "")))

```

## consensus re-clustering of combined expression and PSI data

### execute ensemble SOM and create consensus matrix

```{r}

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7)
ydim_range_combinedexpr <- c(8, 9, 10, 11, 6, 7, 8, 5, 6, 7, 4, 5, 4)

som_seed_number <- 7

list_of_tibbles_combinedexpr_logCPM_PSI_scaled <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_unscaled, .f = function(.x) {
  
  tibble_combinedexpr <- .x
  
  tibble_combinedexpr[, c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")] <- tibble_combinedexpr[, c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")] %>% genescale(m = ., axis = 1, method = "Z")
  
  return(tibble_combinedexpr)
  
})

# LAST TIME ENSEMBL CHANGED HALFWAY THRU THE ANALYSIS. IM NOT REPEATING THAT MISTAKE AGAIN

purrr::map2(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .y = names(list_of_tibbles_combinedexpr_logCPM_PSI_scaled), .f = ~write.table(.x, paste(R_processing_results_dir, "tibble", .y, "_GRCh38.99.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE, col.names = TRUE))

# list_of_tibbles_combinedexpr_logCPM_PSI_scaled <- purrr::map(.x = names(list_of_tibbles_combinedexpr_logCPM_PSI_scaled), .f = ~read_delim(paste(R_processing_results_dir, "tibble", .y, "_GRCh38.99.txt", sep = ""), delim = "\t"))

set.seed(som_seed_number)

list_of_wide_tibbles_combinedexpr_som_sweep_clusters <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .f = function(.x) {
  
  tibble_combinedexpr_logCPM_PSI_scaled <- .x
  
  # calculate the cluster membership for each iteration of the SOM
  purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~som(tibble_combinedexpr_logCPM_PSI_scaled[, c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")] %>% as.matrix, grid = somgrid(xdim = .x, ydim = .y, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)) %>% 
    purrr::reduce(bind_cols)
  
})

# set rownames to be the gene_identifier_ID
list_of_wide_df_combinedexpr_som_sweep_clusters <- purrr::map2(.x = list_of_wide_tibbles_combinedexpr_som_sweep_clusters, .y = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .f = function(.x, .y) {
  
  df <- .x %>% as.data.frame
  rownames(df) <- paste(.y$matched_gene_names, "_", .y$identifier, sep = "")
  
  return(df)
  
})

list_matchtest_combinedexpr_som_sweep_byisoform <- purrr::map(.x = list_of_wide_df_combinedexpr_som_sweep_clusters, .f = function(.x) {
  
  # DEBUG ###
  
  # df_of_membership <- list_of_wide_df_combinedexpr_som_sweep_clusters[[1]]
  
  ###########
  
  df_of_membership <- .x
  
  list_of_clusters <- purrr::map(.x = df_of_membership %>% array_tree, .f = ~base::unlist(.x)) 
  
  list_of_correlation_2 <- furrr::future_map(.x = list_of_clusters, .f = ~base::apply(X = df_of_membership, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("list_of_clusters", "df_of_membership")))
  
  return(list_of_correlation_2)
  
})

list_percentage_consensus_byisoform_combinedexpr <- purrr::map(.x = list_matchtest_combinedexpr_som_sweep_byisoform, .f = function(.x) {
  
  list_logical_coclustering_test <- .x
  
  list_percentage_consensus <- furrr::future_map(.x = list_logical_coclustering_test, .f = ~base::apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("list_logical_coclustering_test", "as_tibble")))
  
  return(list_percentage_consensus)
  
})

list_of_tables_consensus_matrix_combinedexpr <- purrr::map(.x = list_percentage_consensus_byisoform_combinedexpr, .f = ~.x %>% rbindlist)

list_of_consensus_matrices_combinedexpr <- purrr::map2(.x = list_of_tables_consensus_matrix_combinedexpr, .y = list_percentage_consensus_byisoform_combinedexpr, .f = function(.x, .y) {
  
  matrix <- .x %>% as.matrix
  
  rownames(matrix) <- names(.y)
  
  return(matrix)
  
})

# 2D clustering of consensus matrix
## create hclust dist matrix
list_of_consensus_matrices_combinedexpr_dist_result <- furrr::future_map(.x = list_of_consensus_matrices_combinedexpr, .f = ~.x %>% Rfast::Dist(method = "euclidean") %>% as.dist, .progress = TRUE, .options = future_options(globals = c("Rfast", "list_of_consensus_matrices_combinedexpr")))
## cluster based on distance matrix per row
list_of_consensus_matrices_combinedexpr_hclust_result <- purrr::map(.x = list_of_consensus_matrices_combinedexpr_dist_result, .f = ~fastcluster::hclust(.x, method = "ward.D2"))
## create dendrogram
list_of_consensus_matrices_combinedexpr_consensus_dendrogram <- purrr::map(.x = list_of_consensus_matrices_combinedexpr_hclust_result, .f = ~as.dendrogram(.x))
## reorder rows
# cols/rows should get darker as you move right/down
list_consensus_matrices_combinedexpr_rowmeans <- purrr::map(.x = list_of_consensus_matrices_combinedexpr, .f = ~rowMeans(.x, na.rm = T))
# matrix_consensus_matrix_combinedexpr_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix_combinedexpr) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_combinedexpr_singular_vectors_byrow <- apply(matrix_consensus_matrix_combinedexpr, 1 , FUN = function(X) {svd(X) %>% .$d})

list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered <- purrr::map2(.x = list_of_consensus_matrices_combinedexpr_consensus_dendrogram, .y = list_consensus_matrices_combinedexpr_rowmeans, .f = ~reorder(.x, .y))

purrr::pmap(.l = list(list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered, 
                      names(list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), 
            .f = ~ggdendrogram(..1) +
  xlab("Gene/isoform") +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "dendrogram_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE))

# extract the order of dendrogram
list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered_order <- list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered %>% purrr::map(~unlist(.x))
# reorder both the rows and columns of the consensus matrix according to the dendrogram order
list_consensus_matrices_combinedexpr_reordered <- purrr::map2(.x = list_of_consensus_matrices_combinedexpr, .y = list_consensus_matrices_combinedexpr_consensus_dendrogram_reordered_order, .f = ~.x[.y, .y] %>% as_tibble(rownames = "gene_isoform_ID"))
# melt the reordered consensus matrix into a long tibble
list_tibble_consensus_matrix_combinedexpr_long <- list_consensus_matrices_combinedexpr_reordered %>% purrr::map(~reshape2::melt(.x, id = c("gene_isoform_ID"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_if(is.factor, as.character))

# write the tibbles
purrr::pmap(.l = list(list_consensus_matrices_combinedexpr_reordered, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~write.table(x = ..1, file = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

# plot the heatmaps
purrr::pmap(.l = list(list_tibble_consensus_matrix_combinedexpr_long, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~ggplot(..1, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("OBseries consensus matrix for som of ", nrow(..3), " exons, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", pvalue_or_FDR, pvalue_cutoff, " dPSI greaterthan ", dpsi_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_y_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_fill_gradientn(colours = c("blue", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_blank(), legend.title.align = 0.5, axis.text.y = element_blank(), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica"), panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
  ggsave(filename = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".png", sep = ""), device = "png", dpi = 300, width = 20, height = 15, units = "cm", limitsize = FALSE))

# plot heatmap data
purrr::pmap(.l = list(list_tibble_consensus_matrix_combinedexpr_long, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~write.table(x = ..1, file = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

# plot the heatmap axes text
purrr::pmap(.l = list(list_tibble_consensus_matrix_combinedexpr_long, 
                      names(list_consensus_matrices_combinedexpr_reordered), 
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~ggplot(..1 %>% dplyr::distinct(., gene_isoform_ID, .keep_all = TRUE), aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = gene_isoform_ID, y = variable)) +
  ggtitle(paste("OBseries consensus matrix for som of ", nrow(..3), " exons, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", pvalue_or_FDR, pvalue_cutoff, " dPSI greaterthan ", dpsi_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_y_discrete(breaks = ..1$gene_isoform_ID %>% unique, labels = ..1$gene_isoform_ID %>% unique, limits = ..1$gene_isoform_ID %>% unique) +
  scale_fill_gradientn(colours = c("blue", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "heatmap_consensus_matrix_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".pdf", sep = ""), device = "pdf", dpi = 1200, width = 40, height = 25, units = "cm", limitsize = FALSE))

```

### cluster determination from consensus matrix

```{r message=FALSE, warning=FALSE}

# tibble_consensus_matrix_combinedexpr_long <- read_delim(paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), delim = "\t")

list_genes_or_exons_from_combinedexpr <- list_tibble_consensus_matrix_combinedexpr_long %>% purrr::map(~.x$variable %>% unique %>% array_tree)

# for each genes_identifier ID, group up those which have a cocluster percentage of more than 0.5
list_genes_or_exons_from_combinedexpr_cooccuring <- purrr::map2(.x = list_genes_or_exons_from_combinedexpr, .y = list_tibble_consensus_matrix_combinedexpr_long, .f = function(.x, .y) {
  
  gene_identifier_IDs <- .x
  consensus_scores <- .y
  
  list_of_coclustered_IDs <- future_map(.x = gene_identifier_IDs, .f = ~consensus_scores[consensus_scores$variable == .x & consensus_scores$cocluster_percentage >= 0.5, "gene_isoform_ID"], .progress = TRUE, .options = future_options(globals = c("gene_identifier_IDs", "consensus_scores")))
  
  names(list_of_coclustered_IDs) <- gene_identifier_IDs
  
  return(list_of_coclustered_IDs)
  
})

# take pairwise intersections
list_pairwise_comparisons_genes_or_exons_from_combinedexpr <- future_map(.x = list_genes_or_exons_from_combinedexpr, .f = function(.x) {
  
  tibble_comparisons <- combn(.x %>% unlist, m = 2) %>% t %>% as_tibble %>% setNames(c("comparison_1", "comparison_2"))
  
  list_comparisons <- list("list_comparison_1" = tibble_comparisons[, "comparison_1"] %>% array_tree, "list_comparison_2" = tibble_comparisons[, "comparison_2"] %>% array_tree)
  
  return(list_comparisons)
  
}, .progress = TRUE, .options = future_options(globals = c("as_tibble", "list_genes_or_exons_from_combinedexpr")))

# NOTE: EACH L1 ELEMENT OF THE FOLLOWING LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.
list_genes_or_isoforms_from_combinedexpr_itemwise_intersection <- purrr::map2(.x = list_pairwise_comparisons_genes_or_exons_from_combinedexpr, .y = list_genes_or_exons_from_combinedexpr_cooccuring, .f = function(.x, .y) {
  
  # DEBUG ###
  
  # gene_identifier_ID <- list_pairwise_comparisons_genes_or_exons_from_combinedexpr[[1]]
  
  ###########
  
  gene_identifier_ID <- .x
  genes_or_exons_from_combinedexpr_cooccuring <- .y
  
  list_intersection <- future_map2(.x = gene_identifier_ID[["list_comparison_1"]] %>% set_names(NULL), .y = gene_identifier_ID[["list_comparison_2"]] %>% set_names(NULL), .f = ~dplyr::intersect(genes_or_exons_from_combinedexpr_cooccuring[[.x]], genes_or_exons_from_combinedexpr_cooccuring[[.y]]) %>% length, .progress = TRUE) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")
  
  return(list_intersection)
  
})

# .options = future_options(globals = c("dplyr", "genes_or_exons_from_combinedexpr_cooccuring"))

list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff <- purrr::map2(.x = list_pairwise_comparisons_genes_or_exons_from_combinedexpr, .y = list_genes_or_exons_from_combinedexpr_cooccuring, .f = function(.x, .y) {
  
  # DEBUG ###
  
  # gene_identifier_ID <- list_pairwise_comparisons_genes_or_exons_from_combinedexpr[[1]]
  
  ###########
  
  gene_identifier_ID <- .x
  genes_or_exons_from_combinedexpr_cooccuring <- .y
  
  list_setdiff <- future_map2(.x = gene_identifier_ID[["list_comparison_1"]] %>% set_names(NULL), .y = gene_identifier_ID[["list_comparison_2"]] %>% set_names(NULL), .f = ~dplyr::setdiff(genes_or_exons_from_combinedexpr_cooccuring[[.x]], genes_or_exons_from_combinedexpr_cooccuring[[.y]]) %>% length, .progress = TRUE) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")
  
  return(list_setdiff)
  
})

# append the intersection and setdiff as new columns onto the pairwise comparison
list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- purrr::pmap(.l = list(list_pairwise_comparisons_genes_or_exons_from_combinedexpr,
                                                                                          list_genes_or_isoforms_from_combinedexpr_itemwise_intersection,
                                                                                          list_genes_or_isoforms_from_combinedexpr_itemwise_setdiff), .f = ~bind_cols(..1 %>% as_tibble, ..2[, 1], ..3[, 1]) %>% add_column("jaccard" = .$coclustering_intersection/(.$coclustering_setdiff + .$coclustering_intersection)) %>% purrr::map(~unlist(.x)) %>% as_tibble)

# write the tables  - all intersection values
purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "itemwise_anyintersection_consensus0.5_", .y, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

# read the table back
# list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2 <- purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2), .f = ~read_delim(paste(R_processing_results_dir, "itemwise_anyintersection_consensus0.5_", .y, ".txt", sep = ""), delim = "\t"))

list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3 <- purrr::map(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_2, .f = ~.x[.x$coclustering_intersection > 0, ])

# plot intersection distribution
purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3), .f = function(.x, .y) {
  
  pdf(paste(R_processing_results_dir, "itemwise_intersection1_consensus0.5_", .y, "_consensus.distribution.pdf", sep = ""))
  
  plot(density(.x$coclustering_intersection %>% as.numeric), main = paste("intersection score distribution for", .y))
  
  dev.off()
  
})

# write the tables - nonzero intersection values only
purrr::map2(.x = list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3, .y = names(list_genes_or_isoforms_from_combinedexpr_itemwise_intersection_3), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "itemwise_intersection1_consensus0.5_", .y, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### GO TO CYTOSCAPE HERE

```{r}

########### RETURN FROM CYTOSCAPE HERE ###################

# import the cluster membership info
list_cytoscape_result <- purrr::map(.x = list("consensus_separate.PSI_combinedexpr_intersection1_min25_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab",
                                              "consensus_sum.PSI_combinedexpr_intersection1_min25_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab"), .f = function(.x) {
                                                
                                                tibble_result <- read_delim(paste(R_processing_results_dir, .x, sep = ""), delim = "\t", col_names = c("cluster", "gene_identifier_ID"))
                                                tibble_result[, "cluster"] <- gsub(x = tibble_result$cluster, pattern = "Cluster ", replacement = "") %>% as.numeric
                                                
                                                return(tibble_result)
                                                
                                              } )

# append the gene_identifier_ID onto the tibble of combined scaled PSI and expr
list_of_tibbles_combinedexpr_logCPM_PSI_scaled_2 <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled, .f = ~bind_cols(.x, gene_identifier_ID = paste(.x$matched_gene_names, "_", .x$identifier, sep = "")))

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_results_by_cluster <- purrr::map(.x = list_cytoscape_result, .f = function(.x) {
  
  tibble_result <- .x
  
  purrr::map(.x = tibble_result$cluster %>% unique, .f = ~tibble_result[tibble_result$cluster == .x, ])
  
} ) %>% set_names(names(list_of_tibbles_combinedexpr_logCPM_PSI_scaled_2))

# bind the standardised PSI information to the cluster information
list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered <- purrr::map2(.x = list_cytoscape_results_by_cluster, .y = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_2, .f = function(.x, .y) {
  
  cytoscape_results_by_cluster <- .x
  tibbles_combinedexpr_logCPM_PSI_scaled_2 <- .y
  
  list_of_tibbles_with_cluster_info_by_cluster <- purrr::map(.x = cytoscape_results_by_cluster, .f = ~dplyr::left_join(.x, tibbles_combinedexpr_logCPM_PSI_scaled_2, by = "gene_identifier_ID"))
  
  tibble_with_cluster_info <- list_of_tibbles_with_cluster_info_by_cluster %>% purrr::reduce(dplyr::bind_rows)
  
  # reorder columns
  tibble_with_cluster_info <- tibble_with_cluster_info[, c(2:ncol(tibble_with_cluster_info), 1)]
  
  # reorder the cluster factor for correct facet order
  tibble_with_cluster_info$cluster <- factor(tibble_with_cluster_info$cluster %>% mixedsort, levels = tibble_with_cluster_info$cluster %>% unique %>% mixedsort)
  
  return(tibble_with_cluster_info)
  
} )

```

### generate expression profile map

the goal of this is to get extract timepoint PSI/expr tables according to each consensus cluster

```{r}

### convert the som table to a long form interprable by ggplot

# reshaping into long table
list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, .f = function(.x) {
  
  id.colnames <- setdiff(colnames(.x), c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d"))
  
  long_tibble <- reshape2::melt(.x, id.vars = id.colnames, variable.name = "timepoint", value.name = "scaled_PSI.expr_value") %>% as_tibble
  
  return(long_tibble)
  
} )

# GGPLOT
purrr::pmap(.l = list(list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, 
                      names(list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered),
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~ggplot(..1, aes(x = timepoint, y = scaled_PSI.expr_value)) +
  geom_line(aes(group = gene_identifier_ID)) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("OBseries consensus SOM of ", nrow(..3), " exons, 
                ", nrow(logCPM_OBseries_RBP), " RBPs, ", nrow(logCPM_OBseries_lncRNA), " lncRNAs, ", nrow(logCPM_OBseries_snRNA), " snRNAs, ", nrow(logCPM_OBseries_TFcomplex), " TFcomplexes", " 
                (any ", pvalue_or_FDR, pvalue_cutoff, " dPSI greaterthan ", dpsi_cutoff, "), sweep from ", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), " to ", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Normalised PSI or expr. Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm", limitsize = FALSE))

purrr::pmap(.l = list(list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, 
                      names(list_of_long_tibbles_combinedexpr_logCPM_PSI_scaled_clustered),
                      list(wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_separate, wide_tibble_of_absolute_PSI_averages_complete.timeseries_differential_sum)), .f = ~write.table(x = ..1, file = paste(R_processing_results_dir, "consensus_som_", nrow(..3), "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", ..2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Gene ontology of each SOM cluster, separate and summed PSI

#### preparation of separate data frames containing gene sets of each cluster

```{r}

# create list of SOM clusters
list_of_SOM_clusters <- purrr::map(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, .f = ~.x$cluster %>% paste %>% unique %>% array_tree)

list_of_tibble_consensus.SOM_separate.PSI_subset_by_cluster <- purrr::map2(.x = list_of_tibbles_combinedexpr_logCPM_PSI_scaled_clustered, .y = list_of_SOM_clusters, .f = function(.x, .y) {
  
  wide_tibble_summary <- .x %>% mutate_if(is.factor, as.character)
  SOM_clusters <- .y
  
  list_of_subset_tibbles_by_cluster <- purrr::map(.x = SOM_clusters, .f = ~wide_tibble_summary[wide_tibble_summary$cluster == .x, ]) %>% set_names(SOM_clusters)
  
} ) %>% set_names(c(paste("separate.PSI_expr_", wide_table_of_final_SOM_summary_5_by_5_OBseries_separate$matched_gene_names %>% unique %>% length, sep = ""), 
                    paste("sum.PSI_expr_", wide_table_of_final_SOM_summary_5_by_5_OBseries_sum$matched_gene_names %>% unique %>% length, sep = "")))

# take gene set for each cluster - all expr and PSI genes
list_of_vectors_genesets_per_consensus.SOM_cluster_all <- purrr::map_depth(.x = list_of_tibble_consensus.SOM_separate.PSI_subset_by_cluster, .depth = 2, .ragged = FALSE, .f = ~.x$matched_gene_names %>% unique)

# take gene set for each cluster - all PSI genes only
list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly <- purrr::map_depth(.x = list_of_tibble_consensus.SOM_separate.PSI_subset_by_cluster, .depth = 2, .ragged = FALSE, .f = ~.x[.x$splicemode != "RNASeq", "matched_gene_names"] %>% unlist %>% unique)

```

#### GO enrichment

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_consensus.SOM_genes_and_GOterms <- cross2(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_consensus.SOM_genes_and_GOterms_names <- cross2(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly %>% names, .y = list("MF", "BP", "CC"))

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map(.x = list_of_combinations_of_consensus.SOM_genes_and_GOterms, .f = ~purrr::map2(.x = .x[[1]], .y = .x[[2]], .f = ~GOHyperGAll(catdb = catdb, gocat = .y, Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble), .progress = TRUE)

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise, .f = ~purrr::map(.x = .x, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 10)))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# ggplot, separate PSI
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(R_processing_results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

# REPEAT OF ANAYSES WITH PLAUSIBLE AS EVENTS ONLY

## filtering out all the implausible AS events

```{r}

# function to fetch maximum AA length of each protein coding gene. AS regions cant be longer than this. very difficult to filter. in my experience, most exons are at most 200 nt but ok
filtering_chr_strand_start_end_tibble_for_plausible_AS_events <- function(tibble_chr_strand_start_end) {
  
  # DEBUG ###
  # tibble_chr_strand_start_end <- tibble_all_diff_exons_chr_strand_start_end
  ###########
  
  a <- getBM(filters = "external_gene_name", values = tibble_chr_strand_start_end$Gene, attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart)
  b <- a %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length))
  colnames(b) <- c("Gene", "transcript_length")
  c <- dplyr::left_join(tibble_chr_strand_start_end, b, by = "Gene")
  d <- c %>% dplyr::filter(width < transcript_length, .preserve = TRUE)
  # retained introns and entire composite structures can be long. the other 4 have no excuse. the longest exon known in existence is 11555 bp long.
  e <- d %>% dplyr::filter(width <= 11555) %>% unique
  # e contains the final list of isoforms which have plausible AS length.
  print(paste(nrow(e), "unique genes with plausible AS length after filtering"))
  
  return(e)
  
}

## END filtering_chr_strand_start_end_tibble_for_plausible_AS_events

```

## filter all tables for plausible

```{r}
# 
# # differential info table
# wide_tibble_of_psisigma_results_allcomparisons_differential
# 
# 
# # constitutive info table
# tibble_constitutive_LSV_info

```

# Quality checks

## Set directory

```{r}

qualitycheck_results_dir <- paste(R_processing_results_dir, "qualitycheck/", sep = "")

if(! dir.exists(qualitycheck_results_dir) ) {
     dir.create(qualitycheck_results_dir, recursive = TRUE)}

```

## graph distributions of p-values

```{r}

# plot pvalue
pdf(paste(qualitycheck_results_dir, "qualityplot_pvalues_density.distribution.pdf", sep = "")) 
  
  plot(density(wide_tibble_of_psisigma_results_allcomparisons_final[, "pvalue"] %>% na.omit %>% unlist), xlab = "pvalue", ylab = "frequency density", main = "PSI-Sigma p-value density distribution")
  
dev.off()

pdf(paste(qualitycheck_results_dir, "qualityplot_pvalues_CDF.pdf", sep = "")) 
  
  plot(ecdf(wide_tibble_of_psisigma_results_allcomparisons_final[, "pvalue"] %>% na.omit %>% unlist), xlab = "pvalue", ylab = "cumulative frequency", main = "PSI-Sigma p-value CDF")
  
dev.off()
  
vector_col.index_absolute.psi.comparison.1 <- grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_final), pattern = "comparison.1_")
vector_col.index_absolute.psi.comparison.2 <- grep(x = colnames(wide_tibble_of_psisigma_results_allcomparisons_final), pattern = "comparison.2_")

# plot all the absolute PSI values
plot(density(wide_tibble_of_psisigma_results_allcomparisons_final[wide_tibble_of_psisigma_results_allcomparisons_final$comparison == "BM_MSC_to_OB_12d_vs_BM_MSC_to_OB_12h" & wide_tibble_of_psisigma_results_allcomparisons_final$pvalue < 0.4 & wide_tibble_of_psisigma_results_allcomparisons_final$pvalue > 0.35, c(1, vector_col.index_absolute.psi.comparison.1, vector_col.index_absolute.psi.comparison.2)] %>% melt(.,id.vars = "database_ID", variable.name = "comparison.replicate", value.name = "absolute.psi") %>% .$absolute.psi %>% na.omit), main = "distribution of PSI values for comparisons with a p value of \n between 0.35 and 0.4")
  
# plot dpsi distribution
pdf(paste(qualitycheck_results_dir, "qualityplot_dpsi_density.distribution.pdf", sep = "")) 
  
  plot(density(wide_tibble_of_psisigma_results_allcomparisons_final[, "dpsi"] %>% na.omit %>% unlist), xlab = "dpsi", ylab = "frequency density", main = "PSI-Sigma dpsi frequency density")
  
dev.off()

pdf(paste(qualitycheck_results_dir, "qualityplot_dpsi_CDF.pdf", sep = "")) 
  
  plot(ecdf(wide_tibble_of_psisigma_results_allcomparisons_final[, "dpsi"] %>% na.omit %>% unlist), xlab = "dpsi", ylab = "cumulative frequency", main = "PSI-Sigma dpsi CDF")
  
dev.off()

```

## check for whether there is any dependence of number of exons detected vs. coverage - CURRENTLY NOT POSSIBLE!

```{r eval=FALSE, include=FALSE}

# number_of_junctions_detected_per_sample <- read.delim(paste(qualitycheck_results_dir, "number_of_junctions_detected_per_sample.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE) %>% as_tibble
# 
# coveragedata <- read.delim(paste(qualitycheck_results_dir, "coveragedata.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble
# 
# num_junctions_vs_coverage <- dplyr::inner_join(number_of_junctions_detected_per_sample, coveragedata, by = "timepoint_name")
# 
# num_junctions_vs_coverage_pearson <- cor(num_junctions_vs_coverage[, 2], num_junctions_vs_coverage[, 3], method = "pearson") %>% signif(4)
# 
# num_junctions_vs_coverage_gradient <- lm(formula = junction_counts ~ read_count, num_junctions_vs_coverage) %>% .[[1]] %>% .[2] %>% signif(digits = 4)
# 
# num_junctions_vs_coverage_intercept <- lm(formula = junction_counts ~ read_count, num_junctions_vs_coverage) %>% .[[1]] %>% .[1] %>% signif(4)
# 
# ggplot(num_junctions_vs_coverage, aes(y = junction_counts, x = read_count)) +
#   geom_point() +
#   geom_smooth(method = "lm", formula = y~x, colour = "blue") +
#   annotate(geom = "text", label = bquote("R"^2 ~ "=" ~ .(num_junctions_vs_coverage_pearson)), x = 3.75e7, y = 244000, color = "blue") +
#   annotate(geom = "text", label = bquote("y =" ~ .(num_junctions_vs_coverage_gradient) ~ "x +" ~ .(num_junctions_vs_coverage_intercept)), x = 3.75e7, y = 240000, color = "blue") +
#   ggtitle(paste("plot_of_number_of_junctions_per_sample_vs_coverage_OBseries", sep = "")) +
#   xlab("Sequencing Depth") +
#   ylab("Number of splice junctions detected") +
#   theme_bw() +
#   theme(text = element_text(family = "Helvetica")) +
#   ggsave(filename = paste(qualitycheck_results_dir, "plot_of_number_of_junctions_per_sample_vs_coverage_OBseries", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 15, height = 15, units = "cm") +
#   ggsave(filename = paste(qualitycheck_results_dir, "plot_of_number_of_junctions_per_sample_vs_coverage_OBseries", ".svg", sep = ""), device = "svg", dpi = 600, width = 15, height = 15, units = "cm")

```

## check the concordance between the ref and recon gtf first/last exon and NMD

```{r}

# wide_tibble_of_psisigma_results_allcomparisons_final_no.IR <- wide_tibble_of_psisigma_results_allcomparisons_final[grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$splicemode, pattern = "IR"), ]

# get row indices of first/last exon and NMD annotations.
## first exon
row.indices_first_exon_ref <- grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$first_or_last_exon_reference, pattern = "first_exon")
row.indices_first_exon_recon <- grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$first_or_last_exon_recon, pattern = "first_exon")

row.indices_first_exon_ref.recon.intersection <- intersect(row.indices_first_exon_ref, row.indices_first_exon_recon)
row.indices_first_exon_ref.recon.union <- union(row.indices_first_exon_ref, row.indices_first_exon_recon)

message("number of first exons in the reference: ", row.indices_first_exon_ref %>% length)
message("number of first exons in the recon: ", row.indices_first_exon_recon %>% length)
message("number of first exons in BOTH recon and reference: ", row.indices_first_exon_ref.recon.intersection %>% length)
message("first exons jaccard similarity: ", (row.indices_first_exon_ref.recon.intersection %>% length)/(row.indices_first_exon_ref.recon.union %>% length))

## last exon
row.indices_last_exon_ref <- grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$first_or_last_exon_reference, pattern = "last_exon")
row.indices_last_exon_recon <- grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$first_or_last_exon_recon, pattern = "last_exon")

row.indices_last_exon_ref.recon.intersection <- intersect(row.indices_last_exon_ref, row.indices_last_exon_recon)
row.indices_last_exon_ref.recon.union <- union(row.indices_last_exon_ref, row.indices_last_exon_recon)

message("number of last exons in the reference: ", row.indices_last_exon_ref %>% length)
message("number of last exons in the recon: ", row.indices_last_exon_recon %>% length)
message("number of last exons in BOTH recon and reference: ", row.indices_last_exon_ref.recon.intersection %>% length)
message("last exons jaccard similarity: ", (row.indices_last_exon_ref.recon.intersection %>% length)/(row.indices_last_exon_ref.recon.union %>% length))

## NMD
row.indices_NMD_ref <- grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$NMD_reference, pattern = "TRUE")
row.indices_NMD_recon <- grep(x = wide_tibble_of_psisigma_results_allcomparisons_final$NMD_recon, pattern = "TRUE")

row.indices_NMD_ref.recon.intersection <- intersect(row.indices_NMD_ref, row.indices_NMD_recon)
row.indices_NMD_ref.recon.union <- union(row.indices_NMD_ref, row.indices_NMD_recon)

message("number of NMD in the reference: ", row.indices_NMD_ref %>% length)
message("number of NMD in the recon: ", row.indices_NMD_recon %>% length)
message("number of NMD in BOTH recon and reference: ", row.indices_NMD_ref.recon.intersection %>% length)
message("NMD jaccard similarity: ", (row.indices_NMD_ref.recon.intersection %>% length)/(row.indices_NMD_ref.recon.union %>% length))

```

## frequency distribution of no. exons detected/gene

### ALL exons

```{r}

avg_exons_per_gene_all <- (wide_tibble_of_psisigma_results_allcomparisons_final$diff_exon_coords %>% unique %>% length)/(wide_tibble_of_psisigma_results_allcomparisons_final$matched_gene_names %>% unique %>% length)

print(paste("There are", avg_exons_per_gene_all, "unique exons/gene detected overall"))

tibble_all_exons_per_gene_freq <- wide_tibble_of_psisigma_results_allcomparisons_final %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons = n())

tibble_all_exons_per_gene_freq_2 <- tibble_all_exons_per_gene_freq %>% group_by(no_exons) %>% summarise(NumberOfGenesWithExonNumber = n())

# ggplot

ggplot(tibble_all_exons_per_gene_freq_2) + 
  geom_col(aes(y = NumberOfGenesWithExonNumber, x = no_exons)) +
  geom_text(data = tibble_all_exons_per_gene_freq_2, aes(label = NumberOfGenesWithExonNumber, y = NumberOfGenesWithExonNumber + 20, x = no_exons), position = position_nudge(y = 50)) +
  ggtitle(paste("frequency distribution of exons per gene for all genes 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  xlim(c(0, 20)) +
  xlab("number of exons/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_all.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_all.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 exon genes : 2 exon genes =", tibble_all_exons_per_gene_freq_2[1, 2]/tibble_all_exons_per_gene_freq_2[2, 2]))

```

### all constitutive exons

```{r}

avg_exons_per_gene_constitutive <- (tibble_constitutive_LSV_info$diff_exon_coords %>% unique %>% length)/(tibble_constitutive_LSV_info$matched_gene_names %>% unique %>% length)

print(paste("There are", avg_exons_per_gene_constitutive, "unique constitutive exons/gene detected"))

tibble_constitutive_exons_per_gene_freq <- tibble_constitutive_LSV_info %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons = n())

tibble_constitutive_exons_per_gene_freq_2 <- tibble_constitutive_exons_per_gene_freq %>% group_by(no_exons) %>% summarise(NumberOfGenesWithExonNumber = n())

# ggplot
ggplot(tibble_constitutive_exons_per_gene_freq_2) + 
  geom_col(aes(y = NumberOfGenesWithExonNumber, x = no_exons)) +
  geom_text(data = tibble_constitutive_exons_per_gene_freq_2, aes(label = NumberOfGenesWithExonNumber, y = NumberOfGenesWithExonNumber + 20, x = no_exons), position = position_nudge(y = 50)) +
  ggtitle(paste("frequency distribution of constitutive exons per gene for all genes 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  xlim(c(0, 20)) +
  xlab("number of exons/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_constitutive.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_constitutive.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 exon genes : 2 exon genes =", tibble_constitutive_exons_per_gene_freq_2[1, 2]/tibble_constitutive_exons_per_gene_freq_2[2, 2]))

```

### all differential exons

```{r}

avg_exons_per_gene_differential <- (wide_tibble_of_psisigma_results_allcomparisons_differential$diff_exon_coords %>% unique %>% length)/(wide_tibble_of_psisigma_results_allcomparisons_differential$matched_gene_names %>% unique %>% length)

print(paste("There are", avg_exons_per_gene_differential, "unique differential exons/gene detected"))

tibble_differential_exons_per_gene_freq <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons = n())

tibble_differential_exons_per_gene_freq_2 <- tibble_differential_exons_per_gene_freq %>% group_by(no_exons) %>% summarise(NumberOfGenesWithExonNumber = n())

# ggplot

ggplot(tibble_differential_exons_per_gene_freq_2) + 
  geom_col(aes(y = NumberOfGenesWithExonNumber, x = no_exons)) +
  geom_text(data = tibble_differential_exons_per_gene_freq_2, aes(label = NumberOfGenesWithExonNumber, y = NumberOfGenesWithExonNumber + 20, x = no_exons), position = position_nudge(y = 50)) +
  ggtitle(paste("frequency distribution of differential exons per gene for all genes 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  # scale_x_continuous(trans = "log2") +
  xlim(c(0, 20)) +
  xlab("number of exons/gene") +
  ylab("number of genes") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_differential.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_exons_per_gene_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_differential.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm") 

print(paste("Ratio of number of 1 exon genes : 2 exon genes =", tibble_differential_exons_per_gene_freq_2[1, 2]/tibble_differential_exons_per_gene_freq_2[2, 2]))

```

## frequency distribution of no. exons detected per category

incl. NMD, first/last exon.

```{r}

# category means splicemode + NMD status + first/last exon
# also clean up the splicemode column
tibble_exons_per_category_all <- wide_tibble_of_psisigma_results_allcomparisons_final %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2", perl = TRUE)} ) %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_exons_all = n())

all_exons_count <- tibble_exons_per_category_all$no_exons_all %>% sum(na.rm = TRUE)
number_NMD_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$any_NMD == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
number_first_exon_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$any_first_exon == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)
number_last_exon_all_exons <- tibble_exons_per_category_all[tibble_exons_per_category_all$any_last_exon == TRUE, ] %>% .$no_exons_all %>% sum(na.rm = TRUE)

message("There are ", number_NMD_all_exons*100/all_exons_count, "% NMD exons overall.")
message("There are ", number_first_exon_all_exons*100/all_exons_count, "% first exons overall.")
message("There are ", number_last_exon_all_exons*100/all_exons_count, "% last exons overall.")

tibble_exons_per_category_constitutive <- tibble_constitutive_LSV_info %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_exons_constitutive = n())

constitutive_exons_count <- tibble_exons_per_category_constitutive$no_exons_constitutive %>% sum(na.rm = TRUE)
number_NMD_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$any_NMD == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
number_first_exon_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$any_first_exon == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)
number_last_exon_constitutive_exons <- tibble_exons_per_category_constitutive[tibble_exons_per_category_constitutive$any_last_exon == TRUE, ] %>% .$no_exons_constitutive %>% sum(na.rm = TRUE)

message("There are ", number_NMD_constitutive_exons*100/constitutive_exons_count, "% NMD exons constitutive.")
message("There are ", number_first_exon_constitutive_exons*100/constitutive_exons_count, "% first exons constitutive.")
message("There are ", number_last_exon_constitutive_exons*100/constitutive_exons_count, "% last exons constitutive.")

tibble_exons_per_category_differential <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(splicemode, any_NMD, any_first_exon, any_last_exon) %>% summarise(no_exons_differential = n())

differential_exons_count <- tibble_exons_per_category_differential$no_exons_differential %>% sum(na.rm = TRUE)
number_NMD_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$any_NMD == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
number_first_exon_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$any_first_exon == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)
number_last_exon_differential_exons <- tibble_exons_per_category_differential[tibble_exons_per_category_differential$any_last_exon == TRUE, ] %>% .$no_exons_differential %>% sum(na.rm = TRUE)

message("There are ", number_NMD_differential_exons*100/differential_exons_count, "% NMD exons differential.")
message("There are ", number_first_exon_differential_exons*100/differential_exons_count, "% first exons differential.")
message("There are ", number_last_exon_differential_exons*100/differential_exons_count, "% last exons differential.")

tibble_exons_per_category_summary <- list(tibble_exons_per_category_all, tibble_exons_per_category_constitutive, tibble_exons_per_category_differential) %>% purrr::reduce(dplyr::full_join)

# melt the sample
long_tibble_exons_per_category_summary <- reshape2::melt(tibble_exons_per_category_summary, id.vars = c("splicemode", "any_NMD", "any_first_exon", "any_last_exon"), variable.name = "sample", value.name = "number_of_exons_per_category") %>% as_tibble %>% 
  # add the overall counts for each splicemode
  dplyr::group_by(splicemode, sample) %>% dplyr::mutate("number_of_exons_per_splicemode" = sum(number_of_exons_per_category %>% na.omit))

# melt the category
long_tibble_exons_per_category_summary_2 <- reshape2::melt(long_tibble_exons_per_category_summary, id.vars = c("splicemode", "sample", "number_of_exons_per_category", "number_of_exons_per_splicemode"), variable.name = "NMD_first_last_exon", value.name = "NMD_first_last_exon_value") %>% as_tibble %>% 
  # add the overall counts for each unique category
  dplyr::group_by(splicemode, sample, NMD_first_last_exon, NMD_first_last_exon_value) %>% dplyr::mutate("number_of_exons_per_category" = sum(number_of_exons_per_category %>% na.omit)) %>% unique %>%
  # add the percentage for each category/splicemode
  dplyr::mutate("percentage_exons_per_category" = number_of_exons_per_category*100/number_of_exons_per_splicemode)

max_number_of_exons_per_splicemode <- max(long_tibble_exons_per_category_summary_2$number_of_exons_per_splicemode)
max_percentage_exons_per_category <- max(long_tibble_exons_per_category_summary_2[long_tibble_exons_per_category_summary_2$NMD_first_last_exon_value == TRUE, ] %>% .$percentage_exons_per_category %>% na.omit)
max_number_of_exons_per_splicemode_for_plot <- max_number_of_exons_per_splicemode

# ggplot
ggplot() + 
  geom_col(data = long_tibble_exons_per_category_summary_2[, c("splicemode", "sample", "number_of_exons_per_splicemode")]  %>% dplyr::distinct(splicemode, sample, .keep_all = TRUE), aes(y = number_of_exons_per_splicemode, x = splicemode)) +
  facet_wrap(~sample, scales = "free", labeller = labeller(sample = c(no_exons_all = "All exons", no_exons_constitutive = "Constitutive", no_exons_differential = "Differential"))) +
  geom_label(data = long_tibble_exons_per_category_summary_2[, c("splicemode", "sample", "number_of_exons_per_splicemode")]  %>% dplyr::distinct(splicemode, sample, .keep_all = TRUE), aes(label = number_of_exons_per_splicemode, y = number_of_exons_per_splicemode, x = splicemode), position = position_identity()) +
  geom_jitter(data = long_tibble_exons_per_category_summary_2[long_tibble_exons_per_category_summary_2$NMD_first_last_exon_value == TRUE, ], aes(x = splicemode, y = percentage_exons_per_category * max_number_of_exons_per_splicemode_for_plot / max_percentage_exons_per_category , shape = NMD_first_last_exon), width = 0.1, height = 0) +
  ggtitle(paste("Frequency distribution of exons per category 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  xlab("Splicemode") +
  scale_y_continuous(name = "Number of exons", limits = c(0, max_number_of_exons_per_splicemode_for_plot), sec.axis = sec_axis(trans = ~. * max_percentage_exons_per_category/max_number_of_exons_per_splicemode, (name = "Percentage NMD/first/last exon per splicemode"))) +
  scale_shape_manual(name = "Category", limits = c("any_NMD", "any_first_exon", "any_last_exon"), labels = c("NMD candidate", "First exon", "Last exon"), values = c(1, 4, 19)) + 
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "frequency_distribution_of_exons_per_category_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 40, height = 15, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "frequency_distribution_of_exons_per_category_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 40, height = 15, units = "cm") 

# upset plot
message("all exons")
df <- wide_tibble_of_psisigma_results_allcomparisons_final %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% .[, c("diff_exon_coords", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = diff_exon_coords + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -diff_exon_coords), row.names = df$diff_exon_coords) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(R_processing_results_dir, "upset_plot_of_intersections_exons_per_NMD.first.last.exon_per_splicemode_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_allexons.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Exon ontology",
                                                                     "any_first_exon" = "Exon ontology",
                                                                     "any_last_exon" = "Exon ontology",
                                                                     "A3SS" = "Splicemode",
                                                                     "A5SS" = "Splicemode",
                                                                     "IR" = "Splicemode",
                                                                     "MES" = "Splicemode",
                                                                     "MXS" = "Splicemode",
                                                                     "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                                      ))

dev.off()

message("all constitutive")
df <- tibble_constitutive_LSV_info %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% .[, c("diff_exon_coords", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = diff_exon_coords + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -diff_exon_coords), row.names = df$diff_exon_coords) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(R_processing_results_dir, "upset_plot_of_intersections_exons_per_NMD.first.last.exon_per_splicemode_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_constitutive.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Exon ontology",
                                                                     "any_first_exon" = "Exon ontology",
                                                                     "any_last_exon" = "Exon ontology",
                                                                     "A3SS" = "Splicemode",
                                                                     "A5SS" = "Splicemode",
                                                                     "IR" = "Splicemode",
                                                                     "MES" = "Splicemode",
                                                                     "MXS" = "Splicemode",
                                                                     "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                                      ))

dev.off()

message("all differential")
df <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% modify_at(., .at = "splicemode", .f = function(x) {gsub(x = x, pattern = "^(TSS\\|)*([^_|\\|]+)(.*)*", replacement = "\\2")} ) %>% dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% .[, c("diff_exon_coords", "splicemode", "any_NMD", "any_first_exon", "any_last_exon")] %>% add_column("dummy" = TRUE) %>% reshape2::dcast(formula = diff_exon_coords + any_NMD + any_first_exon + any_last_exon ~ splicemode, value.var = "dummy") %>% as_tibble 

df[is.na(df)] = FALSE

upset_combs <- data.frame(df %>% dplyr::select(., -diff_exon_coords), row.names = df$diff_exon_coords) %>% make_comb_mat(mode = "distinct")

print(set_size(upset_combs))

pdf(file = paste(R_processing_results_dir, "upset_plot_of_intersections_exons_per_NMD.first.last.exon_per_splicemode_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, "_differential.pdf", sep = ""), height = 4, width = 10)

ComplexHeatmap::UpSet(upset_combs, 
                      comb_order = order(-comb_size(upset_combs)), 
                      left_annotation = rowAnnotation("Set Type" = c("any_NMD" = "Exon ontology",
                                                                     "any_first_exon" = "Exon ontology",
                                                                     "any_last_exon" = "Exon ontology",
                                                                     "A3SS" = "Splicemode",
                                                                     "A5SS" = "Splicemode",
                                                                     "IR" = "Splicemode",
                                                                     "MES" = "Splicemode",
                                                                     "MXS" = "Splicemode",
                                                                     "SES" = "Splicemode")[set_name(upset_combs)], show_annotation_name = FALSE, 
                                                      col = list("Set Type" = c("Exon ontology" = "tomato1", "Splicemode" = "red4"))
                                                      ))

dev.off()

```

## frequency distribution of no. events detected per category

```{r}

junctions_per_category_all_freq <- PSI_levels_timeseries_OB_wide_with_na %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode) %>% summarise(no_junctions_all = n())

junctions_per_category_AS_plausible_freq <- wide_table_of_all_splicemodes_with_na_OBseries_filtered_qvalue_0.05_AS_plausible %>% dplyr::distinct(., AS_event_ID, .keep_all = TRUE) %>% group_by(splicemode) %>% summarise(no_junctions_AS_plausible = n())

junctions_per_category_summary <- dplyr::full_join(junctions_per_category_all_freq, junctions_per_category_AS_plausible_freq, by = "splicemode")

junctions_per_category_summary_2 <- add_column(junctions_per_category_summary, "percentage_change_after_AS_plausible_filtering" = paste(signif((junctions_per_category_summary$no_junctions_AS_plausible - junctions_per_category_summary$no_junctions_all) * 100 / junctions_per_category_summary$no_junctions_all, 2), "%"))

long_junctions_per_category_summary_2 <- reshape2::melt(junctions_per_category_summary_2, id.vars = "splicemode")

long_junctions_per_category_summary_3 <- add_column(long_junctions_per_category_summary_2, "value_numeric" = gsub(x = long_junctions_per_category_summary_2$value, pattern = " %", replacement = "") %>% as.numeric)

# ggplot

ggplot(long_junctions_per_category_summary_3) + 
geom_col(aes(y = value_numeric, x = splicemode)) +
facet_wrap(~variable, scales = "free") +
geom_label(data = long_junctions_per_category_summary_3, aes(label = value, y = value_numeric, x = splicemode)) +
ggtitle(paste("frequency distribution of differentially spliced junctions per category 
              ", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, sep = "")) +
xlab("AS category") +
ylab("Number of differential junctions") +
theme_bw() +
theme(text = element_text(family = "Helvetica")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family ="Helvetica")) +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_category_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
ggsave(filename = paste(qualitycheck_results_dir, "frequency_distribution_of_junctions_per_category_", p_or_q_value, qpvalue_cutoff, "_deltaPSI_greaterthan_", dPSI_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

## graph the no. of exons detected vs. maximum transcript length

### fetch max. transcript lengths for genes in biomart

```{r}

tibble_max_transcript_length_per_gene <- getBM(attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart) %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length	)) %>% 
  setNames(c("matched_gene_names", "maxtranscriptlength"))

```


```{r}

exons_per_gene_constitutive <- wide_tibble_of_psisigma_results_allcomparisons_constitutive %>% 
  dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons_constitutive = n())

exons_per_gene_differential <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% 
  dplyr::distinct(., diff_exon_coords, .keep_all = TRUE) %>% group_by(matched_gene_names) %>% summarise(no_exons_differential = n())

exons_per_gene_merged <- dplyr::full_join(exons_per_gene_constitutive, exons_per_gene_differential, by = "matched_gene_names")

wide_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength <- dplyr::right_join(tibble_max_transcript_length_per_gene, exons_per_gene_merged, by = "matched_gene_names") %>% setNames(., c("Gene", "maxtranscriptlength", "no_exons_constitutive", "no_exons_differential"))

long_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength <- reshape2::melt(wide_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength, 
                                                                                    id = c("Gene", "maxtranscriptlength"), variable.name = "filteringstep",
                                                                                    value.name = "no_exons") %>% as_tibble %>% type_convert

# no. junctions detected vs. maximum annotated transcript length
ggplot(long_tibble_numberof_exons_per_gene_maxCPM_maxtranscriptlength) + 
  geom_point(aes(y = no_exons, x = maxtranscriptlength)) +
  geom_smooth(method = "lm", formula = y~x, colour = "red", aes(y = no_exons, x = maxtranscriptlength)) +
  # annotate(geom = "text", aes(x = 2e5, y = 20, label = paste(cor(x = comparison_1_value, y = comparison_2_value, method = "pearson"))), size = 5) +
  facet_wrap(~filteringstep, scales = "free") +
  ggtitle(paste("scatterplot of the number of unique exons detected per gene against max. annotated transcipt length 
                ", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, sep = "")) +
  xlab("maximum annotated transcript length") +
  ylab("number of exons detected") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no._exons_vs_max_transcript_length_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "scatterplot_no._exons_vs_max_transcript_length_", pvalue_or_FDR, pvalue_cutoff, "_dpsi", dpsi_cutoff, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

## Plot PCA to check for technical variation in absolute PSI values

### Define the column indices of the table which contain the absolute PSI values

```{r}

vector_col.indices_absolute.psi <- grep(x = colnames(wide_tibble_of_psisigma_result_tibbles_processed_ud.only), pattern = "absolute.psi")

```

### show that there are quite alot of missing values across the timeseries

```{r}

library(Amelia)

missmap(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi], pdfstub = paste(qualitycheck_results_dir, "heatmap_missingness_absolute.PSI.pdf", sep = ""), margins = c(10, 5))

cat("There are", nrow(wide_tibble_of_psisigma_result_tibbles_processed_ud.only), "differential exons in total detected across the time series.\n")
cat("Of those,", nrow(wide_tibble_of_psisigma_result_tibbles_processed_ud.only %>% na.omit), "differential exons have a complete time profile with all replicates intact.")

```

### plot PCA using only all intact values, raw

```{r}

# PCA analysis

PCA_combined_count <- prcomp(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit)

# plot standard deviations 

PCA_stdev <- tibble(PC = 1:(PCA_combined_count[["sdev"]] %>% length), stdev = PCA_combined_count[["sdev"]])
PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)

ggplot(PCA_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on absolute PSI (raw)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_absolute_PSI_raw.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_absolute_PSI_raw.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings <- PCA_combined_count[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings <- add_column(PCA_loadings, timepoint = gsub(x = PCA_loadings$sample, pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1"))
PCA_loadings <- add_column(PCA_loadings, replicatenumber = gsub(x = PCA_loadings$sample, pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\2"))

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PC2 vs. PC1 loadings based on absolute PSI (raw)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  scale_color_manual(breaks = vector_OBseries_timepoints, limits = vector_OBseries_timepoints, labels = vector_OBseries_timepoints, values = brewer.pal(8, "Spectral")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_absolute_PSI_raw.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_absolute_PSI_raw.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 15, units = "cm")

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PC3 vs. PC2 loadings based on absolute PSI (raw)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  scale_color_manual(breaks = vector_OBseries_timepoints, limits = vector_OBseries_timepoints, labels = vector_OBseries_timepoints, values = brewer.pal(8, "Spectral")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_absolute_PSI_raw.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_absolute_PSI_raw.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 15, units = "cm")

```

### conduct RUV normalisation and re-check the PCA clustering

```{r}

library(RUVSeq)
library(BBmisc)

 pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVs_absolute.PSI_raw.pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% as.matrix, outline = FALSE, col = factor(gsub(x = colnames(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi]), pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1")), las = 2, main = paste("RLE plot of RUVs absolute PSI (raw)"), margins = c(10, 5))
  
  dev.off() 

k.value <- 3
 
replicate_colnumbers <- tribble(~rep1, ~rep2, ~rep3,
            1,     2,     3,
            4,     5,     6,
            7,     8,     9,
            10,    11,    12,
            13,    14,    15,
            16,    17,    18,
            19,    20,    21,
            22,    23,    24) %>% as.matrix

# RUVs

nsYs <- RUVs(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit %>% as.matrix, scIdx = replicate_colnumbers, k = k.value, isLog = TRUE)
 
tibble_absolute.PSI_OBseries_RUVs <- wide_tibble_of_psisigma_result_tibbles_processed_ud.only %>% na.omit

## rescale ranges
target_min.psi <- min(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit)
target_max.psi <- max(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi] %>% na.omit)

current_min.psi <- min(nsYs$normalizedCounts)
current_max.psi <- max(nsYs$normalizedCounts)

matrix_unscaled_counts <-nsYs$normalizedCounts

matrix_rescaled_counts <- (matrix_unscaled_counts - (current_min.psi - target_min.psi))
matrix_rescaled_counts <- matrix_rescaled_counts*(target_max.psi/max(matrix_rescaled_counts))

tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi] <- matrix_rescaled_counts %>% as_tibble

max(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi])
min(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi])
  
  pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVs_absolute.PSI_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi] %>% as.matrix, outline = FALSE, col = factor(gsub(x = colnames(wide_tibble_of_psisigma_result_tibbles_processed_ud.only[, vector_col.indices_absolute.psi]), pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1")), las = 2, main = paste("RLE plot of RUVs absolute PSI, k =", k.value))
  
  dev.off() 
  

```

### plot PCA using only all intact values, normalised RUVs

```{r}

# PCA analysis

PCA_combined_count <- prcomp(tibble_absolute.PSI_OBseries_RUVs[, vector_col.indices_absolute.psi])

# plot standard deviations 

PCA_stdev <- tibble(PC = 1:(PCA_combined_count[["sdev"]] %>% length), stdev = PCA_combined_count[["sdev"]])
PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)

ggplot(PCA_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_combined_count[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on absolute PSI (RUVs)", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_absolute_PSI_RUVs.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_absolute_PSI_RUVs.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_loadings <- PCA_combined_count[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_loadings <- add_column(PCA_loadings, timepoint = gsub(x = PCA_loadings$sample, pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\1"))
PCA_loadings <- add_column(PCA_loadings, replicatenumber = gsub(x = PCA_loadings$sample, pattern = "(.*)_absolute.psi_(\\d)", replacement = "\\2"))

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PC2 vs. PC1 loadings based on absolute PSI (RUVs)", sep = "")) +
  xlab(paste("PC1 (", PCA_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  scale_color_manual(breaks = vector_OBseries_timepoints, limits = vector_OBseries_timepoints, labels = vector_OBseries_timepoints, values = brewer.pal(8, "Spectral")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_absolute_PSI_RUVs.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_absolute_PSI_RUVs.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 15, units = "cm")

ggplot(PCA_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral") +
  ggtitle(paste("PC3 vs. PC2 loadings based on absolute PSI (RUVs)", sep = "")) +
  xlab(paste("PC2 (", PCA_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  scale_color_manual(breaks = vector_OBseries_timepoints, limits = vector_OBseries_timepoints, labels = vector_OBseries_timepoints, values = brewer.pal(8, "Spectral")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_absolute_PSI_RUVs.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 15, units = "cm") +
  ggsave(filename = paste(qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_absolute_PSI_RUVs.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 15, units = "cm")

```

# JUNCTION ONTOLOGY

## retrieve whole biomart domain annotations from server and save

```{r}

# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

```

```{r eval=FALSE, include=FALSE}

# query biomart
list_of_tibbles_biomart_domain_annotation <- future_map(.x = list_of_attributes_to_retrieve, .f = ~getBM(attributes = .x, mart = ensembl_mart) %>% as_tibble %>% na.omit, .progress = TRUE, .options = future_options(globals = c("getBM", "ensembl_mart")))

# write tables
future_map2(.x = list_of_tibbles_biomart_domain_annotation, .y = names(list_of_tibbles_biomart_domain_annotation), .f = ~write.table(.x, file = paste(shared_dir, "table_biomart_ENSP_to_", .y, ".txt", sep = ""), row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t"), .progress = TRUE, .options = future_options(globals = FALSE))

```

```{r}

# read tables
list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(shared_dir, "table_biomart_ENSP_to_", .x, ".txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

```

## retrieve whole biomart ENSP to uniprotkb entry ID mapping

```{r}

tibble_ENSP_to_uniprotkb <- biomaRt::getBM(attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
  type_convert %>% 
  as_tibble %>%
  na.omit

```

## import GTF and process it into a nice table containing only character and numeric types

```{r eval=FALSE, include=FALSE}

# IMPORT GTF ANNOTATION OF TRANSCRIPT/EXON/PROTEIN CODING REGIONS ETC...

library(rtracklayer)

tibble_ref_gtf_original <- rtracklayer::import("/media/Ubuntu/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(tibble_ref_gtf_original) <- c("seqnames", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/media/Ubuntu/sharedfolder/dbPTM_download/extract/allPTM_human.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/media/Ubuntu/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES
tibble_PTM_combined <- dplyr::bind_rows(tibble_dbPTM_allhuman_annotations, tibble_phosphositeplus_allhuman_phosphosites)

```

## transcript and domain analyses! :)

NEW METHOD - USING ONLY EXONS MATCHED TO THE REFERENCE GTF

now, PSI-sigma considers long and short forms of A3SS/A5SS exons to be distinct.

We just consider differential regions to be any differential exon.

```{r message=FALSE, warning=FALSE}

query_name <- "all_differential"

# set-up ALL differential exons for looping
list_constituent_junctions_for_query <- wide_tibble_of_psisigma_results_allcomparisons_differential %>% (function(input_table) {
  
  output_list <- input_table[, c("diff_exon_coords", "splicemode", "diff_exon_chr", "diff_exon_start", "diff_exon_end", "matched_strand")] %>% 
    as_tibble %>% 
    unique %>%
    array_tree
  
  return(output_list)
  
} )

## match exons to reference annotation
list_ref_entries_matched_to_constituent_junctions <- list_constituent_junctions_for_query %>% future_map(
  .f = ~purrr::splice(.x,
                      
                      # DEBUG ###
                      # .x <- list_constituent_junctions_for_query[[1]]
                      ###########
                      
                      "ref_matched_exons" = list(
                        extract_overlapping.exons(.x, tibble_ref_gtf_original, stranded = TRUE)
                                                )
                      ) %>% 
    # extract vector of matched transcripts from the above
    purrr::splice(
      "vector_matched_transcript_ids" = .$ref_matched_exons %>% .$transcript_id %>% unique %>% na.omit
    )
    , 
                      .progress = TRUE, 
                      .options = future_options(globals = c("tibble_ref_gtf_original", "extract_overlapping.exons"))) %>% 
  purrr::discard(.x = ., .p = ~nrow(.x$ref_matched_exons) == 0)
  
# GENERATE GENOME-RELATIVE COORDS FOR EVERY DIFFERENTIAL POSITION.
# also generate genome-relative coords for every CDS position of transcripts with a matched exon. this is necessary because we need to deal with gaps.
list_genome_relative_differential_coords <- future_map(.x = list_ref_entries_matched_to_constituent_junctions, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_ref_entries_matched_to_constituent_junctions[[2]]
  ###########
  
  ref_gtf_table <<- tibble_ref_gtf_original
  input_list <- .x
  
  output_list <- purrr::splice(
  
    input_list,
    
    # take the maximum range (which is at most 4nt bigger than the actual exon) because of the matching tolerance of +/-2 nt
    "vector_genomic_coords_of_all_differential_exon_positions" = (input_list$ref_matched_exons$start %>% min):(input_list$ref_matched_exons$end %>% max),
    
    "genomic_coords_of_all_CDS_positions_per_protein_id" = list(input_list$vector_matched_transcript_ids %>% (function(x) {
      
      # DEBUG ###
      # x <- input_list$vector_matched_transcript_ids
      ###########
      
      # get the CDS entries by referring to the transcript_id of matched exons.
      list_ref_CDS_entries_from_matched_exons <- x %>% na.omit %>% unique %>% array_tree %>% 
        purrr::map(.x = ., .f = ~ref_gtf_table[ref_gtf_table$transcript_id == .x & ref_gtf_table$type == "CDS", ] %>% 
        .[apply(X = ., MARGIN = 1, FUN = function(X) {all(is.na(X)) == FALSE}), ])
      
      # get the protein_ids of the CDS entries. this is required downstream.
      list_CDS_protein_ids <- list_ref_CDS_entries_from_matched_exons %>% purrr::map(~.x$protein_id %>% na.omit %>% unique %>% as.character)
      
      # generate sorted CDS positions for each protein_id (technically for each transcript_id)
      list_genome_relative_coords_of_CDS_positions_per_protein_id <- list_ref_CDS_entries_from_matched_exons %>% purrr::map_if(.p = ~nrow(.x) > 0, .f = ~sort_tibble_according_to_strand(.x))
      
      # name the lists using the protein_id
      names(list_genome_relative_coords_of_CDS_positions_per_protein_id) <- list_CDS_protein_ids
      
      list_genome_relative_coords_of_CDS_positions_per_protein_id <- list_genome_relative_coords_of_CDS_positions_per_protein_id[which(names(list_genome_relative_coords_of_CDS_positions_per_protein_id) != "character(0)")]
      
      return(list_genome_relative_coords_of_CDS_positions_per_protein_id)
      
    } ) )
    
    )
  
  return(output_list)
    
    }, .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf_original", "sort_tibble_according_to_strand", "as_tibble", "tibble::enframe", "list_ref_CDS_entries_from_matched_exons")) ) %>%
    
    # drop exons that don't have any differential regions.
    purrr::discard(.x = ., .p = ~length(.x$vector_genomic_coords_of_all_differential_exon_positions) == 0)

# MATCH DIFFERENTIAL GENOME-RELATIVE COORDS TO EACH CDS REGION CORRESPONDING TO PROTEIN ID
# THEN EXTRACT THE PROTEIN-RELATIVE COORDS
list_transcript_and_protein_relative_differential_coords <- future_imap(.x = list_genome_relative_differential_coords, .f = function(.x, .y) {
  
  # message("now processing junction number: ", .y)
  
  # DEBUG ###
  # .x <- list_genome_relative_differential_coords[[2]]
  ###########
  
  input_list <- .x
  
  output_list <- purrr::splice(
    
    input_list,
    
    "CDS_relative_differential_coords" = list(purrr::map(.x = input_list$genomic_coords_of_all_CDS_positions_per_protein_id, 
                                              .f = ~which(.x %in% input_list$vector_genomic_coords_of_all_differential_exon_positions) %>% sort(decreasing = FALSE)
                                              ) %>% 
                                   purrr::discard(.p = ~length(.x) == 0)
                                 )
    ) %>%
    
    # protein-relative coords are simply the ceiling of a third of the transcript-relative coords
    purrr::splice(
      
      "protein_relative_differential_coords" = list(.$CDS_relative_differential_coords %>% 
                                         purrr::map(~ceiling(.x / 3) %>% unlist %>% unique))
      
    )
    
    }, .progress = TRUE, .options = future_options(globals = FALSE))

# MATCH THE DIFFERENTIAL TRANSCRIPT-RELATIVE COORDS TO THE ENSEMBL GTF
# MATCH THE DIFFERENTIAL PROTEIN-RELATIVE COORDS TO THE FETCHED BIOMART LIST AS WELL AS THE PTMS
list_matched_annotation <- future_map(.x = list_transcript_and_protein_relative_differential_coords, .f = function(.x) {
  
  # WARNING!! FIX THIS WHEN NAMING THE FUNCTION!
  # list_of_tibbles_biomart_domain_annotation <<- list_of_tibbles_biomart_domain_annotation
  
  # tibble_ENSP_to_uniprotkb <<- tibble_ENSP_to_uniprotkb
  # tibble_PTM_combined <<- tibble_PTM_combined
  # tibble_ref_gtf_original <<- tibble_ref_gtf_original
  ############################################
  
  # DEBUG ###
  # .x <- list_transcript_and_protein_relative_differential_coords[[1]]
  ###########
  
  input_list <- .x
  
  output_list <- purrr::splice(
    
    input_list,
    
    "transcript_features" = purrr::map(.x = input_list$vector_matched_transcript_ids, .f = function(.x) {
      
      # DEBUG ###
      # .x <- input_list$vector_matched_transcript_ids %>% .[[1]]
      ###########
      
      # subset the reference GTF by transcript_id
      tibble_ref_gtf_subset_by_transcript_id <- tibble_ref_gtf_original[tibble_ref_gtf_original$transcript_id == .x, ] %>% .[-which(is.na(.$seqnames)), ]
      
      # test for which differential positions lie between a feature
      row.indices_of_overlaps_with_differential_positions <- which(purrr::map2(.x = tibble_ref_gtf_subset_by_transcript_id$start, 
                           .y = tibble_ref_gtf_subset_by_transcript_id$end, 
                           .f = ~any(.x < input_list$vector_genomic_coords_of_all_differential_exon_positions &
                                       .y > input_list$vector_genomic_coords_of_all_differential_exon_positions)) %>% unlist)
      
      # extract matched GTF entries
      matched_GTF_entries <- tibble_ref_gtf_subset_by_transcript_id[row.indices_of_overlaps_with_differential_positions, ]
      
      return(matched_GTF_entries)
      
    } ) %>% 
      # rbind and spit out unique transcript feature types.
      rbindlist %>% .[, c("type", "transcript_biotype")] %>% unlist %>% unique,
    
    "biomart_annotations" = list(purrr::map2(.x = input_list$CDS_relative_differential_coords, .y = names(input_list$CDS_relative_differential_coords), .f = function(.x, .y) {
      
      # DEBUG ###
      # .x <- input_list$CDS_relative_differential_coords %>% .[[1]]
      # .y <- names(input_list$CDS_relative_differential_coords) %>% .[1]
      ###########
      
      CDS.relative.coords <- .x
      protein.id <- .y
      
      # find domains which overlapped with the differential positions.
      list_matched_biomart_annotations <- purrr::map2(.x = list_of_tibbles_biomart_domain_annotation, 
                                                      .y = names(list_of_tibbles_biomart_domain_annotation),
                                                      .f = function(.x, .y) {
                                                        
                                                        # DEBUG ###
                                                        # .x <- list_of_tibbles_biomart_domain_annotation[[2]]
                                                        ###########
                                                        
                                                        tibble_domain_subset <- .x[.x$ensembl_peptide_id == protein.id, ]
                                                        
                                                        if (nrow(tibble_domain_subset) != 0) {
                                                          
                                                          # test matched_domain_entriesfor which differential positions lie between a domain
                                                          
                                                          row.indices_of_overlaps_with_differential_positions <- which(purrr::map2(
                                                            .x = tibble_domain_subset$start, 
                                                            .y = tibble_domain_subset$end, 
                                                            .f = ~any(.x < CDS.relative.coords &
                                                                        .y > CDS.relative.coords)) %>% unlist)
                                                          
                                                          # extract matched GTF entries
                                                          tibble_matched_domain_entries <- tibble_domain_subset[row.indices_of_overlaps_with_differential_positions, ]
                                                          
                                                          } else if (nrow(tibble_domain_subset) == 0) {
                                                            
                                                            tibble_matched_domain_entries <- tibble_domain_subset
                                                            
                                                            }
                                                        
                                                        # rename the columns back to being domain-type specific
                                                        
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "start", replacement = paste(.y, "_", "start", sep = ""))
                                                        colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "end", replacement = paste(.y, "_", "end", sep = ""))
                                                        
                                                        return(tibble_matched_domain_entries)
                                                        
                                                        } )
      
      # reduce into tibble by full join
      tibble_matched_biomart_annotations <- list_matched_biomart_annotations %>% purrr::reduce(dplyr::full_join)
      
      return(tibble_matched_biomart_annotations)
      
      } ) %>% rbindlist %>% as_tibble ),
    
    "PTMs" =  list(
      
      purrr::map2(.x = input_list$CDS_relative_differential_coords, .y = names(input_list$CDS_relative_differential_coords), .f = function(.x, .y) {
        
      # DEBUG ###
      # .x <- input_list$CDS_relative_differential_coords %>% .[[6]]
      # .y <- names(input_list$CDS_relative_differential_coords) %>% .[6]
      ###########
        
      tibble_uniprotkb_entries_from_ENSP <- tibble_ENSP_to_uniprotkb[tibble_ENSP_to_uniprotkb$ensembl_peptide_id == .y, ]
      
      tibble_combined_PTM_matching_entries <- tibble_uniprotkb_entries_from_ENSP %>% dplyr::left_join(., tibble_PTM_combined, by = "uniprotkb_entry") %>%
        
        .[.$modified_residue_position %in% .x, ]
      
      return(tibble_combined_PTM_matching_entries)
        
      } ) %>% rbindlist %>% as_tibble
      
    )
    
  )
    
}, .progress = TRUE, .options = future_options(globals = c("rbindlist", "list_of_tibbles_biomart_domain_annotation", "tibble_ENSP_to_uniprotkb", "tibble_PTM_combined", "tibble_ref_gtf_original", "as_tibble")))

# TIDY AND WRAP UP ALL THE ANNOTATIONS.
# prepare for export
list_tidied_annotation <- list_matched_annotation %>% 
  future_map(.f = ~
               # concatenate all bare vectors 
               modify_at(.x, .at = "vector_genomic_coords_of_all_differential_exon_positions", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = "vector_matched_transcript_ids", .f = ~.x %>% paste(collapse = ",")) %>%
               modify_at(.x, .at = "transcript_features", .f = ~.x %>% paste(collapse = ",")), .progress = TRUE, .options = future_options(globals = c("rbindlist", "as_tibble")))

# extract the transcript features and tibblise 
tibble_final_transcript_feature_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("diff_exon_coords", "splicemode", "vector_matched_transcript_ids", "transcript_features")] %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble %>%
  setNames(c("diff_exon_coords", "splicemode", "transcript_ids_with_annotation", "transcript_features"))
# write table
write.table(x = tibble_final_transcript_feature_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_transcript_features_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# extract the biomart results and tibblise 
tibble_final_biomart_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("diff_exon_coords", "splicemode", "biomart_annotations")] ) %>%
  purrr::discard(.p = ~.x$biomart_annotations %>% nrow == 0) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "biomart_annotations", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble
# write table
write.table(x = tibble_final_biomart_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_biomart_domains_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# extract the PTM results and tibblise 
tibble_final_PTM_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("diff_exon_coords", "splicemode", "PTMs")] ) %>%
  purrr::discard(.p = ~.x$PTMs %>% nrow == 0) %>%
  purrr::map(~purrr::modify_at(.x = .x, .at = "PTMs", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble
# write table
write.table(x = tibble_final_PTM_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_PTMs_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# extract the other supporting information and tibblise
tibble_final_annotation_supp <- list_tidied_annotation %>% 
  purrr::map(~.x[c("diff_exon_coords", "splicemode", "vector_genomic_coords_of_all_differential_exon_positions", "vector_matched_transcript_ids", "protein_relative_differential_coords")]) %>%
  purrr::map_if(.p = ~.x$protein_relative_differential_coords %>% length != 0, .f = ~purrr::modify_at(.x = .x, .at = "protein_relative_differential_coords", .f = ~.x %>% purrr::map(~paste(.x, collapse = ",")) %>% as_tibble %>% t %>% as_tibble(rownames = "ensembl_peptide_id") %>% setNames(c("ensembl_peptide_id", "protein_relative_differential_coords")))) %>%
  purrr::map_if(.p = ~.x$protein_relative_differential_coords %>% length == 0, .f = ~purrr::modify_at(.x = .x, .at = "protein_relative_differential_coords", .f = function(.x) {return("NA")} ) %>% splice("ensembl_peptide_id" = "NA")) %>%
  purrr::map(~.x %>% flatten %>% as_tibble) %>%
  purrr::discard(.p = ~.x %>% nrow == 0) %>% rbindlist %>% as_tibble
# write table
write.table(x = tibble_final_annotation_supp, file = paste(R_processing_results_dir, "table_exon_ontology_supporting_info_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
  
```

## stats summary of junction ontology

```{r}

# transcript-level
message("total number of unique differential exons with any sort of transcript-level annotation: ", tibble_final_transcript_feature_annotation$diff_exon_coords %>% length)

message("percent of differential regions matched to protein coding transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "protein_coding") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to an lncRNA transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "lncRNA") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a miRNA transcript: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "miRNA") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))

message("percent of differential regions matched to a 3' UTR region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "three_prime_utr") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a 5' UTR region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "five_prime_utr") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))
message("percent of differential regions matched to a CDS region: ", 100 * grep(x = tibble_final_transcript_feature_annotation$transcript_features, pattern = "CDS") %>% length/(tibble_final_transcript_feature_annotation$diff_exon_coords %>% length))

# PROTEIN-LEVEL
vector_unique_interpro_ids <- tibble_final_biomart_annotation$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_final_biomart_annotation %>% dplyr::group_by(diff_exon_coords) %>% 
  dplyr::summarise(overlaps_interpro_domain = all(is.na(interpro)) == FALSE,
                   unique_interpro_ids = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   overlaps_LCR = all(is.na(seg_start)) == FALSE,
                   overlaps_disordered_region = all(is.na(mobidblite)) == FALSE,
                   overlaps_ncoils = all(is.na(ncoils_start)) == FALSE,
                   overlaps_signalp = all(is.na(signalp_start)) == FALSE,
                   overlaps_tmhmm = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort

# create tally of each unique instance of interpro ID per diff_exon_coords
tibble_interpro_id_tally_per_diff.exon <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% .[order(.$tally), ] %>% dplyr::arrange(desc(tally))
# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- getBM(filters = "interpro", values = tibble_interpro_id_tally_per_diff.exon$interpro_id, attributes = c("interpro", "interpro_description"), mart = ensembl_mart) %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble join
tibble_interpro_id_tally_per_diff.exon <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_diff.exon, by = "interpro_id")
# plot
ggplot(tibble_interpro_id_tally_per_diff.exon %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "dodgerblue2") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of differential exons", dpsi_cutoff, "and any sig", pvalue_or_FDR, pvalue_cutoff, "encompassing", nrow(tibble_protein_level_summary_count), "exons")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, "tally_overlapping_interpro_domains_differential_exons_", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 15, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, "tally_overlapping_interpro_domains_differential_exons_", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 15, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_ASeventID, file = paste(R_processing_results_dir, "tally_overlapping_interpro_domains_differential_exons_", dpsi_cutoff,  "_", pvalue_or_FDR, pvalue_cutoff, "_", nrow(tibble_protein_level_summary_count), "_exons_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique exons with any sort of protein-level annotation: ", tibble_final_biomart_annotation$diff_exon_coords %>% unique %>% length, " (", tibble_final_biomart_annotation$diff_exon_coords %>% unique %>% length *100/nrow(tibble_final_transcript_feature_annotation), "% of those which have any transcript annotation)")

message("total percent of unique exons overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique exons overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total number of unique exons overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

```