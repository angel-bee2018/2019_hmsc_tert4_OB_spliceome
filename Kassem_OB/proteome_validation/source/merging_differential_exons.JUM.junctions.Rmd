---
title: "A workspace to design the functions to summarise exon or junction"
author: "Angel Liang"
date: "11/01/2020"
output: html_document
---

# Set the running environment

## Packages

```{r}

library(tidyverse)
library(data.table)
library(rtracklayer)

# library(biomaRt)
# ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

library(furrr)
future::plan(multiprocess)
options(future.globals.maxSize= 30000000000, mc.cores = 3)


```

## Global directories

```{r}

output_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_database_generation/angel_3FT_junctions/"

```

# Pooling AS junction co-ordinates from JUM

accepts:
1. table of differential junctions (result from JUM), must contain AS_event_ID and splicemode columns
2. all the detailed tables used in analysis, as is (untouched)
3. UNION_junc_coor file from JUM, which contains all the junction ID to genome co-ordinate mapping.

## Directories

```{r}

JUM_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/"

differential_junction_table_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/5x5_SOM_2552_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15.txt"

UNION_junc_coor_path <- "Y:/PGNEXUS_OBseries/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

output_file_name <- "junction_table_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15"

```

## Import the detailed tables into the environment

```{r message=FALSE, warning=FALSE}

list_of_timepoint_comparisons_final <- read.delim(paste(JUM_results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree %>% flatten

list_of_AS_events <- c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events") %>% array_tree %>% flatten

# read tables into environment

list_of_detailed_tables <- purrr::map(.x = list_of_timepoint_comparisons_final, .f = ~purrr::map2(.x = .x, .y = list_of_AS_events, .f = ~read.delim(file = paste(JUM_results_dir, "final_JUM_output_", .x, "/", list.files(path = paste(JUM_results_dir, "final_JUM_output_", .x, "/", sep = ""), pattern = paste("(.)", .y, "(.*)detailed.txt", sep = "")), sep = ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble %>% add_column(., "splicemode" = .y)) %>% set_names(list_of_AS_events)) %>% set_names(list_of_timepoint_comparisons_final)

# bind rows for each comparison

list_of_detailed_tables_2 <- list_of_detailed_tables %>% purrr::map(.x = ., .f = ~rbindlist(.x))

# rename the colnames to be not comparison-specific - we will add a comparison column later on

list_of_detailed_tables_3 <- purrr::map2(.x = list_of_detailed_tables_2, .y = list_of_timepoint_comparisons_final, .f = ~setNames(., c("Gene", "AS_event_ID", "AS_structure_ID", "sub_junction_ID", "sub-junction_dispersion_estimate", "LRT_statistic-full_vs_reduced", "LRT_p_value-full_vs_reduced", "BH_adjusted_p-values", "logCPM_1", "logCPM_2", "fitting_parameter_log2fold_change_2_from_1", "sub_junction_chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand", "raw_count.1", "raw_count.2", "raw_count.3", "raw_count.4", "raw_count.5", "raw_count.6", "percentage_usage.1", "percentage_usage.2", "percentage_usage.3", "percentage_usage.4", "percentage_usage.5", "percentage_usage.6", "deltaPSI", "splicemode")) %>% add_column(., "comparison" = .y)) 

wide_table_of_all_detailed_tables <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble

```

### Import table of differential junctions

```{r}

differential_junction_table <- read.delim(paste(differential_junction_table_path), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

```

### Filter the detailed tables and extract junction IDs

```{r}

# DAMMIT I SCREWED MYSELF OVER
# differential_junction_table$splicemode <- gsub(x = differential_junction_table$splicemode, pattern = "A3SS", replacement = "A3SS_events")
# differential_junction_table$splicemode <- gsub(x = differential_junction_table$splicemode, pattern = "A5SS", replacement = "A5SS_events")
# differential_junction_table$splicemode <- gsub(x = differential_junction_table$splicemode, pattern = "cassette_exon", replacement = "cassette_exon_events")

wide_table_of_all_detailed_tables_diffonly <- dplyr::semi_join(wide_table_of_all_detailed_tables, differential_junction_table, by = c("AS_event_ID", "splicemode"))

AS_junction.IDs <- tibble("junction_ID" = wide_table_of_all_detailed_tables_diffonly$AS_structure_ID %>% gsub(x = ., pattern = "(5|3)_(.*)", replacement = "\\2"))

AS_junction_IDs_split <- AS_junction.IDs$junction_ID %>% gsub(x = ., pattern = "Junction_", replacement = "") %>% strsplit(., split = "_")

AS_junction_IDs_split_2 <- tibble("junction_ID" = paste("Junction_", AS_junction_IDs_split %>% unlist, sep = "")) %>% unique

print(paste("there are", nrow(AS_junction_IDs_split_2), "unique junctions which have been plausibly differentially spliced"))

```

### import the UNION junc coordinate table and filter it for differential junctions we have just found

```{r}

UNION_junc_coor_table <- read.delim(paste(UNION_junc_coor_path), sep = "\t", stringsAsFactors = FALSE, col.names = c("chr", "start", "end", "strand", "junction_ID")) %>% as_tibble

UNION_junc_coor_table_2 <- UNION_junc_coor_table

UNION_junc_coor_table_2[, "strand"] <- gsub(x = UNION_junc_coor_table_2[, "strand"] %>% as.data.frame %>% unlist, pattern = "0", replacement = ".")

UNION_junc_coor_table_3 <- dplyr::semi_join(UNION_junc_coor_table_2, AS_junction_IDs_split_2, by = "junction_ID")

UNION_junc_coor_table_4 <- UNION_junc_coor_table_3 %>% na.omit
UNION_junc_coor_table_4[, "start"] <- UNION_junc_coor_table_4[, "start"] + 1
UNION_junc_coor_table_4[, "end"] <- UNION_junc_coor_table_4[, "end"] + 1

```

### import reference GTF, filter it for transcripts with JUNCTION-FLANKING EXONS ONLY and append to UNION junc coord table

this annotation will be placed as FASTA headers in the custom database.

the plan is to grab reference annotation where possible. If not possible, refer to the reconstructed transcriptome merged from all the timepoints and extract the transcript id.

case 1: flanked by reference transcript: header contains ONLY REF transcript and REF gene name regardless of whether the junction is found in the reconstructed GTF or not
case 2: junction not in ref GTF BUT IS in an annotated gene AND junction IS in reconstructed GTF: header contains REF external gene names, comma separated (no space), transcript id comes from reconstructed GTF, separated by comma.
case 3: junction is not in ref GTF and DOES NOT lie in any annotated gene region: header contains no external gene name (NA) and transcript id(s) come(s) from reconstructed GTF.
case 4: junction is not in either ref nor reconstructed GTF: junction is discarded because there's no way to translate it.

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $chr, $start, $end, $strand and $junction_ID
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons <- function(spliceregion_list, tibble_gtf_table, index) {
  
  # DEBUG ###################

  # spliceregion_list <- UNION_junc_coor_table_4_array.tree[[1833]]
  # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_alltimepoints_reconstructed_gtf
  # index <- 1833

  ###########################

  print(paste("now processing junction number", index))
  
if (spliceregion_list$strand == ".") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "exon", ]
    
  } else if (spliceregion_list$strand == "+" | spliceregion_list$strand == "-") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$strand == spliceregion_list$strand %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "exon", ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks a junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
  
  list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
  
  return(list_of_tibbles_flanking_exon_gtf.entries_per_transcript)
  
}

```

```{r}

# function to extract gene name from reference GTF 
# only FULL overlap considered, where the query junction interval is a subset of any transcript

extract_external.gene.name_from_reference_GTF <- function(spliceregion_list, ref_gtf_table, index) {
  
  # DEBUG ###################

  # spliceregion_list <- UNION_junc_coor_table_4_array.tree[[1]]
  # ref_gtf_table <- tibble_ref_gtf
  # index <- 1

  ###########################

  print(paste("now processing junction number", index))
  
if (spliceregion_list$strand == ".") {
    
    ref_gtf_subset <- ref_gtf_table[ref_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= (spliceregion_list$start %>% as.numeric) & .$end >= (spliceregion_list$end %>% as.numeric), ]
    
  } else if (spliceregion_list$strand == "+" | spliceregion_list$strand == "-") {
    
    ref_gtf_subset <- ref_gtf_table[ref_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= (spliceregion_list$start %>% as.numeric) & .$end >= (spliceregion_list$end %>% as.numeric), ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  column_matched_genes <- ref_gtf_subset$gene_name %>% unique
  
  return(column_matched_genes)
  
}

```

```{r}

# FUNCTION TO RETURN FASTA HEADER FROM MATCHED REF/RECONSTRUCTED GTF ROWS.
# NOTE: to be used with purrr
# input: a list containing ref/reconstructed GTF matches for ONE junction, totalling 4 elements: 1. subsets of reference GTF (by transcript) each containing EXACTLY 2 entries of the reference GTF tibble - these describe the exons flanking the junction. 2. subsets of reconstructed GTF giving similar information. 3. amount of transcripts matched to ref. GTF 4. amount of transcripts matched to reconstructed GTF.

# SUMMARY OF BEHAVIOUR:
# the plan is to grab reference annotation where possible. If not possible, refer to the reconstructed transcriptome merged from all the timepoints and extract the transcript id.
# 
# case 1: flanked by reference transcript: header contains ONLY REF transcript and REF gene name regardless of whether the junction is found in the reconstructed GTF or not
# case 2: junction not in ref GTF BUT IS in an annotated gene AND junction IS in reconstructed GTF: header contains REF external gene names, comma separated (no space), transcript id comes from reconstructed GTF, separated by comma.
# case 3: junction is not in ref GTF and DOES NOT lie in any annotated gene region: header gene name is called "intergenic" and transcript id(s) come(s) from reconstructed GTF.
# case 4: junction is not in either ref nor reconstructed GTF: junction is discarded because there's no way to translate it. header is NA, and we shall execute na.omit to ultimately remove it from the junction co-ordinate table
# 
# FASTA HEADER FORMAT:
# format: >diff.splice.tool_transcript.reconstruction.tool|junction_ID|ENST.id|external_gene_name
# example: >JUM_strawberry|Junction_100084|ENST00000536720.1|ALKBH2

generate_fasta_header_from_subset_gtf <- function(element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length, diff.splice.tool_name, transcript.reconstruction.tool_name) {
  
  # DEBUG ###################

  # diff.splice.tool_name <- "JUM"
  # transcript.reconstruction.tool_name <- "strawberry"

  ###########################
  
  ref_gtf_combined <- element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference_gtf_flanking_exon_entries_per_transcript %>% rbindlist %>% as_tibble
  reconstructed_gtf_combined <- element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed_gtf_flanking_exon_entries_per_transcript %>% rbindlist %>% as_tibble
  
  # case 1
  if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric != 0) {
    
    gene_ids <- ref_gtf_combined$gene_name %>% unique
    
    transcript_ids <- ref_gtf_combined$transcript_id %>% unique
    # case 2
  } else if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0 & element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed.gtf_number.of.transcripts.matched %>% paste %>% as.numeric != 0 &
             length(element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$external_gene_names) != 0) {
    
    gene_ids <- element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$external_gene_names
    transcript_ids <- reconstructed_gtf_combined$transcript_id %>% unique
    # case 3
  } else if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0 & element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed.gtf_number.of.transcripts.matched %>% paste %>% as.numeric != 0 &
             length(element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$external_gene_names) == 0) {
    
    gene_ids <- "intergenic"
    transcript_ids <- reconstructed_gtf_combined$transcript_id %>% unique
    
  }
  
  # case 4
  
  if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0 & element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0) {
    
    fasta_header <- NA
    
  } else {
    
    # format: >diff.splice.tool_transcript.reconstruction.tool|junction_ID|ENST.id|external_gene_name
    # example: >JUM_strawberry|Junction_100084|ENST00000536720.1|ALKBH2
    
    fasta_header <- paste(">", 
                          diff.splice.tool_name, 
                          "_", 
                          transcript.reconstruction.tool_name, 
                          "|", 
                          element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$junction_ID, 
                          "|", 
                          paste(transcript_ids, collapse = ","), 
                          "|",
                          paste(gene_ids, collapse = ","), sep = "")
    
  }
  
  return(fasta_header)
  
}

```

```{r results='hide'}

set.seed(7)

UNION_junc_coor_table_4_array.tree <- UNION_junc_coor_table_4 %>% array_tree

# %>% .[sample(1:100, 20)]

tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

alltimepoints_reconstructed_gtf_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/analysis_strawberry/results_assemblyonly/merged/alltimepoints_denovo_reconstructed_stringtiemerged.gtf"

tibble_alltimepoints_reconstructed_gtf <- rtracklayer::import(alltimepoints_reconstructed_gtf_path) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

# FUNCTION TO ANNOTATE EACH JUNCTION WITH FASTA HEADERS from reference GTF

# format: >diff.splice.tool_transcript.reconstruction.tool|junction_ID|ENST.id|external_gene_name
# example: >JUM_strawberry|Junction_100084|ENST00000536720.1|ALKBH2

list_ref.and.reconstructed_gtf_matching.entries <- future_imap(.x = UNION_junc_coor_table_4_array.tree, .f = ~list("reference_gtf_flanking_exon_entries_per_transcript" = extract_junction.flanking.exons(.x, tibble_ref_gtf, .y), "reconstructed_gtf_flanking_exon_entries_per_transcript" = extract_junction.flanking.exons(.x, tibble_alltimepoints_reconstructed_gtf, .y), "external_gene_names" = extract_external.gene.name_from_reference_GTF(.x, tibble_ref_gtf, .y), "junction_ID" = .x$junction_ID), .progress = TRUE, .options = future_options(globals = c("UNION_junc_coor_table_4_array.tree", "tibble_ref_gtf", "tibble_alltimepoints_reconstructed_gtf", "extract_junction.flanking.exons", "extract_external.gene.name_from_reference_GTF")))

list_ref.and.reconstructed_gtf_matching.entries_with.length <- purrr::map(.x = list_ref.and.reconstructed_gtf_matching.entries, .f = ~purrr::splice(.x, "reference.gtf_number.of.transcripts.matched" = length(.x$reference_gtf_flanking_exon_entries_per_transcript), "reconstructed.gtf_number.of.transcripts.matched" = length(.x$reconstructed_gtf_flanking_exon_entries_per_transcript)))

list_fasta_headers <- purrr::map(.x = list_ref.and.reconstructed_gtf_matching.entries_with.length, .f = ~generate_fasta_header_from_subset_gtf(.x, "JUM", "strawberry"))

UNION_junc_coor_table_5 <- add_column(UNION_junc_coor_table_4, "fasta_header" = list_fasta_headers %>% unlist)

UNION_junc_coor_table_5 <- UNION_junc_coor_table_5 %>% na.omit

print(paste("Number of junctions before filtering:", nrow(UNION_junc_coor_table_4)))
print(paste("Number of junctions after filtering, translatable:", nrow(UNION_junc_coor_table_5)))
print(paste("Number of junctions filtered out:", (nrow(UNION_junc_coor_table_4) - nrow(UNION_junc_coor_table_5))))

```

### export final UNION_junc_coor table

```{r}

write.table(UNION_junc_coor_table_5, file = paste(output_dir, output_file_name, ".txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

write.table(UNION_junc_coor_table_5[sample(1:nrow(UNION_junc_coor_table_5), 20), ], file = paste(output_dir, output_file_name, ".txt_test", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

write.table(dplyr::anti_join(UNION_junc_coor_table_3, UNION_junc_coor_table_5, by = "junction_ID"), file = paste(output_dir, output_file_name, "_discardedjunctions.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

write.table(wide_table_of_all_detailed_tables_diffonly, file = paste(output_dir, output_file_name, "_detailedtables.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

### write final junction table as .bed file

```{r}

junc_bed_table <- UNION_junc_coor_table_5[, c("chr", "start", "end", "junction_ID", "strand")] %>% setNames(c("chr", "start", "end", "name", "strand")) %>% add_column(., "score" = 1000, .after = "name")

cat(paste("track name=\"Splice Junctions\" description=\"", output_file_name, "\" graphType=junctions\n", sep = ""), file = paste(output_dir, output_file_name, ".bed", sep = ""))
write.table(junc_bed_table, file = paste(output_dir, output_file_name, ".bed", sep = ""), sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)

```
