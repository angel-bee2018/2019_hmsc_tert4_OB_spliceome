---
title: "A workspace to design the functions to add in the FASTA headers for exons or junctions"
author: "Angel Liang"
date: "11/01/2020"
output: html_document
---

# Set the running environment

## Packages

```{r}

library(tidyverse)
library(data.table)
library(rtracklayer)

# library(biomaRt)
# ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

library(furrr)
future::plan(multiprocess)
options(future.globals.maxSize = 30000000000)

```

## Global directories

```{r}

output_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_database_generation/angel_3FT_junctions/"
output_file_name_JUM <- "junction_table_OBseries_SOM_1663_junctions_any_qvalue0.01_any_deltaPSI_greaterthan_0.2"


```

## Functions

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $chr, $start, $end, $strand and $junction_ID
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons <- function(spliceregion_list, tibble_gtf_table, index) {
  
  # DEBUG ###################

  # spliceregion_list <- UNION_junc_coor_table_4_array.tree[[1833]]
  # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_alltimepoints_reconstructed_gtf
  # index <- 1833

  ###########################

  print(paste("now processing junction number", index))
  
if (spliceregion_list$strand == ".") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "exon", ]
    
  } else if (spliceregion_list$strand == "+" | spliceregion_list$strand == "-") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$strand == spliceregion_list$strand %>% trimws, ] %>% .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 2) & .$end >= ((spliceregion_list$start %>% as.numeric) + 2)), ] %>% .[.$type == "exon", ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks a junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
  
  list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
  
  return(list_of_tibbles_flanking_exon_gtf.entries_per_transcript)
  
}

```

```{r}

# function to extract gene name from reference GTF 
# only FULL overlap considered, where the query junction interval is a subset of any transcript

extract_external.gene.name_from_reference_GTF <- function(spliceregion_list, ref_gtf_table, index) {
  
  # DEBUG ###################

  # spliceregion_list <- UNION_junc_coor_table_4_array.tree[[1]]
  # ref_gtf_table <- tibble_ref_gtf
  # index <- 1

  ###########################

  print(paste("now processing junction number", index))
  
if (spliceregion_list$strand == ".") {
    
    ref_gtf_subset <- ref_gtf_table[ref_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= (spliceregion_list$start %>% as.numeric) & .$end >= (spliceregion_list$end %>% as.numeric), ]
    
  } else if (spliceregion_list$strand == "+" | spliceregion_list$strand == "-") {
    
    ref_gtf_subset <- ref_gtf_table[ref_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% .[.$start <= (spliceregion_list$start %>% as.numeric) & .$end >= (spliceregion_list$end %>% as.numeric), ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  column_matched_genes <- ref_gtf_subset$gene_name %>% unique
  
  return(column_matched_genes)
  
}

```

```{r}

# FUNCTION TO RETURN FASTA HEADER FROM MATCHED REF/RECONSTRUCTED GTF ROWS.
# NOTE: to be used with purrr
# input: a list containing ref/reconstructed GTF matches for ONE junction, totalling 4 elements: 1. subsets of reference GTF (by transcript) each containing EXACTLY 2 entries of the reference GTF tibble - these describe the exons flanking the junction. 2. subsets of reconstructed GTF giving similar information. 3. amount of transcripts matched to ref. GTF 4. amount of transcripts matched to reconstructed GTF.

# SUMMARY OF BEHAVIOUR:
# the plan is to grab reference annotation where possible. If not possible, refer to the reconstructed transcriptome merged from all the timepoints and extract the transcript id.
# 
# case 1: flanked by reference transcript: header contains ONLY REF transcript and REF gene name regardless of whether the junction is found in the reconstructed GTF or not
# case 2: junction not in ref GTF BUT IS in an annotated gene AND junction IS in reconstructed GTF: header contains REF external gene names, comma separated (no space), transcript id comes from reconstructed GTF, separated by comma.
# case 3: junction is not in ref GTF and DOES NOT lie in any annotated gene region: header gene name is called "intergenic" and transcript id(s) come(s) from reconstructed GTF.
# case 4: junction is not in either ref nor reconstructed GTF: junction is discarded because there's no way to translate it. header is NA, and we shall execute na.omit to ultimately remove it from the junction co-ordinate table
# 
# FASTA HEADER FORMAT:
# format: >diff.splice.tool_transcript.reconstruction.tool|junction_ID|ENST.id|external_gene_name
# example: >JUM_strawberry|Junction_100084|ENST00000536720.1|ALKBH2

generate_fasta_header_from_subset_gtf <- function(element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length, diff.splice.tool_name, transcript.reconstruction.tool_name) {
  
  # DEBUG ###################

  # diff.splice.tool_name <- "JUM"
  # transcript.reconstruction.tool_name <- "strawberry"

  ###########################
  
  ref_gtf_combined <- element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference_gtf_flanking_exon_entries_per_transcript %>% rbindlist %>% as_tibble
  reconstructed_gtf_combined <- element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed_gtf_flanking_exon_entries_per_transcript %>% rbindlist %>% as_tibble
  
  # case 1
  if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric != 0) {
    
    gene_ids <- ref_gtf_combined$gene_name %>% unique
    
    transcript_ids <- ref_gtf_combined$transcript_id %>% unique
    # case 2
  } else if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0 & element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed.gtf_number.of.transcripts.matched %>% paste %>% as.numeric != 0 &
             length(element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$external_gene_names) != 0) {
    
    gene_ids <- element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$external_gene_names
    transcript_ids <- reconstructed_gtf_combined$transcript_id %>% unique
    # case 3
  } else if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0 & element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed.gtf_number.of.transcripts.matched %>% paste %>% as.numeric != 0 &
             length(element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$external_gene_names) == 0) {
    
    gene_ids <- "intergenic"
    transcript_ids <- reconstructed_gtf_combined$transcript_id %>% unique
    
  }
  
  # case 4
  
  if (element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reference.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0 & element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$reconstructed.gtf_number.of.transcripts.matched %>% paste %>% as.numeric == 0) {
    
    fasta_header <- NA
    
  } else {
    
    # format: >diff.splice.tool_transcript.reconstruction.tool|junction_ID|ENST.id|external_gene_name
    # example: >JUM_strawberry|Junction_100084|ENST00000536720.1|ALKBH2
    
    fasta_header <- paste(">", 
                          diff.splice.tool_name, 
                          "_", 
                          transcript.reconstruction.tool_name, 
                          "|", 
                          element_of_list_ref.and.reconstructed_gtf_matching.entries_with.length$junction_ID, 
                          "|", 
                          paste(transcript_ids, collapse = ","), 
                          " OS=",
                          paste(species.name, collapse = ","), 
                          " GN=",
                          paste(gene_ids, collapse = ","), sep = "")
    
  }
  
  return(fasta_header)
  
}

```

# Pooling AS junction co-ordinates from JUM

accepts:
1. table of differential junctions (result from JUM), must contain AS_event_ID and splicemode columns
2. all the detailed tables used in analysis, as is (untouched)
3. UNION_junc_coor file from JUM, which contains all the junction ID to genome co-ordinate mapping.

## Directories

```{r}

JUM_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/"

differential_junction_table_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/5x5_SOM_1663_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.2.txt"

UNION_junc_coor_path <- "Y:/PGNEXUS_OBseries/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

output_file_name <- "junction_table_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.2"

```

## Import the detailed tables into the environment

```{r message=FALSE, warning=FALSE}

list_of_timepoint_comparisons_final <- read.delim(paste(JUM_results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree %>% flatten

list_of_AS_events <- c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events") %>% array_tree %>% flatten

# read tables into environment

list_of_detailed_tables <- future_map(.x = list_of_timepoint_comparisons_final, .f = ~purrr::map2(.x = .x, .y = list_of_AS_events, .f = ~read.delim(file = paste(JUM_results_dir, "final_JUM_output_", .x, "/", list.files(path = paste(JUM_results_dir, "final_JUM_output_", .x, "/", sep = ""), pattern = paste("(.)", .y, "(.*)detailed.txt", sep = "")), sep = ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble %>% add_column(., "splicemode" = .y)) %>% set_names(list_of_AS_events), .progress = TRUE) %>% set_names(list_of_timepoint_comparisons_final)

# bind rows for each comparison

list_of_detailed_tables_2 <- list_of_detailed_tables %>% purrr::map(.x = ., .f = ~rbindlist(.x))

# rename the colnames to be not comparison-specific - we will add a comparison column later on

list_of_detailed_tables_3 <- purrr::map2(.x = list_of_detailed_tables_2, .y = list_of_timepoint_comparisons_final, .f = ~setNames(., c("Gene", "AS_event_ID", "AS_structure_ID", "sub_junction_ID", "sub-junction_dispersion_estimate", "LRT_statistic-full_vs_reduced", "LRT_p_value-full_vs_reduced", "BH_adjusted_p-values", "logCPM_1", "logCPM_2", "fitting_parameter_log2fold_change_2_from_1", "sub_junction_chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand", "raw_count.1", "raw_count.2", "raw_count.3", "raw_count.4", "raw_count.5", "raw_count.6", "percentage_usage.1", "percentage_usage.2", "percentage_usage.3", "percentage_usage.4", "percentage_usage.5", "percentage_usage.6", "deltaPSI", "splicemode")) %>% add_column(., "comparison" = .y)) 

wide_table_of_all_detailed_tables <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble

```

### Import table of differential junctions

```{r}

differential_junction_table <- read.delim(paste(differential_junction_table_path), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

```

### Filter the detailed tables and extract junction IDs

```{r}

# DAMMIT I SCREWED MYSELF OVER
# differential_junction_table$splicemode <- gsub(x = differential_junction_table$splicemode, pattern = "A3SS", replacement = "A3SS_events")
# differential_junction_table$splicemode <- gsub(x = differential_junction_table$splicemode, pattern = "A5SS", replacement = "A5SS_events")
# differential_junction_table$splicemode <- gsub(x = differential_junction_table$splicemode, pattern = "cassette_exon", replacement = "cassette_exon_events")

wide_table_of_all_detailed_tables_diffonly <- dplyr::semi_join(wide_table_of_all_detailed_tables, differential_junction_table, by = c("AS_event_ID", "splicemode"))

AS_junction.IDs <- tibble("junction_ID" = wide_table_of_all_detailed_tables_diffonly$AS_structure_ID %>% gsub(x = ., pattern = "(5|3)_(.*)", replacement = "\\2"))

AS_junction_IDs_split <- AS_junction.IDs$junction_ID %>% gsub(x = ., pattern = "Junction_", replacement = "") %>% strsplit(., split = "_")

AS_junction_IDs_split_2 <- tibble("junction_ID" = paste("Junction_", AS_junction_IDs_split %>% unlist, sep = "")) %>% unique

print(paste("there are", nrow(AS_junction_IDs_split_2), "unique junctions which have been plausibly differentially spliced"))

```

### import the UNION junc coordinate table and filter it for differential junctions we have just found

```{r}

UNION_junc_coor_table <- read.delim(paste(UNION_junc_coor_path), sep = "\t", stringsAsFactors = FALSE, col.names = c("chr", "start", "end", "strand", "junction_ID")) %>% as_tibble

UNION_junc_coor_table_2 <- UNION_junc_coor_table

UNION_junc_coor_table_2[, "strand"] <- gsub(x = UNION_junc_coor_table_2[, "strand"] %>% as.data.frame %>% unlist, pattern = "0", replacement = ".")

UNION_junc_coor_table_3 <- dplyr::semi_join(UNION_junc_coor_table_2, AS_junction_IDs_split_2, by = "junction_ID")

UNION_junc_coor_table_4 <- UNION_junc_coor_table_3 %>% na.omit
UNION_junc_coor_table_4[, "start"] <- UNION_junc_coor_table_4[, "start"] + 1
UNION_junc_coor_table_4[, "end"] <- UNION_junc_coor_table_4[, "end"] + 1

tibble_junction_table <- UNION_junc_coor_table_4

```

### import reference GTF, filter it for transcripts with JUNCTION-FLANKING EXONS ONLY and append to UNION junc coord table

this annotation will be placed as FASTA headers in the custom database.

the plan is to grab reference annotation where possible. If not possible, refer to the reconstructed transcriptome merged from all the timepoints and extract the transcript id.

case 1: flanked by reference transcript: header contains ONLY REF transcript and REF gene name regardless of whether the junction is found in the reconstructed GTF or not
case 2: junction not in ref GTF BUT IS in an annotated gene AND junction IS in reconstructed GTF: header contains REF external gene names, comma separated (no space), transcript id comes from reconstructed GTF, separated by comma.
case 3: junction is not in ref GTF and DOES NOT lie in any annotated gene region: header contains no external gene name (NA) and transcript id(s) come(s) from reconstructed GTF.
case 4: junction is not in either ref nor reconstructed GTF: junction is discarded because there's no way to translate it.

```{r results='hide'}

set.seed(7)

tibble_junction_table_array.tree <- tibble_junction_table %>% array_tree

# %>% .[sample(1:100, 20)]

tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

alltimepoints_reconstructed_gtf_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_strawberry/results_assemblyonly/merged/alltimepoints_denovo_reconstructed_stringtiemerged.gtf"

tibble_alltimepoints_reconstructed_gtf <- rtracklayer::import(alltimepoints_reconstructed_gtf_path) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

# get junction-flanking exon matches for IR events
list_ref_matching_junction_entries <- future_imap(.x = tibble_junction_table_array.tree, .f = ~list(
  "chr" = .x$chr,
  "start" = .x$start,
  "end" = .x$end,
  "strand" = .x$strand,
  "reference_gtf_match" = extract_junction.flanking.exons(.x, tibble_ref_gtf, .y), 
  "reconstructed_gtf_match" = extract_junction.flanking.exons(.x, tibble_alltimepoints_reconstructed_gtf, .y)), 
  .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_alltimepoints_reconstructed_gtf", "extract_junction.flanking.exons", "data.table", "tibble")))

# turn those GTF matches into gene/transcript names
list_annotated_junction_entries <- future_map(.x = list_ref_matching_junction_entries, .f = ~annotate_matched_entries(.x) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("annotate_matched_entries")))

# collapse list into tibble
tibble_annotated_junction_entries <- list_annotated_junction_entries %>% rbindlist %>% as_tibble

# remove whitespace because it can cause problems
tibble_annotated_junction_entries[, "chr"] <- tibble_annotated_junction_entries$chr %>% trimws
tibble_annotated_junction_entries[, "start"] <- tibble_annotated_junction_entries$start %>% trimws
tibble_annotated_junction_entries[, "end"] <- tibble_annotated_junction_entries$end %>% trimws
tibble_annotated_junction_entries[, "strand"] <- tibble_annotated_junction_entries$strand %>% trimws
tibble_annotated_junction_entries <- tibble_annotated_junction_entries %>% type_convert

# add exon width column for filtering baseed on exon length
tibble_annotated_junction_entries <- tibble_annotated_junction_entries %>% add_column("width" = tibble_annotated_junction_entries$end - tibble_annotated_junction_entries$start + 1)

# remove junctions that did not have a match in either reference nor reconstructed GTF
## get row indices which have NA for both matched gene name and transcript name
row.indices_rows_with_non_translatable <- which(is.na(tibble_annotated_junction_entries$matched_gene_names) & is.na(tibble_annotated_junction_entries$matched_recon_transcript_names))
                                                
cat("Number of exons before filtering:", nrow(tibble_annotated_junction_entries), "\n")
cat("Number of untranslatable exons:", length(row.indices_rows_with_non_translatable), "\n")
cat("Percentage untranslatable:", length(row.indices_rows_with_non_translatable) * 100/nrow(tibble_annotated_junction_entries), "% \n")

# filter out all the non-translatable exons
tibble_ref_matching_junction_entries_all_translatable <- tibble_annotated_junction_entries[-row.indices_rows_with_non_translatable, ]

# add identifier column
tibble_ref_matching_junction_entries_all_translatable <- tibble_ref_matching_junction_entries_all_translatable %>% add_column("identifier" = paste(tibble_ref_matching_junction_entries_all_translatable$chr, ":", tibble_ref_matching_junction_entries_all_translatable$start, "-", tibble_ref_matching_junction_entries_all_translatable$end, ":", as.numeric(paste(tibble_ref_matching_junction_entries_all_translatable$strand, "1", sep = "")), sep = ""))

```

## Join the matched gene/transcript names back onto original table, add in fasta header

```{r}

tibble_junction_table_matched <- dplyr::left_join(tibble_ref_matching_junction_entries_all_translatable, tibble_junction_table)

tibble_junction_table_matched_with_fasta_header <- tibble_junction_table_matched %>% add_column("fasta_header" = convert_annotation_to_fasta_header(
                                                                                            diff.splice.tool_name = "psi.sigma", 
                                                                                            transcript.reconstruction.tool_name = "strawberry", 
                                                                                            identifier = tibble_junction_table_matched$identifier, 
                                                                                            transcript_ids = tibble_junction_table_matched$matched_recon_transcript_names, 
                                                                                            species_name = "Homo sapiens", 
                                                                                            gene_id = tibble_junction_table_matched$matched_gene_names))

```

### export final fasta table

```{r}

# write the final fasta info table
write.table(tibble_junction_table_matched_with_fasta_header, file = paste(output_dir, output_file_name_JUM, ".txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# write a test version consisting of 20 rows selected at random
write.table(tibble_junction_table_matched_with_fasta_header[sample(1:nrow(tibble_junction_table_matched_with_fasta_header), 20), ], file = paste(output_dir, output_file_name_JUM, ".txt_test", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# output the discarded entries
write.table(dplyr::anti_join(tibble_junction_table, tibble_junction_table_matched_with_fasta_header), file = paste(output_dir, output_file_name_JUM, "_discarded.entries.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

### write final junction table as .bed file

```{r}

junc_bed_table <- tibble_junction_table_matched_with_fasta_header[, c("chr", "start", "end", "identifier", "strand")] %>% setNames(c("chr", "start", "end", "name", "strand")) %>% add_column(., "score" = 1000, .after = "name")

write.table(junc_bed_table, file = paste(output_dir, output_file_name_JUM, ".bed", sep = ""), sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE, append = FALSE)

```

# Adding FASTA header to PSI-Sigma exons

## Set the running environment

### Packages

```{r}

library(tidyverse)
library(data.table)
library(rtracklayer)

# library(biomaRt)
# ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

library(furrr)
future::plan(multiprocess)
options(future.globals.maxSize = 30000000000, mc.cores = 4)

```

## Set environment

```{r}

output_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_exons/"

if(! dir.exists(output_dir) ) {
     dir.create(output_dir, recursive = TRUE)}

output_file_name_PSI.Sigma <- "exon_table_OB_diff_dpsi10_anypvalue0.01_3272_exons_anysig_with_na"


table_of_exon_coords_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_2_psi.sigma.1.9_in_parallel/R_processing_results/table_of_all_differential_exons_coords_10_anypvalue0.01_3272_exons_anysig_with_na.txt"

ref_gtf_path <- "Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf"

alltimepoints_reconstructed_gtf_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_strawberry/results_assemblyonly/merged/alltimepoints_denovo_reconstructed_stringtiemerged.gtf"

splicemode_column_name <- "splicemode"
IR_regex_string <- "IR"

```

## Define functions

```{r}

# FUNCTION to extract the information from matched GTF entries.
# input: a list containing ref + recon GTF entries, a single element of a list of all the matches for each exon.
# things to annotate: gene name, strand, all exons are NMD in the reference GTF, first/last/only exon in reference or recon. GTF

annotate_matched_entries <- function(list_matched_ref_recon_gtf) {
  
  # DEBUG ######
  
  # list_matched_ref_recon_gtf <- list_ref_matching_exon_entries[[2]]
  
  ##############
  
  # gene name
  matched_gene_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reference_gtf_match"]]) != 0) {
    
    matched_gene_names <- paste(list_matched_ref_recon_gtf[["reference_gtf_match"]]$gene_name %>% unique, collapse = ",")
    
  }
  
  # transcript name (recon)
  matched_recon_transcript_names <- NA
  
  if (nrow(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]) != 0) {
    
    matched_recon_transcript_names <- paste(list_matched_ref_recon_gtf[["reconstructed_gtf_match"]]$transcript_id %>% unique, collapse = ",")
    
  }
  
  return(list("chr" = list_matched_ref_recon_gtf$chr,
              "start" = list_matched_ref_recon_gtf$start,
              "end" = list_matched_ref_recon_gtf$end,
              "strand" = list_matched_ref_recon_gtf$strand,
              "matched_gene_names" = matched_gene_names,
              "matched_recon_transcript_names" = matched_recon_transcript_names))
  
}

```

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $diff_exon_chr, $diff_exon_start, $diff_exon_end
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons <- function(spliceregion_list, tibble_gtf_table, index) {
  
  # DEBUG ###################

  # index <- 1
  # spliceregion_list <- wide_tibble_of_all_unique_exon_coords_array.tree[[3]]
  # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_alltimepoints_reconstructed_gtf
  
  ###########################

  print(paste("now processing junction number", index))
  
  # +/- 1 nt tolerance
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% 
      .[.$start <= ((spliceregion_list$end %>% as.numeric) + 2) & .$end >= ((spliceregion_list$start %>% as.numeric) - 2), ] %>% 
      .[!(.$start <= ((spliceregion_list$end %>% as.numeric) - 1) & .$end >= ((spliceregion_list$start %>% as.numeric) + 1)), ] %>% 
      .[.$type == "exon", ]
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks the junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% as.numeric)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% as.numeric) - (.x[1, "exon_number"] %>% paste %>% as.numeric)) == 1)
    
    tibbles_all_flanking_exon_gtf.entries_per_transcript <- list_of_tibbles_flanking_exon_gtf.entries_per_transcript %>% rbindlist %>% as_tibble
  
  return(tibbles_all_flanking_exon_gtf.entries_per_transcript)
  
}

```

```{r}

# FUNCTION TO EXTRACT REFERENCE EXONS WHICH OVERLAP EXACTLY WITH QUERY EXONS
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $diff_exon_chr, $diff_exon_start, $diff_exon_end
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_overlapping.exons <- function(spliceregion_list, tibble_gtf_table, index) {
  
  # DEBUG ###################
# 
#   index <- 1
#   spliceregion_list <- wide_tibble_of_all_unique_exon_coords_array.tree[[index]]
#   # tibble_gtf_table <- tibble_ref_gtf
#   tibble_gtf_table <- tibble_alltimepoints_reconstructed_gtf
  
  ###########################

  print(paste("now processing junction number", index))
  
  # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == spliceregion_list$chr %>% trimws, ] %>% 
      .[.$start > ((spliceregion_list$start %>% as.numeric) - 2) & .$end < ((spliceregion_list$end %>% as.numeric) + 2), ] %>% 
      .[(.$start < ((spliceregion_list$start %>% as.numeric) + 2) & .$end > ((spliceregion_list$end %>% as.numeric) - 2)), ] %>% 
      .[.$type == "exon", ]
  
  return(tibble_gtf_subset_overlapping_exons)
  
}

```

```{r}

# FUNCTION TO MAKE A FASTA HEADER FROM RESULTS OF MATCHING
convert_annotation_to_fasta_header <- function(diff.splice.tool_name, transcript.reconstruction.tool_name, identifier, transcript_ids, species_name, gene_id) {
  
  # format is like UniProt: >diff.splice.tool_transcript.reconstruction.tool|identifier|ENST.id OS=organism GN=external_gene_name
# example: >JUM_strawberry|12:1000232-1000250|ENST00000536720.1 OS=Homo sapiens GN=ALKBH2

fasta_header <- paste(">", 
                      diff.splice.tool_name, 
                      "_", 
                      transcript.reconstruction.tool_name, 
                      "|", 
                      identifier, 
                      "|", 
                      transcript_ids, 
                      " OS=",
                      species_name, 
                      " GN=",
                      gene_id, sep = "")

return(fasta_header)
  
}

```

## Import reference and reconstructed GTF

```{r}

tibble_ref_gtf <- rtracklayer::import(ref_gtf_path) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_alltimepoints_reconstructed_gtf <- rtracklayer::import(alltimepoints_reconstructed_gtf_path) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

```

## Import table of exon coords

```{r}

tibble_exon_coords <- read.delim(file = table_of_exon_coords_path, sep = "", stringsAsFactors = FALSE) %>% mutate_if(is.factor, as.character) %>% as_tibble

```

## Process the IR entries using junction method

```{r}

tibble_exon_coords_array.tree_IR <- tibble_exon_coords[grep(x = tibble_exon_coords[, splicemode_column_name] %>% unlist, pattern = IR_regex_string), ] %>% array_tree

# get junction-flanking exon matches for IR events
list_ref_matching_exon_entries_IR <- future_imap(.x = tibble_exon_coords_array.tree_IR, .f = ~list(
  "chr" = .x$chr,
  "start" = .x$start,
  "end" = .x$end,
  "strand" = .x$strand,
  "reference_gtf_match" = extract_junction.flanking.exons(.x, tibble_ref_gtf, .y), 
  "reconstructed_gtf_match" = extract_junction.flanking.exons(.x, tibble_alltimepoints_reconstructed_gtf, .y)), 
  .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_alltimepoints_reconstructed_gtf", "extract_junction.flanking.exons", "data.table", "tibble")))

list_ref_matching_exon_entries_IR <- future_map(.x = list_ref_matching_exon_entries_IR, .f = ~annotate_matched_entries(.x) %>% as_tibble, .progress = TRUE)

```

## Process non-IR entries using exon method

```{r}

tibble_exon_coords_array.tree_not_IR <- tibble_exon_coords[-grep(x = tibble_exon_coords[, splicemode_column_name] %>% unlist, pattern = IR_regex_string), ] %>% array_tree

# get overlapping exon matches for non-IR events
list_ref_matching_exon_entries_not_IR <- future_imap(.x = tibble_exon_coords_array.tree_not_IR, .f = ~list(
  "chr" = .x$chr,
  "start" = .x$start,
  "end" = .x$end,
  "strand" = .x$strand,
  "reference_gtf_match" = extract_overlapping.exons(.x, tibble_ref_gtf, .y), 
  "reconstructed_gtf_match" = extract_overlapping.exons(.x, tibble_alltimepoints_reconstructed_gtf, .y)), 
  .progress = TRUE, .options = future_options(globals = c("tibble_ref_gtf", "tibble_alltimepoints_reconstructed_gtf", "extract_junction.flanking.exons", "data.table", "tibble")))

list_ref_matching_exon_entries_not_IR <- future_map(.x = list_ref_matching_exon_entries_not_IR, .f = ~annotate_matched_entries(.x) %>% as_tibble, .progress = TRUE)

```

## Merge both IR and non-IR results and remove untranslatable exons

```{r}

tibble_ref_matching_exon_entries_all <- dplyr::bind_rows(list_ref_matching_exon_entries_IR %>% rbindlist, list_ref_matching_exon_entries_not_IR %>% rbindlist) %>% as_tibble

# remove whitespace because it can cause problems
tibble_ref_matching_exon_entries_all[, "chr"] <- tibble_ref_matching_exon_entries_all$chr %>% trimws
tibble_ref_matching_exon_entries_all[, "start"] <- tibble_ref_matching_exon_entries_all$start %>% trimws
tibble_ref_matching_exon_entries_all[, "end"] <- tibble_ref_matching_exon_entries_all$end %>% trimws
tibble_ref_matching_exon_entries_all[, "strand"] <- tibble_ref_matching_exon_entries_all$strand %>% trimws
tibble_ref_matching_exon_entries_all <- tibble_ref_matching_exon_entries_all %>% type_convert

# add exon width column for filtering baseed on exon length
tibble_ref_matching_exon_entries_all <- tibble_ref_matching_exon_entries_all %>% add_column("width" = tibble_ref_matching_exon_entries_all$end - tibble_ref_matching_exon_entries_all$start + 1)

# write.table(tibble_ref_matching_exon_entries_all, file = paste(R_processing_results_dir, "table_all_exons_reference_match_info.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# remove exons that did not have a match in either reference nor reconstructed GTF, and are short exons
## get row indices which have NA for both matched gene name and transcript name, and are less than 100 nt long
row.indices_rows_with_non_translatable <- which(is.na(tibble_ref_matching_exon_entries_all$matched_gene_names) & is.na(tibble_ref_matching_exon_entries_all$matched_recon_transcript_names))
                                                
# & tibble_ref_matching_exon_entries_all$width < 99)

cat("Number of exons before filtering:", nrow(tibble_ref_matching_exon_entries_all), "\n")
cat("Number of untranslatable exons:", length(row.indices_rows_with_non_translatable), "\n")
cat("Percentage untranslatable:", length(row.indices_rows_with_non_translatable) * 100/nrow(tibble_ref_matching_exon_entries_all), "% \n")

# filter out all the non-translatable exons
tibble_ref_matching_exon_entries_all_translatable <- tibble_ref_matching_exon_entries_all[-row.indices_rows_with_non_translatable, ]

# add identifier column
tibble_ref_matching_exon_entries_all_translatable <- tibble_ref_matching_exon_entries_all_translatable %>% add_column("identifier" = paste(tibble_ref_matching_exon_entries_all_translatable$chr, ":", tibble_ref_matching_exon_entries_all_translatable$start, "-", tibble_ref_matching_exon_entries_all_translatable$end, ":", as.numeric(paste(tibble_ref_matching_exon_entries_all_translatable$strand, "1", sep = "")), sep = ""))

# for translatable exons with no match to reference/recon. GTF, use "nomatch" as transcript name
## get row indices where both gene name and transcript name is NA
# row.indices_rows_with_na <- which(is.na(tibble_ref_matching_exon_entries_all_translatable$matched_gene_names) & is.na(tibble_ref_matching_exon_entries_all_translatable$matched_recon_transcript_names))

# tibble_ref_matching_exon_entries_all_translatable[row.indices_rows_with_na, "matched_recon_transcript_names"] <- "nomatch"

```

## Join the matched gene/transcript names back onto original table, add in fasta header

```{r}

tibble_exon_coords_matched <- dplyr::left_join(tibble_ref_matching_exon_entries_all_translatable, tibble_exon_coords[, c("chr", "start", "end", "strand", splicemode_column_name)])

tibble_exon_coords_matched_with_fasta_header <- tibble_exon_coords_matched %>% add_column("fasta_header" = convert_annotation_to_fasta_header(
                                                                                            diff.splice.tool_name = "psi.sigma", 
                                                                                            transcript.reconstruction.tool_name = "strawberry", 
                                                                                            identifier = tibble_exon_coords_matched$identifier, 
                                                                                            transcript_ids = tibble_exon_coords_matched$matched_recon_transcript_names, 
                                                                                            species_name = "Homo sapiens", 
                                                                                            gene_id = tibble_exon_coords_matched$matched_gene_names))

```

### export final fasta table

```{r}

# write the final fasta info table
write.table(tibble_exon_coords_matched_with_fasta_header, file = paste(output_dir, output_file_name_PSI.Sigma, ".txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# write a test version consisting of 20 rows selected at random
write.table(tibble_exon_coords_matched_with_fasta_header[sample(1:nrow(tibble_exon_coords_matched_with_fasta_header), 20), ], file = paste(output_dir, output_file_name_PSI.Sigma, ".txt_test", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# output the discarded entries
write.table(dplyr::anti_join(tibble_exon_coords, tibble_exon_coords_matched_with_fasta_header), file = paste(output_dir, output_file_name_PSI.Sigma, "_discarded.entries.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

### write final junction table as .bed file

```{r}

exon_bed_table <- tibble_exon_coords_matched_with_fasta_header[, c("chr", "start", "end", "identifier", "strand")] %>% setNames(c("chr", "start", "end", "name", "strand")) %>% add_column(., "score" = 1000, .after = "name")

# cat(paste("track name=\"Alternative exons\" description=\"", output_file_name_PSI.Sigma, "\" graphType=junctions\n", sep = ""), file = paste(output_dir, output_file_name, ".bed", sep = ""))
write.table(exon_bed_table, file = paste(output_dir, output_file_name_PSI.Sigma, ".bed", sep = ""), sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE, append = FALSE)

```
