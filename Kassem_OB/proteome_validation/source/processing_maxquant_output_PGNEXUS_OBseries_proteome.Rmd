---
title: "Processing MaxQuant output for proteomic validation of PGNEXUS OB RNA-Seq data"
author: "Angel Liang"
date: "22/02/2020"
output: html_document
---


# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
# library(gtools)
# library(extrafont)
# loadfonts(device="win")
windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)


library(ggplot2)
# library(kohonen)
# library(genefilter)
# library(gplots)
# library(lattice)
# library(svglite)
# library(scales)

library(biomaRt)
ensembl_mart = useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host = "www.ensembl.org")
library(systemPipeR)
# library(GOstats)
# library(PFAM.db)
# library(bc3net)
# 
# library(ggdendro)
library(data.table)
library(seqinr)
# library(Rfast)

# maxquant_junctions.3FT_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_maxquant/run_1_PGNEXUS_OBseries_allsamples_angel.junctions.3FT/txt/"

R_processing_results_dir <- paste("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/", sep = "")

if(! dir.exists(R_processing_results_dir) ) {
     dir.create(R_processing_results_dir, recursive = TRUE)}

`3FT_results_dir` <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/three_frame_translation_results/"

```

## define functions

### FUNCTION TO PLOT PCA FOR TIMEPOINT AND REPLICATE

```{r}

plot_PCA_for_timepoint_and_replicate <- function(matrixtable, timepoint_order = NULL, replicate_order = NULL, PCA_depths_y = NULL, PCA_depths_x = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL) {
  
  # DEBUG ###
  # save_dir <- R_processing_results_dir
  # save_name <- "raw_MQ_intensities"
  # 
  # graph_title <- paste(.y[[1]], "\n", .y[[2]], sep = "")
  # 
  # timepoint_order <- c("ud_1_24", "ud_30_6", "30m", "1h", "6h", "1d")
  # replicate_order <- vector_replicate_names
  # 
  # PCA_depths_y <- c(2, 3, 4)
  # PCA_depths_x <- c(1, 2, 3)
  ###########
  
  PCA_result <- prcomp(matrixtable)
  
  ## measure PC variance #
  PCA_stdev <- tibble("PC" = 1:(PCA_result[["sdev"]] %>% length), "stdev" = PCA_result[["sdev"]])
  
  PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
  PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)
  
  ggplot(PCA_variance) + 
    geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
    scale_fill_gradientn(colours = heat.colors(n = (PCA_result[["sdev"]] %>% length))) +
    ggtitle(paste("PCA variance distribution\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("PC") +
    ylab("Variance explained (%)") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

  ## measure PC loadings #
  ## column names of the matrix need to be split by a "|", like this: timepoint|replicatenumber
  PCA_loadings <- PCA_result[["rotation"]] %>% as_tibble(rownames = "sample")
  PCA_loadings <- add_column(PCA_loadings, "timepoint" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1") %>% factor(x = ., levels = timepoint_order))
  PCA_loadings <- add_column(PCA_loadings, "replicatenumber" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2") %>% factor(x = ., levels = replicate_order))
  
  # plot PCA for multiple depths all in one go.
  purrr::map2(.y = PCA_depths_y, .x = PCA_depths_x, .f = function(.y, .x) {
    
    pc_y <- .y
    pc_x <- .x
    
    ggplot(PCA_loadings) + 
    geom_point(aes(y = !!(paste("PC", pc_y, sep = "") %>% as.name), x = !!(paste("PC", pc_x, sep = "") %>% as.name), shape = replicatenumber, color = timepoint, size = 2)) +
    scale_fill_gradientn(name = "Timepoint", colours = rainbow(n = (PCA_loadings %>% nrow))) +
    scale_shape_discrete(name = "Replicate") +
    ggtitle(paste("PCA loadings\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab(paste("PC", pc_x, " (", PCA_variance[pc_x, "variance_explained"] %>% signif(3), "%)", sep = "")) +
    ylab(paste("PC", pc_y, " (", PCA_variance[pc_y, "variance_explained"] %>% signif(3), "%)", sep = "")) +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 25, units = "cm")
    
    } )
  
}

```

### multiple test correction

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

```

### FUNCTION TO CHANGE THE NAME OF ONE COLUMN WITH EXACT MATCH

```{r}

rename_column_exact <- function(input_tibble, target_column, output_colname) {
  
  output_tibble <- input_tibble
  
  colnames(output_tibble)[which(colnames(output_tibble) == target_column)] <- output_colname
  
  return(output_tibble)
  
}

```

### function to split a whole table by a delimiter in a column

```{r}

split_delimited_columns_in_table <- function(input_table, target_colname, split, columns_to_deduplicate = NULL) {
  
  # DEBUG ###
  # input_table <- test
  # target_colname <- c("Proteins", "Positions.within.proteins", "Fasta.headers", "Leading.proteins")
  # split = "\\;"
  # columns_to_deduplicate <- c("id")
  ###########
  
  # list-ify the target column
  list_target_column_strsplit_per_element <- input_table[, target_colname] %>% array_tree(margin = 2) %>% purrr::map(~.x %>% unlist %>% strsplit(., split = split))
  
  # map length
  vector_sum_lengths <- list_target_column_strsplit_per_element %>% purrr::map(~length(.x %>% unlist)) %>% unlist(use.names = FALSE) %>% unique
  
  # check. if the split lengths are different, then die.
  if (length(vector_sum_lengths) != 1) {
    
    stop("split lengths are uneven across specified columns.")
    
  }
  
  # repeat table according to the split lengths
  vector_split_lengths <- purrr::map_depth(.x = list_target_column_strsplit_per_element, .depth = 2, .f = ~length(.x)) %>% 
    purrr::map(~unlist(.x)) %>%
    purrr::pmap(.f = ~max(...)) %>%
    unlist
  
  row_indices_of_table_repeated_by_split <- purrr::map2(.x = 1:nrow(input_table), .y = vector_split_lengths, .f = ~rep(x = .x, times = .y)) %>% unlist
  
  input_table_repeated_by_split <- input_table[row_indices_of_table_repeated_by_split, ]
  
  # replace target column with split values
  input_table_repeated_by_split[, target_colname] <- list_target_column_strsplit_per_element %>% purrr::map(~unlist(.x)) %>% purrr::reduce(cbind)
  
  split_table <- input_table_repeated_by_split
  
  # if specified, append an index to a particular column
  if (is.null(columns_to_deduplicate) == FALSE) {
    
    # get the duplicated row indices where split lengths > 1
    indices_of_duplicates <- which(vector_split_lengths > 1)
    
    # get the repetition number where split lengths > 1
    repetition_numbers_of_duplicates <- vector_split_lengths[which(vector_split_lengths > 1)]
    
    # list-ify the columns to be appended
    list_deduplicated_columns <- input_table[, columns_to_deduplicate] %>% array_tree(margin = 2) %>% purrr::map(~array_tree(.x))
    
    # map over each column, split the target element and add _[0-9]+
    list_deduplicated_columns_split <- purrr::map(.x = list_deduplicated_columns, .f = function(a1) {
      
      # map a subset each of the L2 (elements of a column)
      a1[indices_of_duplicates] <- purrr::map2(.x = a1[indices_of_duplicates], .y = repetition_numbers_of_duplicates, 
                  .f = ~rep(.x, times = .y) %>% unlist %>% paste(., 1:.y, sep = "_"))
      
      return(a1 %>% unlist)
      
    } )
    
    # tibblise
    tibble_deduplicated_columns_split <- list_deduplicated_columns_split %>% as_tibble
    
    # add back every row onto the split table
    for (dedupe_colname in columns_to_deduplicate) {
      
      split_table[, dedupe_colname] <- tibble_deduplicated_columns_split[, dedupe_colname]
      
    }
    
  }
  
  return(split_table)
  
}

```

### FUNCTION TO TAKE THE AVERAGE OF ROWS OF A DATAFRAME ACCORDING TO A FACTOR WITH INFORMATION ABOUT THE COLUMN DESIGN

```{r}

average_replicates_by_column <- function(table, design_factor, min_replicates) {

  # DEBUG ###
  # table <- raw_tibble %>% dplyr::select(-id)
  # design_factor <- factor(x = gsub(x = colnames(raw_tibble %>% dplyr::select(-id)), pattern = "^([^\\|]+).*", replacement = "\\1", perl = TRUE), levels = c("30m_vs_ud", "1h_vs_ud", "6h_vs_ud", "1d_vs_ud"))
  # min_replicates <- 1
  ###########
  
  # subset and take average
  # establish looping behaviour thru the levels
  purrr::map(.x = levels(design_factor), .f = function(.x) {
    
    # DEBUG ###
    # .x <- levels(design_factor) %>% .[[2]]
    ###########
    
    table_subset <- table[, which(design_factor == .x)]
    
    # add mean and replicate numbers columns
    table_column_averages <- table_subset %>% add_column("mean" = rowMeans(., na.rm = TRUE), 
                                                         "replicates" = pmap(.l = list("x" = .[, 1] %>% unlist, "y" = .[, 2] %>% unlist, "z" = .[, 3] %>% unlist), .f = function(x, y, z) {length(c(x, y, z) %>% na.omit)}) %>% unlist)
    
    # delete the mean if the number of replicates is less than 2
    table_column_averages[which(table_column_averages$replicates < min_replicates), "mean"] <- NA
    
    # only keep the mean column
    tibble_mean <- table_column_averages[, "mean"]
    
    # rename column names
    colnames(tibble_mean) <- paste(colnames(tibble_mean), "|", .x, sep = "")
    
    return(tibble_mean)
    
  } ) %>%
    # join all mean columns and we're done
    purrr::reduce(dplyr::bind_cols) %>%
    
    return
    
}

```

# read the tables into environment

```{r}

list_maxquant_run_dirs <- list("2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms/txt/",
                               "2020_phosphoproteome_OBseries_junc.exons" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_junc.exons/txt/",
                               # "sp.hsa.canonical.isoforms_junc.exons" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_sp.hsa.canonical.isoforms_junc.exons/txt/",
                               # "con_sp.hsa.canonical.isoforms_junc.exons" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms_junc.exons/txt/",
                               "2012_PGNEXUS_proteome_con.sp.canonical.isoforms_katana" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_con.sp.canonical.isoforms_katana/txt/",
                               "2012_PGNEXUS_proteome_sp.canonical.isoforms_junc.exons_katana" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_sp.canonical.isoforms_junc.exons_katana/txt/",
                               "2012_PGNEXUS_proteome_junc.exons_katana" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_junc.exons_katana/txt/"
                               )
                               
list_output.table_categories <- list("modification_specific_peptides" = "modificationSpecificPeptides.txt", 
                                     "msms" = "msms.txt",
                                     "peptides" = "peptides.txt", 
                                     "protein_groups" = "proteinGroups.txt",
                                     "phosphosites" = "Phospho (STY)Sites.txt")

# create combinations of files and runs
list_for_maxquant_table_import <- purrr::map(.x = list_maxquant_run_dirs, .f = ~purrr::cross2(.x, list_output.table_categories))
# also create corresponding combinations of names to annotate with
list_of_nested_table_names <- purrr::map(.x = names(list_maxquant_run_dirs), .f = ~purrr::cross2(.x, names(list_output.table_categories)) %>% set_names(names(list_output.table_categories))) %>% set_names(names(list_maxquant_run_dirs))

# read the tables into the environment
list_imported_maxquant_tibbles <- purrr::map(.x = list_for_maxquant_table_import, .f = ~future_map(.x = .x, .f = ~read.delim(paste(.x[[1]], .x[[2]], sep = ""), stringsAsFactors = FALSE, row.names = NULL, sep = "\t") %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("read.delim", "as_tibble"))))
# , .options = future_options(globals = c("as_tibble"))

# rename the lists at L2
list_imported_maxquant_tibbles <- list_imported_maxquant_tibbles %>% purrr::map(.f = ~set_names(.x, names(list_output.table_categories)))

```

# global processing of tables

```{r}

list_imported_maxquant_tibbles_processed <- list_imported_maxquant_tibbles 

# filtering by MS.MS.Count may not be reliable
# %>% purrr::map(.f = ~modify_at(.x = .x, .at = c("peptides"), .f = ~dplyr::filter(.x, MS.MS.Count != 0) %>% dplyr::arrange(., PEP)) )

```

# Data triaging

## plot the PEP and score distributions of CON, SP and 3FT identified peptides

### rearrange the msms.txt tables for ggplot

```{r}

# function to create peptide class column
peptide_class_column <- function(msms_tibble) {
  
  col <- rep(NA, times = nrow(msms_tibble))
  
  # record the columns of contaminants, reverse sequences, swissprot matches, junction and exon matches.
  cons <- grep(x = msms_tibble$Proteins, pattern = "(^CON_|;CON_)", ignore.case = FALSE)
  revs <- which(msms_tibble$Reverse == "+")
  sps <- grep(x = msms_tibble$Proteins, pattern = "(^[A-Z][0-9].*|;[A-Z][0-9].*)", ignore.case = FALSE)
  junctions <- grep(x = msms_tibble$Proteins, pattern = "junction_.*", ignore.case = FALSE)
  exons <- grep(x = msms_tibble$Proteins, pattern = "exon_.*", ignore.case = FALSE)
  
  col[cons] <- "contaminants"
  col[revs] <- "reversed_sequences"
  col[sps] <- "swissprot_hits"
  col[junctions] <- "junction_3FT_hits"
  col[exons] <- "exon_3FT_hits"
  
  return(col)
  
}

list_msms_tibbles <- purrr::map2(.x = list_imported_maxquant_tibbles_processed %>% purrr::map(.f = ~.x$msms), .y = names(list_imported_maxquant_tibbles_processed), .f = ~add_column(.x, "dbrun" = .y) %>% add_column("peptide_class" = peptide_class_column(.x)))

# melt into long tables for ggplot faceting by peptide class and database run
long_tibble_evidence_tibbles_facet.peptideclass.dbrun <- list_msms_tibbles %>% rbindlist(fill = TRUE) %>% as_tibble

```

### ggplot of number of hits in each category

```{r}

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = peptide_class, fill = PEP <= 0.01)) +
  geom_bar() +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Bar plot of number of hits in each peptide category", sep = "")) +
  xlab("Peptide category") +
  scale_x_discrete(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence")) + 
  ylab(expression(Number~of~total~hits)) +
  scale_fill_manual(limits = c("TRUE", "FALSE"), labels = c("PEP < 0.01", "PEP > 0.01"), values = c("blue2", "grey75"), name = "Hit significance") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = peptide_class, fill = PEP <= 0.01)) +
  geom_bar(aes(y = log10(..count..))) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Bar plot of number of hits in each peptide category", sep = "")) +
  xlab("Peptide category") +
  scale_x_discrete(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence")) + 
  ylab(expression(Number~of~total~hits~(log[10]))) +
  # scale_y_continuous(trans = "log10") +
  scale_fill_manual(limits = c("TRUE", "FALSE"), labels = c("PEP < 0.01", "PEP > 0.01"), values = c("blue2", "grey75"), name = "Hit significance") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class_log10", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class_log10", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### ggplot of PEP distributions below 0.05

```{r}

# line - absolute counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, color = peptide_class)) +
  geom_density(aes(y = ..count..)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.005, 0.051), breaks = c(-0.005, seq(0, 0.051, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.absolute", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.absolute", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# line - normalised counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, color = peptide_class)) +
  geom_density(aes(y = ..density..)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.005, 0.051), breaks = c(-0.005, seq(0, 0.051, 0.005))) +
  ylab("Frequency density (smoothed)") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.normalised", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.normalised", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# bar
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, fill = peptide_class)) +
  geom_histogram(binwidth = 0.0005, aes(y = ..count..)) +
  facet_grid(dbrun ~ peptide_class, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.051), breaks = c(-0.001, seq(0, 0.051, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_fill_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_absolute", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_absolute", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# bar
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, fill = peptide_class)) +
  geom_histogram(binwidth = 0.0005, aes(y = ..density..)) +
  facet_grid(dbrun ~ peptide_class, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.051), breaks = c(-0.001, seq(0, 0.051, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_fill_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_normalised", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_normalised", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### ggplot of score distributions

```{r}

# absolute counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = Score + 1, colour = peptide_class)) +
  geom_density(aes(y = ..count.. + 1)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Comparison of peptide score distributions", sep = "")) +
  xlab(expression(Score[MaxQuant] + 1)) +
  scale_x_continuous(trans = "log10", breaks = c(1, seq(50, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score), 50))) +
  ylab("Frequency (absolute)") +
  # scale_y_continuous(trans = "log10") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_absolute.counts", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_absolute.counts", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# normalised counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = Score + 1, colour = peptide_class)) +
  geom_density(aes(y = ..density.. + 1)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Comparison of peptide score distributions", sep = "")) +
  xlab(expression(Score[MaxQuant] + 1)) +
  scale_x_continuous(trans = "log10", breaks = c(1, seq(50, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score), 50))) +
  ylab("Frequency (normalised)") +
  # scale_y_continuous(trans = "log10") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_normalised.counts", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_normalised.counts", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### plot of score vs. PEP

```{r}

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun %>% dplyr::distinct(., PEP, Score, .keep_all = TRUE) %>% dplyr::filter(., PEP <= 1), aes(x = log10(PEP + 1), y = Score + 1, colour = peptide_class)) +
  geom_point() +
  geom_smooth(formula = y ~ x) +
  # show where PEP = 0.01 is
  geom_vline(xintercept = 0.00432137378, colour = "red", linetype = 2) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Correlation~plot~of~peptide~score~vs.~PEP~(PEP <= 0.05~only))) +
  xlab(expression(log[10](PEP[MaxQuant] + 1))) +
  ylab(expression(Score[MaxQuant])) +
  scale_y_continuous(trans = "log10", breaks = c(1, seq(30, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score + 1), 30))) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_correlation_score_vs_PEP", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_correlation_score_vs_PEP", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

## evaluate the local FDR of 3FT peptides only

```{r}

# calculate the peptide FDR based on the evidence.txt information
list_local_FDR <- purrr::map(.x = list_imported_maxquant_tibbles_processed[vector_evidence.txt_list.indices], .f = function(.x) {
  
  .x <- list_imported_maxquant_tibbles_processed[vector_evidence.txt_list.indices][[1]]
  
  number_of_reverse_hits_exons <- grep(x = .x$Leading.proteins, pattern = "(REV__exon)") %>% length
  number_of_reverse_hits_junctions <- grep(x = .x$Leading.proteins, pattern = "(REV__junction)") %>% length
  
  number_of_total_hits_exons <- grep(x = .x$Leading.proteins, pattern = "(exon_)") %>% length
  number_of_total_hits_junctions <- grep(x = .x$Leading.proteins, pattern = "(junction_)") %>% length
  
  FDR_exons <- number_of_reverse_hits_exons/number_of_total_hits_exons
  FDR_junctions <- number_of_reverse_hits_junctions/number_of_total_hits_junctions
  
  return(list(
    "Local FDR info (exons)" = list(
      
      "FDR_exons" = FDR_exons,
      "number_of_reverse_hits_exons" = number_of_reverse_hits_exons,
      "number_of_total_hits_exons" = number_of_total_hits_exons
      
    ),
    "Local FDR info (junctions)" = list(
      
      "FDR_junctions" = FDR_junctions,
      "number_of_reverse_hits_junctions" = number_of_reverse_hits_junctions,
      "number_of_total_hits_junctions" = number_of_total_hits_junctions
      
    )
    
  ))
  
} )

str(list_local_FDR)

```

# Proteomic validation

## Filter for PEP and score

```{r}

tibble_junc.exons_filtered <- list_imported_maxquant_tibbles_processed[c("2012_PGNEXUS_proteome_junc.exons_katana", "2020_phosphoproteome_OBseries_junc.exons")] %>% purrr::map2(.x = ., .y = names(.), ~.x$peptides %>% add_column("dbrun" = .y)) %>% rbindlist(fill = TRUE) %>% as_tibble %>% 
  dplyr::filter(PEP <= 0.01 & Score >= 30 & str_detect(string = Leading.razor.protein, pattern = "^REV") == FALSE) %>%
  type_convert

# count the number of splice peptides identified.
cat("\nnumber of junctions/exons validated: ", tibble_junc.exons_filtered$Leading.razor.protein %>% unique %>% length)

cat("\nnumber of NON-AMBIGUOUS junctions/exons validated: ", tibble_junc.exons_filtered$Leading.razor.protein %>% .[-grep(x = tibble_junc.exons_filtered$Proteins, pattern = ";")] %>% unique %>% length)

cat("\nnumber of NON-AMBIGUOUS junctions validated: ", tibble_junc.exons_filtered$Leading.razor.protein %>% .[-grep(x = tibble_junc.exons_filtered$Proteins, pattern = ";")] %>% .[grep(x = ., pattern = "junction")] %>% unique %>% length)

cat("\nnumber of NON-AMBIGUOUS exons validated: ", tibble_junc.exons_filtered$Leading.razor.protein %>% .[-grep(x = tibble_junc.exons_filtered$Proteins, pattern = ";")] %>% .[grep(x = ., pattern = "exon")] %>% unique %>% length)

```

## Gene set enrichment

### import the FASTA identifier to gene mappings

```{r}

tibble_fasta_supp_info_exons <- read.delim(file = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_exons/exon_table_OB_diff_dpsi10_anypvalue0.01_3272_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

tibble_fasta_supp_info_junctions <- read.delim(file = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_junctions/junction_table_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

# bind rows
tibble_fasta_supp_info <- dplyr::bind_rows(tibble_fasta_supp_info_exons, tibble_fasta_supp_info_junctions)

```

### Join gene names using the FASTA identifier

```{r}

tibble_junc.exons_filtered_with.gene.name <- dplyr::left_join(tibble_junc.exons_filtered, 
                                                              dplyr::bind_rows(tibble_fasta_supp_info_exons[, c("identifier", "matched_gene_names")],
                                                                               tibble_fasta_supp_info_junctions[, c("identifier", "matched_gene_names")]) %>% 
                                                                setNames(c("Leading.razor.protein", "gene_name")))

tibble_junc.exons_to_gene.name <- tibble_junc.exons_filtered_with.gene.name[, c("gene_name", "Leading.razor.protein", "Sequence")]

cat("\nnumber of novel exons/junctions: ", is.na(tibble_junc.exons_to_gene.name %>% dplyr::distinct(Leading.razor.protein, .keep_all = TRUE)) %>% which %>% length)

```

# Tryptic peptide evaluation and visualisation

## Import the details of 3FT - junctions and exons

```{r}

tibble_detailed_3FT_summary_JUM <- read.delim(file = paste(`3FT_results_dir`, "threeframetranslate_junctions_qvalue0.01_dpsi0.15_diff_3FT.summary.info.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

tibble_detailed_3FT_summary_PSIsigma <- read.delim(file = paste(`3FT_results_dir`, "threeframetranslate_exons_pvalue0.01_dpsi10_diff_3FT.summary.info.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

```

## Evaluate junction spanning of tryptic peptides

### Retrieve the parent peptide start and end positions of the matched peptides and test for spanning.

```{r}

# get only the junction entries from the filtered table 
tibble_junc.exons_filtered_with.gene.name_split_juncs.only <- tibble_junc.exons_filtered_with.gene.name %>% 
  # split_delimited_column_in_table(target_colname = "Proteins", split = ";", columns_to_deduplicate = "id") %>% 
  dplyr::filter(str_detect(string = Leading.razor.protein, pattern = "junction")) %>%
  dplyr::distinct(Leading.razor.protein, .keep_all = TRUE)

# now clean up other proteins which were grouped together with the junctions - unnecessary if we're just dealing with the junc.exons.
# we use grep to get the row indices which contain Junction "protein"
# this is final.
# tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split <- tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split[grep(x = tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split$Proteins, pattern = "Junction"), ]

# loop thru each identified tryptic peptide. match to the 3FT info.
## subset to reduce parallel overhead
tibble_detailed_3FT_summary_JUM_subset <- tibble_detailed_3FT_summary_JUM[, c("ORF_valid", "fasta_header", "window_start_AA_position", "window_end_AA_position", "junction_AA_position")]

list_tryptic_junc_peptides_matched_to_3FT_summary <- future_imap(.x = tibble_junc.exons_filtered_with.gene.name_split_juncs.only %>% array_tree,
                                                                 .f = function(a1, a2) {
                                                                   
                                                                   cat("\nnow processing: ", a2)
                                                                   
                                                                   list("tryptic_peptide_start" = a1$Start.position,
                                                                        "tryptic_peptide_end" = a1$End.position,
                                                                        "matched_3FT_summary_entry" = tibble_detailed_3FT_summary_JUM_subset[which(str_detect(string = tibble_detailed_3FT_summary_JUM_subset$ORF_valid, pattern = a1$Sequence) == TRUE & str_detect(string = tibble_detailed_3FT_summary_JUM_subset$fasta_header, pattern = a1$Leading.razor.protein) == TRUE), c("window_start_AA_position", "window_end_AA_position", "junction_AA_position")]) %>% return
                                                                   
                                                                 }, .progress = TRUE, .options = future_options(globals = c("tibble_detailed_3FT_summary_JUM_subset", "str_detect")))

# officially test for junction-spanning.
## it's considered spanning if there's at least one AA on both sides.
list_tryptic_junc_peptides_spanning_logical_test <- list_tryptic_junc_peptides_matched_to_3FT_summary %>% purrr::map(.f = ~any(((.x$matched_3FT_summary_entry$window_start_AA_position + (.x$tryptic_peptide_start %>% trimws %>% as.numeric - 1)) <= (.x$matched_3FT_summary_entry$junction_AA_position - 1)) & ((.x$matched_3FT_summary_entry$window_start_AA_position + (.x$tryptic_peptide_end %>% trimws %>% as.numeric - 1)) >= (.x$matched_3FT_summary_entry$junction_AA_position + 1))
                                                                                                                               ))

# count of shame
cat("\nWe have identified", which(list_tryptic_junc_peptides_spanning_logical_test %>% unlist == TRUE) %>% length, "peptides which span a splice junction.")

# write the processed table.
# write.table(tibble_PGNEXUS_MSMS_junction_peptides_with_SJ_crossing_info, file = paste(R_processing_results_dir, "PGNEXUS_MSMS_identified_JUM_q0.01_dpsi0.2_junc.peptides_with_SJ.info.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

```

### further explore what the junction-spanning peptides are

```{r}

tibble_junction_spanning_peptides_identifier.gene <- tibble_junc.exons_filtered_with.gene.name_split_juncs.only[which(list_tryptic_junc_peptides_spanning_logical_test %>% unlist == TRUE), c("gene_name", "Leading.razor.protein", "Sequence")]

```

#### GO enrichment for all junction spanning peptides + exonic peptides identified

```{r}

# join exonic peptides and junction-spanning peptides into the same table
tibble_confirmed_junc.exons <- dplyr::bind_rows(tibble_junction_spanning_peptides_identifier.gene, tibble_junc.exons_to_gene.name[grep(x = tibble_junc.exons_to_gene.name$Leading.razor.protein, pattern = "exon"), ]) %>% 
  dplyr::arrange(gene_name)

# write table
write.table(tibble_confirmed_junc.exons, file = paste(R_processing_results_dir, "table_brief.info_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# CONDUCT ENRICHMENT
tibble_hyperGO_confirmed_junc.exons <- dplyr::bind_rows(GOHyperGAll(catdb = catdb, gocat = "MF", sample = tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "BP", sample = tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "CC", sample = tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction) %>% as_tibble

write.table(tibble_hyperGO_confirmed_junc.exons, file = paste(R_processing_results_dir, "table_hyperGO_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# write the geneset
write.table(tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, file = paste(R_processing_results_dir, "table_geneset_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)

```

## Preprocessing for visualisation in IGV

Step 1: Import the details of 3FT - junctions and exons
Step 2: Calculate the genome-relative positions of the identified tryptic peptides
Step 3: Write a BLOCKED bed file (BED12 format)
Step 4 (outside R): BEDtoBAM

### PEPTIDES
### calculate genome-relative ranges of all the nucleotides encoding the identified tryptic peptides
### return a bedfile-like format

```{r}

# split table by exons or junctions
tibble_junction_peptides_only <- tibble_junc.exons_filtered[grep(x = tibble_junc.exons_filtered$Leading.razor.protein, pattern = "junction_"), ]
tibble_exon_peptides_only <- tibble_junc.exons_filtered[grep(x = tibble_junc.exons_filtered$Leading.razor.protein, pattern = "exon_"), ]

# to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
# extract the MQ outputted start/end positions: 
# 1. They are the valid-ORF-relative coords, 
# 2. then parent translated transcript-relative coords then,
# 3. use the translation frame and 3x length to get the nucleotide positions.
# 4. convert individual nt positions to genomic ranges

# match junctions #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_bedfile_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_junction_peptides_only[5, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM$fasta_header, pattern = a1$Leading.razor.protein %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_JUM$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM[row_index_of_matched_3FT_table, ]
  
  # get translated transcript-relative AA coords
  translated_transcript_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  translated_transcript_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                              "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
    add_column("difference" = .$n.plus.1 - .$n)
  
  ## if there are no gaps, then just take the genomic range as the start:end
  if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
    
    vec_blockCount <- 1
    vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
    vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
    
  } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
    
    vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
    vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                         tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
    vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                       last(all_genome_relative_positions_of_tryptic_peptide))
    vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_block_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
    "start" = first(all_genome_relative_positions_of_tryptic_peptide),
    "end" = last(all_genome_relative_positions_of_tryptic_peptide),
    "name" = a1$Leading.razor.protein %>% paste %>% trimws,
    "score" = a1$Score %>% as.numeric,
    "strand"= tibble_matched_3FT_entry$matched_junction_strand,
    "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
    "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
    "itemRgb" = "153,0,255",
    "blockCount" = vec_blockCount %>% paste(collapse = ","),
    "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
    "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
    "qName" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(tibble_block_info)      
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM", "tibble_junction_peptides_only", "first", "last")))

# match exons #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_bedfile_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_exon_peptides_only[5, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma$fasta_header, pattern = a1$Leading.razor.protein %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_PSIsigma$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma[row_index_of_matched_3FT_table, ]
  
  # get translated transcript-relative AA coords
  translated_transcript_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  translated_transcript_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                              "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
    add_column("difference" = .$n.plus.1 - .$n)
  
  ## if there are no gaps, then just take the genomic range as the start:end
  if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
    
    vec_blockCount <- 1
    vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
    vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
    
  } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
    
    vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
    vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                         tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
    vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                       last(all_genome_relative_positions_of_tryptic_peptide))
    vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_block_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_exon_chr,
    "start" = first(all_genome_relative_positions_of_tryptic_peptide),
    "end" = last(all_genome_relative_positions_of_tryptic_peptide),
    "name" = a1$Leading.razor.protein %>% paste %>% trimws,
    "score" = a1$Score %>% as.numeric,
    "strand"= tibble_matched_3FT_entry$matched_exon_strand,
    "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
    "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
    "itemRgb" = "153,0,0",
    "blockCount" = vec_blockCount %>% paste(collapse = ","),
    "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
    "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
    "qName" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(tibble_block_info)      
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma_diff", "first", "last")))

# rbind and tibblise
tibble_bedfile <- splice(list_bedfile_junctions_only, list_bedfile_exons_only) %>% rbindlist %>% as_tibble %>% dplyr::select(-qName)

# track line
# cat(paste("track name=\"", output_file_name_JUM, "\" description=\"", output_file_name_JUM, "\" graphType=junctions\n", sep = ""), file = paste(R_processing_results_dir, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""))
# 
# append = TRUE
write.table(x = tibble_bedfile, file = paste(R_processing_results_dir, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# GO TO BEDTOOLS NOW ###
# cd /media/Ubuntu/sharedfolder/bedtools2/bin/
# ./bedToBam -i /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bed -bed12 -g hg38.chrom.sizes_ensembl > /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bam

# rtracklayer::export(object = tibble_bedfile, con = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), format = "bedPE")
# 
# # add the QNAME for real this time
# tibble_bedfile2 <- read.delim(file = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), sep = "\t", col.names = colnames(tibble_bedfile)[-length(colnames(tibble_bedfile))], row.names = NULL, header = FALSE, check.names = FALSE) %>% as_tibble

```

### PHOSPHOSITES
### return a .mut mutation file.
### actually, maybe not, since the phosphosites might be gapped.

```{r}

b1 <- list_imported_maxquant_tibbles_processed$`2020_phosphoproteome_OBseries_junc.exons`$phosphosites %>%
  # filter for class I phosphosites
  # remove the reverse hits or table split wont work
  dplyr::filter(Localization.prob >= 0.75 & PEP <= 0.01 & Score >= 30 & Reverse != "+") %>%
  # dedupe in preparation for the next step
  split_delimited_columns_in_table(input_table = ., target_colname = c("Proteins", "Positions.within.proteins", "Fasta.headers"), split = ";", columns_to_deduplicate = "id") %>%
  split_delimited_columns_in_table(input_table = ., target_colname = c("Leading.proteins"), split = ";", columns_to_deduplicate = "id") %>%
  split_delimited_columns_in_table(input_table = ., target_colname = c("Peptide.IDs"), split = ";", columns_to_deduplicate = "id") %>%
  type_convert %>%
  # add the "sequence" information by joining with the peptides table so we can accurately match back to the FASTA
  dplyr::left_join(., list_imported_maxquant_tibbles_processed$`2020_phosphoproteome_OBseries_junc.exons`$peptides %>% dplyr::rename("Peptide.IDs" = "id") %>% dplyr::select(Peptide.IDs, Sequence), by = "Peptide.IDs")

# split table by exons or junctions
tibble_junction_peptides_only <- b1[grep(x = b1$Leading.proteins, pattern = "^junction_"), ]
tibble_exon_peptides_only <- b1[grep(x = b1$Leading.proteins, pattern = "^exon_"), ]

# to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
# extract the MQ outputted start/end positions: 
# 1. They are the valid-ORF-relative coords, 
# 2. then parent translated transcript-relative coords then,
# 3. use the translation frame and 3x length to get the nucleotide positions.
# 4. convert individual nt positions to genomic ranges

# match junctions #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_bedfile_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_junction_peptides_only[1, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_JUM$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM[row_index_of_matched_3FT_table, ]
  
  # get translated transcript-relative AA coords
  translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                              "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
    add_column("difference" = .$n.plus.1 - .$n)
  
  ## if there are no gaps, then just take the genomic range as the start:end
  if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
    
    vec_blockCount <- 1
    vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
    vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
    
  } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
    
    vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
    vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                         tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
    vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                       last(all_genome_relative_positions_of_tryptic_peptide))
    vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_block_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
    "start" = first(all_genome_relative_positions_of_tryptic_peptide),
    "end" = last(all_genome_relative_positions_of_tryptic_peptide),
    "name" = a1$Leading.proteins %>% paste %>% trimws,
    "score" = a1$Score %>% as.numeric,
    "strand"= tibble_matched_3FT_entry$matched_junction_strand,
    "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
    "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
    "itemRgb" = "255,187,0",
    "blockCount" = vec_blockCount %>% paste(collapse = ","),
    "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
    "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
    "qName" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(tibble_block_info)      
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM", "tibble_junction_peptides_only", "first", "last")) )

# match exons #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_bedfile_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_exon_peptides_only[4, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_PSIsigma$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma[row_index_of_matched_3FT_table, ]
  
  # get translated transcript-relative AA coords
  translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                              "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
    add_column("difference" = .$n.plus.1 - .$n)
  
  ## if there are no gaps, then just take the genomic range as the start:end
  if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
    
    vec_blockCount <- 1
    vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
    vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
    
  } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
    
    vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
    vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                         tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
    vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                       last(all_genome_relative_positions_of_tryptic_peptide))
    vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_block_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_exon_chr,
    "start" = first(all_genome_relative_positions_of_tryptic_peptide),
    "end" = last(all_genome_relative_positions_of_tryptic_peptide),
    "name" = a1$Leading.proteins %>% paste %>% trimws,
    "score" = a1$Score %>% as.numeric,
    "strand"= tibble_matched_3FT_entry$matched_exon_strand,
    "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
    "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
    "itemRgb" = "255,187,0",
    "blockCount" = vec_blockCount %>% paste(collapse = ","),
    "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
    "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
    "qName" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(tibble_block_info)      
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma", "first", "last")))

# rbind and tibblise
tibble_bedfile <- splice(list_bedfile_junctions_only, list_bedfile_exons_only) %>% rbindlist %>% as_tibble %>% dplyr::select(-qName)

# track line
# cat(paste("track name=\"", output_file_name_JUM, "\" description=\"", output_file_name_JUM, "\" graphType=junctions\n", sep = ""), file = paste(R_processing_results_dir, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""))
# 
# append = TRUE
write.table(x = tibble_bedfile %>% dplyr::distinct(chrom, start, end, name, .keep_all = TRUE), file = paste(R_processing_results_dir, "proteomic_alignment_2020_phosphoproteome_phosphosites.bed", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# GO TO BEDTOOLS NOW ###
# cd /media/Ubuntu/sharedfolder/bedtools2/bin/
# ./bedToBam -i /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bed -bed12 -g hg38.chrom.sizes_ensembl > /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bam

# rtracklayer::export(object = tibble_bedfile, con = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), format = "bedPE")
# 
# # add the QNAME for real this time
# tibble_bedfile2 <- read.delim(file = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), sep = "\t", col.names = colnames(tibble_bedfile)[-length(colnames(tibble_bedfile))], row.names = NULL, header = FALSE, check.names = FALSE) %>% as_tibble

```

### export a tibble of all genome-relative coords for evaluation of phosphosite in differential regions

```{r}

# to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
# extract the MQ outputted start/end positions: 
# 1. They are the valid-ORF-relative coords, 
# 2. then parent translated transcript-relative coords then,
# 3. use the translation frame and 3x length to get the nucleotide positions.
# 4. convert individual nt positions to genomic ranges

# match junctions #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_genome.relative.positions_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_junction_peptides_only[1, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_JUM$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM[row_index_of_matched_3FT_table, ]
  
  # get translated transcript-relative AA coords
  translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_position_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
    "genome_relative_positions_phosphosite" = paste(all_genome_relative_positions_of_tryptic_peptide, collapse = ","),
    "identifier" = a1$Leading.proteins %>% paste %>% trimws,
    "strand"= tibble_matched_3FT_entry$matched_junction_strand,
    "protein_sequence_tryptic_peptide" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(tibble_position_info)      
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM", "tibble_junction_peptides_only", "first", "last")) )

# match exons #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_genome.relative.positions_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_exon_peptides_only[4, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_PSIsigma$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma[row_index_of_matched_3FT_table, ]
  
  # get translated transcript-relative AA coords
  translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_position_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_exon_chr,
    "genome_relative_positions_phosphosite" = paste(all_genome_relative_positions_of_tryptic_peptide, collapse = ","),
    "identifier" = a1$Leading.proteins %>% paste %>% trimws,
    "strand"= tibble_matched_3FT_entry$matched_exon_strand,
    "protein_sequence_tryptic_peptide" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(tibble_position_info)      
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma", "first", "last")))

# rbind and tibblise
tibble_genome.relative.positions <- splice(list_genome.relative.positions_junctions_only, list_genome.relative.positions_exons_only) %>% rbindlist %>% as_tibble

# write table.
write.table(x = tibble_genome.relative.positions, file = paste(R_processing_results_dir, "genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

