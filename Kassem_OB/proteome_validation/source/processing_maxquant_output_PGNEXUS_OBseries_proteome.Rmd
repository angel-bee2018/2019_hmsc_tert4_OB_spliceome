---
title: "Processing MaxQuant output for proteomic validation of PGNEXUS OB RNA-Seq data"
author: "Angel Liang"
date: "22/02/2020"
output: html_document
---


# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
# library(gtools)
# library(extrafont)
# loadfonts(device="win")
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)

library(ggplot2)
# library(kohonen)
# library(genefilter)
# library(gplots)
# library(lattice)
# library(svglite)
# library(scales)

library(biomaRt)
ensembl_mart = useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host = "www.ensembl.org")
library(systemPipeR)
# library(GOstats)
# library(PFAM.db)
# library(bc3net)
# 
# library(ggdendro)
library(data.table)
library(seqinr)
# library(Rfast)

library(rtracklayer)

shared_dir <- "/mnt/Tertiary/sharedfolder/"

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
tibble_ref_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% 
  as_tibble %>%
  dplyr::mutate_if(is.factor, as.character)

# maxquant_junctions.3FT_results_dir <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_maxquant/run_1_PGNEXUS_OBseries_allsamples_angel.junctions.3FT/txt/"

R_processing_results_dir <- paste("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/", sep = "")

if(! dir.exists(R_processing_results_dir) ) {
     dir.create(R_processing_results_dir, recursive = TRUE)}

`3FT_results_dir` <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/three_frame_translation_results/"

```

## define functions

### FUNCTION TO PLOT PCA FOR TIMEPOINT AND REPLICATE

```{r}

plot_PCA_for_timepoint_and_replicate <- function(matrixtable, timepoint_order = NULL, replicate_order = NULL, PCA_depths_y = NULL, PCA_depths_x = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL) {
  
  # DEBUG ###
  # save_dir <- R_processing_results_dir
  # save_name <- "raw_MQ_intensities"
  # 
  # graph_title <- paste(.y[[1]], "\n", .y[[2]], sep = "")
  # 
  # timepoint_order <- c("ud_1_24", "ud_30_6", "30m", "1h", "6h", "1d")
  # replicate_order <- vector_replicate_names
  # 
  # PCA_depths_y <- c(2, 3, 4)
  # PCA_depths_x <- c(1, 2, 3)
  ###########
  
  PCA_result <- prcomp(matrixtable)
  
  ## measure PC variance #
  PCA_stdev <- tibble("PC" = 1:(PCA_result[["sdev"]] %>% length), "stdev" = PCA_result[["sdev"]])
  
  PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
  PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)
  
  ggplot(PCA_variance) + 
    geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
    scale_fill_gradientn(colours = heat.colors(n = (PCA_result[["sdev"]] %>% length))) +
    ggtitle(paste("PCA variance distribution\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("PC") +
    ylab("Variance explained (%)") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

  ## measure PC loadings #
  ## column names of the matrix need to be split by a "|", like this: timepoint|replicatenumber
  PCA_loadings <- PCA_result[["rotation"]] %>% as_tibble(rownames = "sample")
  PCA_loadings <- add_column(PCA_loadings, "timepoint" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1") %>% factor(x = ., levels = timepoint_order))
  PCA_loadings <- add_column(PCA_loadings, "replicatenumber" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2") %>% factor(x = ., levels = replicate_order))
  
  # plot PCA for multiple depths all in one go.
  purrr::map2(.y = PCA_depths_y, .x = PCA_depths_x, .f = function(.y, .x) {
    
    pc_y <- .y
    pc_x <- .x
    
    ggplot(PCA_loadings) + 
    geom_point(aes(y = !!(paste("PC", pc_y, sep = "") %>% as.name), x = !!(paste("PC", pc_x, sep = "") %>% as.name), shape = replicatenumber, color = timepoint, size = 2)) +
    scale_fill_gradientn(name = "Timepoint", colours = rainbow(n = (PCA_loadings %>% nrow))) +
    scale_shape_discrete(name = "Replicate") +
    ggtitle(paste("PCA loadings\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab(paste("PC", pc_x, " (", PCA_variance[pc_x, "variance_explained"] %>% signif(3), "%)", sep = "")) +
    ylab(paste("PC", pc_y, " (", PCA_variance[pc_y, "variance_explained"] %>% signif(3), "%)", sep = "")) +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 25, units = "cm")
    
    } )
  
}

```

### multiple test correction

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

```

### FUNCTION TO CHANGE THE NAME OF ONE COLUMN WITH EXACT MATCH

```{r}

rename_column_exact <- function(input_tibble, target_column, output_colname) {
  
  output_tibble <- input_tibble
  
  colnames(output_tibble)[which(colnames(output_tibble) == target_column)] <- output_colname
  
  return(output_tibble)
  
}

```

### function to split a whole table by a delimiter in a column

```{r}

split_delimited_columns_in_table <- function(input_table, target_colname, split, columns_to_deduplicate = NULL) {
  
  # DEBUG ###
  # input_table <- test
  # target_colname <- c("Proteins", "Positions.within.proteins", "Fasta.headers", "Leading.proteins")
  # split = "\\;"
  # columns_to_deduplicate <- c("id")
  ###########
  
  # list-ify the target column
  list_target_column_strsplit_per_element <- input_table[, target_colname] %>% array_tree(margin = 2) %>% purrr::map(~.x %>% unlist %>% strsplit(., split = split))
  
  # map length
  vector_sum_lengths <- list_target_column_strsplit_per_element %>% purrr::map(~length(.x %>% unlist)) %>% unlist(use.names = FALSE) %>% unique
  
  # check. if the split lengths are different, then die.
  if (length(vector_sum_lengths) != 1) {
    
    stop("split lengths are uneven across specified columns.")
    
  }
  
  # repeat table according to the split lengths
  vector_split_lengths <- purrr::map_depth(.x = list_target_column_strsplit_per_element, .depth = 2, .f = ~length(.x)) %>% 
    purrr::map(~unlist(.x)) %>%
    purrr::pmap(.f = ~max(...)) %>%
    unlist
  
  row_indices_of_table_repeated_by_split <- purrr::map2(.x = 1:nrow(input_table), .y = vector_split_lengths, .f = ~rep(x = .x, times = .y)) %>% unlist
  
  input_table_repeated_by_split <- input_table[row_indices_of_table_repeated_by_split, ]
  
  # replace target column with split values
  input_table_repeated_by_split[, target_colname] <- list_target_column_strsplit_per_element %>% purrr::map(~unlist(.x)) %>% purrr::reduce(cbind)
  
  split_table <- input_table_repeated_by_split
  
  # if specified, append an index to a particular column
  if (is.null(columns_to_deduplicate) == FALSE) {
    
    # get the duplicated row indices where split lengths > 1
    indices_of_duplicates <- which(vector_split_lengths > 1)
    
    # get the repetition number where split lengths > 1
    repetition_numbers_of_duplicates <- vector_split_lengths[which(vector_split_lengths > 1)]
    
    # list-ify the columns to be appended
    list_deduplicated_columns <- input_table[, columns_to_deduplicate] %>% array_tree(margin = 2) %>% purrr::map(~array_tree(.x))
    
    # map over each column, split the target element and add _[0-9]+
    list_deduplicated_columns_split <- purrr::map(.x = list_deduplicated_columns, .f = function(a1) {
      
      # map a subset each of the L2 (elements of a column)
      a1[indices_of_duplicates] <- purrr::map2(.x = a1[indices_of_duplicates], .y = repetition_numbers_of_duplicates, 
                  .f = ~rep(.x, times = .y) %>% unlist %>% paste(., 1:.y, sep = "_"))
      
      return(a1 %>% unlist)
      
    } )
    
    # tibblise
    tibble_deduplicated_columns_split <- list_deduplicated_columns_split %>% as_tibble
    
    # add back every row onto the split table
    for (dedupe_colname in columns_to_deduplicate) {
      
      split_table[, dedupe_colname] <- tibble_deduplicated_columns_split[, dedupe_colname]
      
    }
    
  }
  
  return(split_table)
  
}

```

### FUNCTION TO TAKE THE AVERAGE OF ROWS OF A DATAFRAME ACCORDING TO A FACTOR WITH INFORMATION ABOUT THE COLUMN DESIGN

```{r}

average_replicates_by_column <- function(table, design_factor, min_replicates) {

  # DEBUG ###
  # table <- raw_tibble %>% dplyr::select(-id)
  # design_factor <- factor(x = gsub(x = colnames(raw_tibble %>% dplyr::select(-id)), pattern = "^([^\\|]+).*", replacement = "\\1", perl = TRUE), levels = c("30m_vs_ud", "1h_vs_ud", "6h_vs_ud", "1d_vs_ud"))
  # min_replicates <- 1
  ###########
  
  # subset and take average
  # establish looping behaviour thru the levels
  purrr::map(.x = levels(design_factor), .f = function(.x) {
    
    # DEBUG ###
    # .x <- levels(design_factor) %>% .[[2]]
    ###########
    
    table_subset <- table[, which(design_factor == .x)]
    
    # add mean and replicate numbers columns
    table_column_averages <- table_subset %>% add_column("mean" = rowMeans(., na.rm = TRUE), 
                                                         "replicates" = pmap(.l = list("x" = .[, 1] %>% unlist, "y" = .[, 2] %>% unlist, "z" = .[, 3] %>% unlist), .f = function(x, y, z) {length(c(x, y, z) %>% na.omit)}) %>% unlist)
    
    # delete the mean if the number of replicates is less than 2
    table_column_averages[which(table_column_averages$replicates < min_replicates), "mean"] <- NA
    
    # only keep the mean column
    tibble_mean <- table_column_averages[, "mean"]
    
    # rename column names
    colnames(tibble_mean) <- paste(colnames(tibble_mean), "|", .x, sep = "")
    
    return(tibble_mean)
    
  } ) %>%
    # join all mean columns and we're done
    purrr::reduce(dplyr::bind_cols) %>%
    
    return
    
}

```

# read the tables into environment

```{r}

list_maxquant_run_dirs <- list(
  "2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms/txt/",
  # "2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms_junc.exons_deskside" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms_junc.exons_deskside/txt/",
  "2020_phosphoproteome_OBseries_sp.hsa.canonical.isoforms_junc.exons" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_sp.hsa.canonical.isoforms_junc.exons_deskside/txt/",
  "2020_phosphoproteome_OBseries_junc.exons" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_junc.exons_deskside/txt/",
  
  "2012_PGNEXUS_proteome_con.sp.canonical.isoforms" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_con.sp.canonical.isoforms_katana/txt/",
  "2012_PGNEXUS_proteome_con_sp.canonical.isoforms_junc.exons" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_con_sp.canonical.isoforms_junc.exons_deskside/txt/",
  "2012_PGNEXUS_proteome_sp.canonical.isoforms_junc.exons" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_sp.canonical.isoforms_junc.exons_deskside/txt/",
  "2012_PGNEXUS_proteome_junc.exons" = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/2012_PGNEXUS_proteome_junc.exons_deskside/txt/"
)

list_output.table_categories <- list("modification_specific_peptides" = "modificationSpecificPeptides.txt", 
                                     "msms" = "msms.txt",
                                     "peptides" = "peptides.txt", 
                                     "protein_groups" = "proteinGroups.txt",
                                     "phosphosites" = "Phospho (STY)Sites.txt")

# create combinations of files and runs
list_for_maxquant_table_import <- purrr::map(.x = list_maxquant_run_dirs, .f = ~purrr::cross2(.x, list_output.table_categories))
# also create corresponding combinations of names to annotate with
list_of_nested_table_names <- purrr::map(.x = names(list_maxquant_run_dirs), .f = ~purrr::cross2(.x, names(list_output.table_categories)) %>% set_names(names(list_output.table_categories))) %>% set_names(names(list_maxquant_run_dirs))

# read the tables into the environment
list_imported_maxquant_tibbles <- purrr::map(.x = list_for_maxquant_table_import, .f = ~future_map(.x = .x, .f = ~read.delim(paste(.x[[1]], .x[[2]], sep = ""), stringsAsFactors = FALSE, row.names = NULL, header = TRUE, sep = "\t") %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("read.delim", "as_tibble"))))
# , .options = future_options(globals = c("as_tibble"))

# rename the lists at L2
list_imported_maxquant_tibbles <- list_imported_maxquant_tibbles %>% purrr::map(.f = ~set_names(.x, names(list_output.table_categories)))

```

# global processing of tables

```{r}

list_imported_maxquant_tibbles_processed <- list_imported_maxquant_tibbles 

# filtering by MS.MS.Count may not be reliable
# %>% purrr::map(.f = ~modify_at(.x = .x, .at = c("peptides"), .f = ~dplyr::filter(.x, MS.MS.Count != 0) %>% dplyr::arrange(., PEP)) )

```

# Data triaging

## plot the PEP and score distributions of CON, SP and 3FT identified peptides

### rearrange the msms.txt tables for ggplot

```{r}

# function to create peptide class column
peptide_class_column <- function(msms_tibble) {
  
  col <- rep(NA, times = nrow(msms_tibble))
  
  # record the columns of contaminants, reverse sequences, swissprot matches, junction and exon matches.
  cons <- grep(x = msms_tibble$Proteins, pattern = "(^CON_|;CON_)", ignore.case = FALSE)
  revs <- which(msms_tibble$Reverse == "+")
  sps <- grep(x = msms_tibble$Proteins, pattern = "(^[A-Z][0-9].*|;[A-Z][0-9].*)", ignore.case = FALSE)
  junctions <- grep(x = msms_tibble$Proteins, pattern = "JUM", ignore.case = FALSE)
  exons <- grep(x = msms_tibble$Proteins, pattern = "PSISigma", ignore.case = FALSE)
  
  col[cons] <- "contaminants"
  col[revs] <- "reversed_sequences"
  col[sps] <- "swissprot_hits"
  col[junctions] <- "junction_3FT_hits"
  col[exons] <- "exon_3FT_hits"
  
  return(col)
  
}

list_msms_tibbles <- purrr::map2(.x = list_imported_maxquant_tibbles_processed %>% purrr::map(.f = ~.x$msms), .y = names(list_imported_maxquant_tibbles_processed), .f = ~add_column(.x, "dbrun" = .y) %>% add_column("peptide_class" = peptide_class_column(.x)))

# melt into long tables for ggplot faceting by peptide class and database run
long_tibble_evidence_tibbles_facet.peptideclass.dbrun <- list_msms_tibbles %>% rbindlist(fill = TRUE) %>% as_tibble

```

### ggplot of number of hits in each category

```{r}

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = peptide_class, fill = PEP <= 0.01)) +
  geom_bar() +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Bar plot of number of hits in each peptide category", sep = "")) +
  xlab("Peptide category") +
  scale_x_discrete(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence")) + 
  ylab(expression(Number~of~total~hits)) +
  scale_fill_manual(limits = c("TRUE", "FALSE"), labels = c("PEP < 0.01", "PEP > 0.01"), values = c("blue2", "grey75"), name = "Hit significance") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = peptide_class, fill = PEP <= 0.01)) +
  geom_bar(aes(y = log10(..count..))) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Bar plot of number of hits in each peptide category", sep = "")) +
  xlab("Peptide category") +
  scale_x_discrete(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence")) + 
  ylab(expression(Number~of~total~hits~(log[10]))) +
  # scale_y_continuous(trans = "log10") +
  scale_fill_manual(limits = c("TRUE", "FALSE"), labels = c("PEP < 0.01", "PEP > 0.01"), values = c("blue2", "grey75"), name = "Hit significance") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class_log10", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_number.of.hits_per_peptide.class_log10", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### ggplot of PEP distributions below 0.05

```{r}

# line - absolute counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, color = peptide_class)) +
  geom_density(aes(y = ..count..)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.005, 0.051), breaks = c(-0.005, seq(0, 0.051, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.absolute", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.absolute", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# line - normalised counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, color = peptide_class)) +
  geom_density(aes(y = ..density..)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.005, 0.051), breaks = c(-0.005, seq(0, 0.051, 0.005))) +
  ylab("Frequency density (smoothed)") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.normalised", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.normalised", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# bar
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, fill = peptide_class)) +
  geom_histogram(binwidth = 0.0005, aes(y = ..count..)) +
  facet_grid(dbrun ~ peptide_class, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.051), breaks = c(-0.001, seq(0, 0.051, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_fill_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_absolute", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_absolute", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# bar
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, fill = peptide_class)) +
  geom_histogram(binwidth = 0.0005, aes(y = ..density..)) +
  facet_grid(dbrun ~ peptide_class, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.05~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.051), breaks = c(-0.001, seq(0, 0.051, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_fill_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_normalised", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar_normalised", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### ggplot of score distributions

```{r}

# absolute counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = Score + 1, colour = peptide_class)) +
  geom_density(aes(y = ..count.. + 1)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Comparison of peptide score distributions", sep = "")) +
  xlab(expression(Score[MaxQuant] + 1)) +
  scale_x_continuous(trans = "log10", breaks = c(1, seq(50, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score), 50))) +
  ylab("Frequency (absolute)") +
  # scale_y_continuous(trans = "log10") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_absolute.counts", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_absolute.counts", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# normalised counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = Score + 1, colour = peptide_class)) +
  geom_density(aes(y = ..density.. + 1)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Comparison of peptide score distributions", sep = "")) +
  xlab(expression(Score[MaxQuant] + 1)) +
  scale_x_continuous(trans = "log10", breaks = c(1, seq(50, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score), 50))) +
  ylab("Frequency (normalised)") +
  # scale_y_continuous(trans = "log10") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_normalised.counts", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_peptide.score_distribution_per_peptide.class_normalised.counts", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### plot of score vs. PEP

```{r}

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun %>% dplyr::distinct(., PEP, Score, .keep_all = TRUE) %>% dplyr::filter(., PEP <= 1), aes(x = log10(PEP + 1), y = Score + 1, colour = peptide_class)) +
  geom_point() +
  geom_smooth(formula = y ~ x) +
  # show where PEP = 0.01 is
  geom_vline(xintercept = 0.00432137378, colour = "red", linetype = 2) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Correlation~plot~of~peptide~score~vs.~PEP~(PEP <= 0.05~only))) +
  xlab(expression(log[10](PEP[MaxQuant] + 1))) +
  ylab(expression(Score[MaxQuant])) +
  scale_y_continuous(trans = "log10", breaks = c(1, seq(30, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score + 1), 30))) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_correlation_score_vs_PEP", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "qualityplot_correlation_score_vs_PEP", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

## evaluate the local FDR of 3FT peptides only

```{r}

# calculate the peptide FDR based on the evidence.txt information
list_local_FDR <- purrr::map(.x = list_imported_maxquant_tibbles_processed[c("2012_PGNEXUS_proteome_junc.exons", "2020_phosphoproteome_OBseries_junc.exons")], .f = function(a1) {
  
  .x <- a1$peptides 
  # %>% dplyr::filter(PEP < 0.0034)
  
  number_of_reverse_hits_exons <- grep(x = .x$Leading.razor.protein, pattern = "(REV__psisigma)", ignore.case = TRUE) %>% length
  number_of_reverse_hits_junctions <- grep(x = .x$Leading.razor.protein, pattern = "(REV__jum)", ignore.case = TRUE) %>% length
  
  number_of_total_hits_exons <- intersect(grep(x = .x$Leading.razor.protein, pattern = "(psisigma)", ignore.case = TRUE), which(.x$Proteins != "")) %>% length
  number_of_total_hits_junctions <- intersect(grep(x = .x$Leading.razor.protein, pattern = "(jum)", ignore.case = TRUE), which(.x$Proteins != "")) %>% length
  
  FDR_exons <- number_of_reverse_hits_exons/number_of_total_hits_exons
  FDR_junctions <- number_of_reverse_hits_junctions/number_of_total_hits_junctions
  
  return(list(
    "Local FDR info (exons)" = list(
      
      "FDR_exons" = FDR_exons,
      "number_of_reverse_hits_exons" = number_of_reverse_hits_exons,
      "number_of_total_hits_exons" = number_of_total_hits_exons
      
    ),
    "Local FDR info (junctions)" = list(
      
      "FDR_junctions" = FDR_junctions,
      "number_of_reverse_hits_junctions" = number_of_reverse_hits_junctions,
      "number_of_total_hits_junctions" = number_of_total_hits_junctions
      
    )
    
  ))
  
} )

str(list_local_FDR)

```

# Proteomic validation

## Junc/exons only: Filter for PEP and score

```{r}

tibble_junc.exons_filtered <- list_imported_maxquant_tibbles_processed[c("2012_PGNEXUS_proteome_junc.exons", "2020_phosphoproteome_OBseries_junc.exons")] %>% purrr::map2(.x = ., .y = names(.), ~.x$peptides %>% add_column("dbrun" = .y)) %>% rbindlist(fill = TRUE) %>% as_tibble %>% 
  dplyr::filter(PEP <= 0.01 & Score >= 30 & str_detect(string = Leading.razor.protein, pattern = "^REV") == FALSE)

# count the number of splice peptides identified.
cat("\nnumber of junctions/exons with at least some protein evidence: ", tibble_junc.exons_filtered$Proteins %>% strsplit(split = ";") %>% unlist %>% unique %>% length)

# we need to get the total unique number of identifiers from each FASTA. so import then count.
## import FASTA and extract unique identifiers
list_fasta_exons_differential_combined <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_combined_3FT.fasta", seqtype = "AA", as.string = TRUE, forceDNAtolower = FALSE)
vector_unique_identifiers_exons_differential_combined <- names(list_fasta_exons_differential_combined) %>% gsub(x = ., pattern = ".*\\|(.*)\\|.*", replacement = "\\1") %>% unique
list_fasta_exons_constitutive_combined <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_combined_3FT.fasta", seqtype = "AA", as.string = TRUE, forceDNAtolower = FALSE) 
vector_unique_identifiers_exons_constitutive_combined <- names(list_fasta_exons_constitutive_combined) %>% gsub(x = ., pattern = ".*\\|(.*)\\|.*", replacement = "\\1") %>% unique

list_fasta_junctions_differential <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_differential_3FT.fasta", seqtype = "AA", as.string = TRUE, forceDNAtolower = FALSE)
vector_unique_identifiers_junctions_differential_combined <- names(list_fasta_junctions_differential) %>% gsub(x = ., pattern = ".*\\|(.*)\\|.*", replacement = "\\1") %>% unique
list_fasta_junctions_constitutive <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_constitutive_3FT.fasta", seqtype = "AA", as.string = TRUE, forceDNAtolower = FALSE)
vector_unique_identifiers_junctions_constitutive_combined <- names(list_fasta_junctions_constitutive) %>% gsub(x = ., pattern = ".*\\|(.*)\\|.*", replacement = "\\1") %>% unique

cat("\nnumber of total unique exons in the fasta: ", length(vector_unique_identifiers_exons_differential_combined) + length(vector_unique_identifiers_exons_constitutive_combined))
cat("\nnumber of total unique junctions in the fasta: ", length(vector_unique_identifiers_junctions_differential_combined) + length(vector_unique_identifiers_junctions_constitutive_combined))

```

## Gene set enrichment

```{r}

load(file = "/mnt/Tertiary/sharedfolder/polyA_RNAseq_GO_background_GOTERM.catdb")

```

### import the FASTA identifier to gene mappings

```{r}

tibble_fasta_supp_info_exons_differential_ensembl <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_differential_strawberry <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_exons_constitutive_ensembl <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_constitutive_strawberry <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_junctions_differential <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_differential_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_junctions_constitutive <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_constitutive_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

# bind rows
tibble_fasta_supp_info <- dplyr::bind_rows(tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry,
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive)

```

### Join gene names using the FASTA identifier

```{r}

tibble_junc.exons_filtered_with.gene.name <- dplyr::left_join(tibble_junc.exons_filtered, 
                                                              tibble_fasta_supp_info[, c("final_identifier", "gene_name", "splicemode")] %>% 
                                                                dplyr::rename("Leading.razor.protein" = "final_identifier"))

tibble_junc.exons_to_gene.name <- tibble_junc.exons_filtered_with.gene.name[, c("gene_name", "Leading.razor.protein", "Sequence", "splicemode")]

cat("\nnumber of novel exons/junctions: ", grep(x = tibble_junc.exons_to_gene.name$Leading.razor.protein, pattern = "strawberry") %>% length)

```

# Tryptic peptide evaluation and visualisation

## Import the details of 3FT - junctions and exons

```{r}

tibble_detailed_3FT_summary_JUM <- dplyr::bind_rows(tibble_fasta_supp_info_junctions_differential, tibble_fasta_supp_info_junctions_constitutive)

tibble_detailed_3FT_summary_PSIsigma <- dplyr::bind_rows(tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry)

```

## Evaluate junction spanning of tryptic peptides

### Retrieve the parent peptide start and end positions of the matched peptides and test for spanning.

```{r}

# get only the junction entries from the filtered table 
tibble_junc.exons_filtered_with.gene.name_split_juncs.only <- tibble_junc.exons_filtered_with.gene.name %>% 
  # split_delimited_column_in_table(target_colname = "Proteins", split = ";", columns_to_deduplicate = "id") %>% 
  dplyr::filter(str_detect(string = Leading.razor.protein, pattern = "junction")) %>%
  dplyr::distinct(Leading.razor.protein, .keep_all = TRUE)

# now clean up other proteins which were grouped together with the junctions - unnecessary if we're just dealing with the junc.exons.
# we use grep to get the row indices which contain Junction "protein"
# this is final.
# tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split <- tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split[grep(x = tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split$Proteins, pattern = "Junction"), ]

# loop thru each identified tryptic peptide. match to the 3FT info.
## subset to reduce parallel overhead
tibble_detailed_3FT_summary_JUM_subset <- tibble_detailed_3FT_summary_JUM[, c("virtual_peptide_sequence", "fasta_header", "window_start_AA_position", "window_end_AA_position", "junction_AA_position", "ORF")]

list_tryptic_junc_peptides_matched_to_3FT_summary <- future_imap(.x = tibble_junc.exons_filtered_with.gene.name_split_juncs.only %>% array_tree,
                                                                 .f = function(a1, a2) {
                                                                   
                                                                   cat("\nnow processing: ", a2)
                                                                   
                                                                   list("tryptic_peptide_start" = a1$Start.position,
                                                                        "tryptic_peptide_end" = a1$End.position,
                                                                        "matched_3FT_summary_entry" = tibble_detailed_3FT_summary_JUM_subset[which(str_detect(string = tibble_detailed_3FT_summary_JUM_subset$virtual_peptide_sequence, pattern = a1$Sequence) == TRUE & str_detect(string = tibble_detailed_3FT_summary_JUM_subset$fasta_header, pattern = a1$Leading.razor.protein) == TRUE), c("window_start_AA_position", "window_end_AA_position", "junction_AA_position")]) %>% return
                                                                   
                                                                 }, .progress = TRUE, .options = future_options(globals = c("tibble_detailed_3FT_summary_JUM_subset", "str_detect")))

# officially test for junction-spanning.
## it's considered spanning if there's at least one AA on both sides.
list_tryptic_junc_peptides_spanning_logical_test <- list_tryptic_junc_peptides_matched_to_3FT_summary %>% purrr::map(.f = ~any(((.x$matched_3FT_summary_entry$window_start_AA_position + (.x$tryptic_peptide_start %>% trimws %>% as.numeric - 1)) <= (.x$matched_3FT_summary_entry$junction_AA_position - 1)) & ((.x$matched_3FT_summary_entry$window_start_AA_position + (.x$tryptic_peptide_end %>% trimws %>% as.numeric - 1)) >= (.x$matched_3FT_summary_entry$junction_AA_position + 1))
                                                                                                                               ))

# count of shame
cat("\nTHIS IS THE NUMBER OF VALIDATED JUNCTIONS FOR JUM")

cat("\nWe have identified", which(list_tryptic_junc_peptides_spanning_logical_test %>% unlist == TRUE & grepl(x = tibble_junc.exons_filtered_with.gene.name_split_juncs.only$Proteins, pattern = "JUM_constitutive")) %>% length, "peptides which span a splice junction (constitutive).")

cat("\nWe have identified", which(list_tryptic_junc_peptides_spanning_logical_test %>% unlist == TRUE & grepl(x = tibble_junc.exons_filtered_with.gene.name_split_juncs.only$Proteins, pattern = "JUM_differential")) %>% length, "peptides which span a splice junction (differential).")

# write the processed table.
# write.table(tibble_PGNEXUS_MSMS_junction_peptides_with_SJ_crossing_info, file = paste(R_processing_results_dir, "PGNEXUS_MSMS_identified_JUM_q0.01_dpsi0.2_junc.peptides_with_SJ.info.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

```

### further explore what the junction-spanning peptides are

```{r}

tibble_junction_spanning_peptides_identifier.gene <- tibble_junc.exons_filtered_with.gene.name_split_juncs.only[which(list_tryptic_junc_peptides_spanning_logical_test %>% unlist == TRUE), c("gene_name", "Leading.razor.protein", "Sequence", "splicemode")]

```

#### GO enrichment for all junction spanning peptides + exonic peptides identified. 
#### NOTE: THESE ARE NOT VALIDATING. THEY ARE JUST PEPTIDES WHICH PASSED THE SCORE AND PEP CUTOFF.

```{r}

# join exonic peptides and junction-spanning peptides into the same table
tibble_unconfirmed_junc.exons <- dplyr::bind_rows(tibble_junction_spanning_peptides_identifier.gene, tibble_junc.exons_to_gene.name[grep(x = tibble_junc.exons_to_gene.name$Leading.razor.protein, pattern = "PSISigma"), ]) %>% 
  dplyr::arrange(gene_name)

cat("number of exons per gene: ")
tibble_unconfirmed_junc.exons %>% dplyr::filter(str_detect(string = Leading.razor.protein, pattern = "exon")) %>% dplyr::distinct(Leading.razor.protein, .keep_all = TRUE) %>% group_by(gene_name) %>% dplyr::summarise("tally_ids_per_gene" = n()) %>% dplyr::arrange(desc(tally_ids_per_gene)) %>% na.omit %>% .$tally_ids_per_gene %>% mean %>% print

cat("number of junctions per gene: ")
tibble_unconfirmed_junc.exons %>% dplyr::filter(str_detect(string = Leading.razor.protein, pattern = "junction")) %>% dplyr::distinct(Leading.razor.protein, .keep_all = TRUE) %>% group_by(gene_name) %>% dplyr::summarise("tally_ids_per_gene" = n()) %>% dplyr::arrange(desc(tally_ids_per_gene)) %>% na.omit %>% .$tally_ids_per_gene %>% mean %>% print

# write table
write.table(tibble_unconfirmed_junc.exons, file = paste(R_processing_results_dir, "table_brief.info_unconfirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# CONDUCT ENRICHMENT
tibble_hyperGO_confirmed_junc.exons <- dplyr::bind_rows(GOHyperGAll(catdb = catdb, gocat = "MF", sample = tibble_unconfirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "BP", sample = tibble_unconfirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "CC", sample = tibble_unconfirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction) %>% as_tibble

write.table(tibble_hyperGO_confirmed_junc.exons, file = paste(R_processing_results_dir, "table_hyperGO_unconfirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# write the geneset
write.table(tibble_unconfirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, file = paste(R_processing_results_dir, "table_geneset_unconfirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)

```

## Preprocessing for visualisation in IGV

Step 1: Import the details of 3FT - junctions and exons
Step 2: Calculate the genome-relative positions of the identified tryptic peptides
Step 3: Write a BLOCKED bed file (BED12 format)
Step 4 (outside R): BEDtoBAM

### PEPTIDES
### calculate genome-relative ranges of all the nucleotides encoding the identified tryptic peptides
### return a blocked .bed file

```{r}

# split table by exons or junctions
tibble_junction_peptides_only <- tibble_junc.exons_filtered[grep(x = tibble_junc.exons_filtered$Leading.razor.protein, pattern = "JUM", ignore.case = TRUE), ]
tibble_exon_peptides_only <- tibble_junc.exons_filtered[grep(x = tibble_junc.exons_filtered$Leading.razor.protein, pattern = "PSISigma", ignore.case = TRUE), ]

# to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
# extract the MQ outputted start/end positions: 
# 1. They are the valid-ORF-relative coords, 
# 2. then parent translated transcript-relative coords then,
# 3. use the translation frame and 3x length to get the nucleotide positions.
# 4. convert individual nt positions to genomic ranges

# match junctions #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_peptide_bedfile_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_junction_peptides_only[56, ]
  ###########
  
  # cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM$fasta_header, pattern = a1$Leading.razor.protein %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_JUM$virtual_peptide_sequence, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM[row_index_of_matched_3FT_table, ]
  
  # get the ORF status. this will dictate how we determine the translation-relative coords.
  ORF_status <- tibble_matched_3FT_entry$ORF
  
  # for dORF, the position of the first AA is going to be the end of the window - the valid ORF length.
  ORF_AA_length <- nchar(tibble_matched_3FT_entry$virtual_peptide_sequence)
  
  # get translated transcript-relative AA coords
  if (ORF_status == "uORF") {
    translated_transcript_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$window_start_AA_position %>% trimws %>% as.numeric) - 1
    translated_transcript_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$window_start_AA_position %>% trimws %>% as.numeric) - 1
  } else if (ORF_status == "dORF") {
    # must get the position of the first AA of the dORF first.
    translation_frame_relative_dORF_start <- (tibble_matched_3FT_entry$window_end_AA_position %>% trimws %>% as.numeric) - ORF_AA_length + 1
    
    translated_transcript_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
    translated_transcript_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
  }
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  ### then sort in increasing order for the next step
  if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {
    
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
  }
  
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                              "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
    add_column("difference" = .$n.plus.1 - .$n)
  
  ## if there are no gaps, then just take the genomic range as the start:end
  if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
    
    vec_blockCount <- 1
    vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
    vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
    
  } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
    
    vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
    vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                         tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
    vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                       last(all_genome_relative_positions_of_tryptic_peptide))
    vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_block_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
    "start" = first(all_genome_relative_positions_of_tryptic_peptide),
    "end" = last(all_genome_relative_positions_of_tryptic_peptide),
    "name" = a1$Leading.razor.protein %>% paste %>% trimws,
    "score" = a1$Score %>% as.numeric,
    "strand"= tibble_matched_3FT_entry$matched_junction_strand,
    "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
    "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
    "itemRgb" = "153,0,255",
    "blockCount" = vec_blockCount %>% paste(collapse = ","),
    "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
    "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
    "qName" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(list("tibble_block_info" = tibble_block_info,
              "vector_genomic_positions" = all_genome_relative_positions_of_tryptic_peptide))
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM", "tibble_junction_peptides_only", "first", "last")))

# match exons #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_peptide_bedfile_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_exon_peptides_only[1, ]
  ###########
  
  # cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma$fasta_header, pattern = a1$Leading.razor.protein %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_PSIsigma$virtual_peptide_sequence, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma[row_index_of_matched_3FT_table, ]
  
  # get the ORF status. this will dictate how we determine the translation-relative coords.
  ORF_status <- tibble_matched_3FT_entry$ORF_type
  
  # for dORF, the position of the first AA is going to be the exon end (EE) position - the valid ORF length + 1
  ORF_AA_length <- nchar(tibble_matched_3FT_entry$virtual_peptide_sequence)
  
  # get translation-relative AA coords
  if (ORF_status == "uORF") {
    translation_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$list_translation_frame_relative_effective_ES %>% trimws %>% as.numeric) - 1
    translation_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$list_translation_frame_relative_effective_ES %>% trimws %>% as.numeric) - 1
  } else if (ORF_status == "dORF") {
    # must get the position of the first AA of the dORF first.
    translation_frame_relative_dORF_start <- (tibble_matched_3FT_entry$list_translation_frame_relative_effective_EE %>% trimws %>% as.numeric) - ORF_AA_length + 1
    
    translation_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
    translation_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
  }
  
  # get transcript relative nt coords
  ## NOTE: this is strand-dependent.
  parent_transcript_relative_nt_start <- 3*(translation_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + tibble_matched_3FT_entry$list_transcript_relative_first_nt_of_start_codon - 1
  parent_transcript_relative_nt_end <- 3*translation_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)  + tibble_matched_3FT_entry$list_transcript_relative_first_nt_of_start_codon - 1
  
  # get genome-relative positions for every nt encoding the tryptic peptide
  ## have to take the strand into account.
  ### extract the genome-relative forward coords of every nt in the parent transcript
  ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
  vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$list_all_stranded_genome_relative_coords_of_parent_transcript %>% strsplit(split = ",") %>% unlist %>% as.numeric
  ### use the transcript-relative nt coords to match
  all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
  
  # NOTE: the following here does not need to be done because these coords are already stranded! but i will leave it here anyways for future reference/debug.
  ### then sort in increasing order for the next step
  # if (tibble_matched_3FT_entry$strand %>% trimws %>% paste == "+") {
  #   
  #   all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
  #   
  # } else if (tibble_matched_3FT_entry$strand %>% trimws %>% paste == "-") {
  #   
  #   all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
  #   
  # }
  
  # convert the individual nt positions to a set of ranges
  ## achieve this by comparing n to n + 1
  ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
  tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                              "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
    add_column("difference" = .$n.plus.1 - .$n)
  
  ## if there are no gaps, then just take the genomic range as the start:end
  if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
    
    vec_blockCount <- 1
    vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
    vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
    
  } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
    
    vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
    vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                         tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
    vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                       last(all_genome_relative_positions_of_tryptic_peptide))
    vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
    
  }
  
  # the block details are still vector at this point. 
  # must paste collapse in order to use in the BED file.
  tibble_block_info <- tibble(
    "chrom" = tibble_matched_3FT_entry$chr,
    "start" = first(all_genome_relative_positions_of_tryptic_peptide),
    "end" = last(all_genome_relative_positions_of_tryptic_peptide),
    "name" = a1$Leading.razor.protein %>% paste %>% trimws,
    "score" = a1$Score %>% as.numeric,
    "strand"= tibble_matched_3FT_entry$list_matched_strand,
    "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
    "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
    "itemRgb" = "153,0,0",
    "blockCount" = vec_blockCount %>% paste(collapse = ","),
    "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
    "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
    "qName" = a1$Sequence %>% paste %>% trimws)
  
  # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
  return(list("tibble_block_info" = tibble_block_info,
              "vector_genomic_positions" = all_genome_relative_positions_of_tryptic_peptide))
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma_diff", "first", "last")))

# rbind and tibblise
tibble_peptide_bedfile <- splice(list_peptide_bedfile_junctions_only %>% purrr::map(~.x$tibble_block_info), list_peptide_bedfile_exons_only %>% purrr::map(~.x$tibble_block_info)) %>% rbindlist %>% as_tibble %>% dplyr::select(-qName)

# track line
# cat(paste("track name=\"", output_file_name_JUM, "\" description=\"", output_file_name_JUM, "\" graphType=junctions\n", sep = ""), file = paste(R_processing_results_dir, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""))
# 
# append = TRUE
write.table(x = tibble_peptide_bedfile, file = paste(R_processing_results_dir, "proteome_coverage_JUM_PSISigma_cons_diff_strawberry_maxquant.bed", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# GO TO BEDTOOLS NOW ###
# cd /media/Ubuntu/sharedfolder/bedtools2/bin/
# ./bedToBam -i /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bed -bed12 -g hg38.chrom.sizes_ensembl > /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bam

# rtracklayer::export(object = tibble_bedfile, con = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), format = "bedPE")
# 
# # add the QNAME for real this time
# tibble_bedfile2 <- read.delim(file = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), sep = "\t", col.names = colnames(tibble_bedfile)[-length(colnames(tibble_bedfile))], row.names = NULL, header = FALSE, check.names = FALSE) %>% as_tibble

```

#### validate PSI-Sigma exons using the .bed file.

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4)))

# extract only the unique sequence entries from PSI-Sigma
tibble_PSIsigma_peptide_bedfile_unique <- tibble_peptide_bedfile[grep(x = tibble_peptide_bedfile$name, pattern = "PSIsigma", ignore.case = TRUE), ] %>%
  dplyr::distinct(chrom, strand, start, end, blockCount, blockSizes, blockStarts, .keep_all = TRUE) %>%
  # extract the exonic coords
  dplyr::mutate("alternative_exon_start" = gsub(x = name, pattern = ".*VSR_([^_]+)_exon_([^\\:]+)\\:([0-9]+)\\-([0-9]+)$", replacement = "\\3"),
                "alternative_exon_end" = gsub(x = name, pattern = ".*VSR_([^_]+)_exon_([^\\:]+)\\:([0-9]+)\\-([0-9]+)$", replacement = "\\4"))

# list-ify by chromosome for looping with the ensembl GTF

chr_in_common <- intersect(tibble_PSIsigma_peptide_bedfile_unique$chrom %>% unique, tibble_ref_gtf$seqnames %>% unique)

list_PSIsigma_peptide_bedfile_unique_by_chr <- purrr::map(.x = chr_in_common, .f = ~tibble_PSIsigma_peptide_bedfile_unique[tibble_PSIsigma_peptide_bedfile_unique$chrom == .x, ]) %>%
  set_names(chr_in_common)

list_tibble_ref_gtf_by_chr <- purrr::map(.x = chr_in_common, .f = ~tibble_ref_gtf[tibble_ref_gtf$seqnames == .x, ]) %>%
  set_names(chr_in_common)

list_validation_result <- future_map2(
  .x = list_PSIsigma_peptide_bedfile_unique_by_chr,
  .y = list_tibble_ref_gtf_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_PSIsigma_peptide_bedfile_unique_by_chr[[1]]
    # a2 <- list_tibble_ref_gtf_by_chr[[1]]
    ###########
    
    result_L2 <- future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[2]]
        ###########
        
        # We only have to deal with scenarios in which the alternative exon is LONGER than the reference exons.
        # In these cases, we require the protein evidence to lie at least partly in the region unique to the exon. 
        # To that end, we should just ONLY match reference exons which are only PARTIALLY OVERLAPPING with the alernative exon, and find whether the protein evidence is in the overhanging region.
        
        # find all ref. exons overlapping with the alternative exon.
        tibble_ref_exons_partially_overlapping_alt_exon <- a2[which(a2$type == "exon" & 
                                                                      a2$transcript_biotype == "protein_coding" &
                                                                      a2$start < b1$alternative_exon_end %>% type.convert & 
                                                                      a2$end > b1$alternative_exon_start %>% type.convert &
                                                                      (a2$start > b1$alternative_exon_start %>% type.convert | 
                                                                         a2$end < b1$alternative_exon_end %>% type.convert)), ]
        
        # see if there's an exact exon match to the alternative exon.
        tibble_exact_exon_match_to_alternative_exon <- a2[which(a2$type == "exon" & 
                                                                  a2$transcript_biotype == "protein_coding" &
                                                                  a2$start == b1$alternative_exon_start %>% type.convert & 
                                                                  a2$end == b1$alternative_exon_end %>% type.convert), ]
        
        # if no potential ambiguity then the protein evidence is validating.
        # also if there's no corresponding exon in the reference THAT'S PROTEIN CODING, any evidence is validating too! (technically, proteme evidence validates CODING REGIONS of transcripts, and not technically exons themselves.) 
        if (tibble_ref_exons_partially_overlapping_alt_exon %>% nrow == 0 | tibble_exact_exon_match_to_alternative_exon %>% nrow == 0) {
          return("validating")
        } else if (tibble_ref_exons_partially_overlapping_alt_exon %>% nrow > 0) {
          
          # get all the coords of the alternative exon
          vec_all_genomic_positions_of_alternative_exon <- (b1$alternative_exon_start %>% type.convert):(b1$alternative_exon_end %>% type.convert)
          
          # list all the positions of the overhanging region.
          ## get all the coords of each partially overlapping ref. exon.
          list_all_genomic_positions_of_each_partially_overlapping_ref_exon <- purrr::map2(.x = tibble_ref_exons_partially_overlapping_alt_exon$start,
                                                                                           .y = tibble_ref_exons_partially_overlapping_alt_exon$end,
                                                                                           .f = ~.x:.y)
          
          # get overhang positions (setdiff) for each ref. exon
          # NOTE: ORDER IS IMPORTANT. it's left arg. minus right arg.
          list_all_genomic_positions_of_overhangs_per_ref_exon <- purrr::map(.x = list_all_genomic_positions_of_each_partially_overlapping_ref_exon,
                                                                             .f = ~setdiff(vec_all_genomic_positions_of_alternative_exon, .x))
          
          # keep only unique overhang positions.
          vector_all_unique_overhang_genomic_positions <- list_all_genomic_positions_of_overhangs_per_ref_exon %>% purrr::reduce(intersect)
          
          # finally test for overlap between the tryptic peptide and the overhang
          logical_test_overhang_overlap <- any(vector_all_unique_overhang_genomic_positions <= b1$thickEnd & vector_all_unique_overhang_genomic_positions >= b1$thickStart)
          
          if (logical_test_overhang_overlap == TRUE) {
            return("validating")
          } else if (logical_test_overhang_overlap == FALSE) {
            return("ambiguous")
          }
          
        }
        
      } ) %>%  # L2: each tryptic peptide entry
      set_names(nm = paste(a1$name,";", a1$thickStart, "-", a1$thickEnd, sep = ""))
    
  }, .progress = TRUE ) # L1: over chromosomes

# tibblise into a summary of ambiguity for each exon
tibble_PSIsigma_exon_ambiguity_summary <- list_validation_result %>% 
  flatten %>% 
  as_tibble(.name_repair = "unique") %>% 
  t %>% 
  as_tibble(name_repair = "unique", rownames = "final_identifier_and_peptide_coords") %>% 
  setNames(c("final_identifier_and_peptide_coords", "ambiguity")) %>% 
  dplyr::mutate("final_identifier" = gsub(x = final_identifier_and_peptide_coords, pattern = "(.*);(.*)", replacement = "\\1"))

# finally the count of shame as we get absolutely screwed over by the sparseness of LC-MS.
cat("\nTHIS IS THE NUMBER OF VALIDATED EXONS FOR PSI-SIGMA")

cat("\nWe have identified", tibble_PSIsigma_exon_ambiguity_summary[grep(x = tibble_PSIsigma_exon_ambiguity_summary$final_identifier, pattern = "differential", ignore.case = TRUE), ] %>% dplyr::filter(ambiguity == "validating") %>% dplyr::distinct(final_identifier) %>% nrow, "peptides which are validating (differential).")

cat("\nWe have identified", tibble_PSIsigma_exon_ambiguity_summary[grep(x = tibble_PSIsigma_exon_ambiguity_summary$final_identifier, pattern = "constitutive", ignore.case = TRUE), ] %>% dplyr::filter(ambiguity == "validating") %>% dplyr::distinct(final_identifier) %>% nrow, "peptides which are validating (constitutive).")

```

#### calculate statistics on the number of known vs. novel junctions/exons.

```{r}

options(mc.cores = 8)

# retrieve genome-relative positions of tryptic peptides
list_peptide_genome_relative_positions <- splice(list_peptide_bedfile_junctions_only %>% purrr::map(~.x$vector_genomic_positions), 
                                                 list_peptide_bedfile_exons_only %>% purrr::map(~.x$vector_genomic_positions))
# test for overlap with reference CDS regions
## subset reference GTF for CDS regions only
tibble_ref_gtf_CDS_only <- tibble_ref_gtf[tibble_ref_gtf$type == "CDS", ]

options(mc.cores = 48)

# NOTE: TRUE if overlaps with any reference CDS. FALSE if not.
list_logical_test_for_CDS_overlap <- future_map2(
  .x = list_peptide_genome_relative_positions,
  .y = tibble_peptide_bedfile$chrom,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_peptide_genome_relative_positions[[1]]
    # a2 <- tibble_peptide_bedfile$chrom %>% .[[1]]
    ###########
    
    result <- purrr::map(
      .x = a1,
      .f = function(b1) {
        
        (b1 < (tibble_ref_gtf_CDS_only[tibble_ref_gtf_CDS_only$seqnames == a2, ] %>% .$end) & 
           b1 > (tibble_ref_gtf_CDS_only[tibble_ref_gtf_CDS_only$seqnames == a2, ] %>% .$start)) %>%
          any %>%
          return
        
      } )
    
    return(result %>% unlist %>% any == TRUE)
    
  }, .progress = TRUE)

# finally count the number of novel peptides we have identified
cat("\nTHIS IS THE NUMBER OF NOVEL SPLICE PEPTIDES IDENTIFIED")

cat("\nWe have identified", tibble_peptide_bedfile[(list_logical_test_for_CDS_overlap %>% unlist == FALSE) %>% which, ] %>% nrow, "novel peptides in proximity to splice regions")

# we are now going to extract only the final_identifiers which are validating.
vector_validated_final_identifiers <- c(tibble_PSIsigma_exon_ambiguity_summary[grep(x = tibble_PSIsigma_exon_ambiguity_summary$final_identifier, pattern = "constitutive", ignore.case = TRUE), ] %>% dplyr::filter(ambiguity == "validating") %>% dplyr::distinct(final_identifier) %>% unlist,
                                        tibble_junction_spanning_peptides_identifier.gene$Leading.razor.protein %>% unlist)

# write novel splice peptides as .bed file
write.table(x = tibble_peptide_bedfile[(list_logical_test_for_CDS_overlap %>% unlist == FALSE) %>% which, ] %>% .[.$name %in% vector_validated_final_identifiers, ], file = paste(R_processing_results_dir, "proteome_coverage_JUM_PSISigma_cons_diff_strawberry_maxquant_novel_validating_peptides.bed", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

cat("\nHence we have identified", tibble_peptide_bedfile[(list_logical_test_for_CDS_overlap %>% unlist == FALSE) %>% which, ] %>% .[.$name %in% vector_validated_final_identifiers, ] %>% nrow, "novel splice junctions/exons, backed by proteome evidence.")

# export validated junc.exons info and GO enrichment
tibble_confirmed_junc.exons <- tibble_unconfirmed_junc.exons[tibble_unconfirmed_junc.exons$Leading.razor.protein %in% vector_validated_final_identifiers, ]

# write table
write.table(tibble_confirmed_junc.exons, file = paste(R_processing_results_dir, "table_brief.info_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# CONDUCT ENRICHMENT
tibble_hyperGO_confirmed_junc.exons <- dplyr::bind_rows(GOHyperGAll(catdb = catdb, gocat = "MF", sample = tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "BP", sample = tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "CC", sample = tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction) %>% as_tibble

write.table(tibble_hyperGO_confirmed_junc.exons, file = paste(R_processing_results_dir, "table_hyperGO_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# write the geneset
write.table(tibble_confirmed_junc.exons$gene_name %>% strsplit(split = ",") %>% unlist, file = paste(R_processing_results_dir, "table_geneset_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)

```

### PHOSPHOSITES
### return a .mut mutation file.
### actually, maybe not, since the phosphosites might be gapped.

```{r}

tibble_class_I_phosphosites <- list_imported_maxquant_tibbles_processed$`2020_phosphoproteome_OBseries_junc.exons`$phosphosites %>%
  # filter for class I phosphosites
  # remove the reverse hits or table split wont work
  dplyr::filter(Localization.prob >= 0.75 & PEP <= 0.01 & Score >= 30 & Reverse != "+") %>%
  # dedupe in preparation for the next step
  split_delimited_columns_in_table(input_table = ., target_colname = c("Proteins", "Positions.within.proteins"), split = ";", columns_to_deduplicate = "id") %>%
  split_delimited_columns_in_table(input_table = ., target_colname = c("Peptide.IDs"), split = ";", columns_to_deduplicate = NULL) %>%
  type_convert %>%
  # add the "sequence" information by joining with the peptides table so we can accurately match back to the FASTA
  dplyr::left_join(., list_imported_maxquant_tibbles_processed$`2020_phosphoproteome_OBseries_junc.exons`$peptides %>% dplyr::rename("Peptide.IDs" = "id") %>% dplyr::select(Peptide.IDs, Sequence), by = "Peptide.IDs")

# split table by exons or junctions
tibble_junction_peptides_only <- tibble_class_I_phosphosites[grep(x = tibble_class_I_phosphosites$Proteins, pattern = "^JUM", ignore.case = TRUE), ]
tibble_exon_peptides_only <- tibble_class_I_phosphosites[grep(x = tibble_class_I_phosphosites$Proteins, pattern = "^PSISigma", ignore.case = TRUE), ]

# to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
# extract the MQ outputted start/end positions: 
# 1. They are the valid-ORF-relative coords, 
# 2. then parent translated transcript-relative coords then,
# 3. use the translation frame and 3x length to get the nucleotide positions.
# 4. convert individual nt positions to genomic ranges

# match junctions #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_bedfile_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_junction_peptides_only[2, ]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM$fasta_header, pattern = a1$Proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_JUM$virtual_peptide_sequence, pattern = a1$Sequence %>% gsub(pattern = "_", replacement = "") %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM[row_index_of_matched_3FT_table %>% na.omit, ]
  
  if (tibble_matched_3FT_entry %>% nrow == 0) {
    return(NULL)
  } else {
    
    # get the ORF status. this will dictate how we determine the translation-relative coords.
    ORF_status <- tibble_matched_3FT_entry$ORF
    
    # get sequence length
    tryptic_peptide_sequence_length <- a1$Sequence %>% nchar
    
    # get translated transcript-relative AA coords
    if (ORF_status == "uORF") {
      parent_transcript_relative_nt_start <- tibble_matched_3FT_entry$translation_window_start_transcript.relative + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + 3*(a1$Positions.within.proteins %>% trimws %>% as.numeric - 1) + 1
      parent_transcript_relative_nt_end <- tibble_matched_3FT_entry$translation_window_start_transcript.relative + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + 3*tryptic_peptide_sequence_length
    } else if (ORF_status == "dORF") {
      parent_transcript_relative_nt_start <- tibble_matched_3FT_entry$first_nt_after_splice_junction_transcript_relative + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + 3*(a1$Positions.within.proteins %>% trimws %>% as.numeric - 1) + 1
      parent_transcript_relative_nt_end <- tibble_matched_3FT_entry$first_nt_after_splice_junction_transcript_relative + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + 3*tryptic_peptide_sequence_length
    }
    
    # get genome-relative positions for every nt encoding the tryptic peptide
    ## have to take the strand into account.
    ### extract the genome-relative forward coords of every nt in the parent transcript
    ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
    # vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
    ### use the transcript-relative nt coords to match
    # all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
    # NOTE: the following here does not need to be done because these coords are already stranded! but i will leave it here anyways for future reference/debug.
    ### use the transcript-relative nt coords to match
    ### then sort in increasing order for the next step
    vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric %>% sort
    
    if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {

      all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort

    } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {

      all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort

    }
    
    # convert the individual nt positions to a set of ranges
    ## achieve this by comparing n to n + 1
    ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
    tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                                "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
      add_column("difference" = .$n.plus.1 - .$n)
    
    ## if there are no gaps, then just take the genomic range as the start:end
    if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
      
      vec_blockCount <- 1
      vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
      vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
      
    } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
      
      vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
      vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                           tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
      vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                         last(all_genome_relative_positions_of_tryptic_peptide))
      vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
      
    }
    
    # the block details are still vector at this point. 
    # must paste collapse in order to use in the BED file.
    tibble_block_info <- tibble(
      "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
      "start" = first(all_genome_relative_positions_of_tryptic_peptide),
      "end" = last(all_genome_relative_positions_of_tryptic_peptide),
      "name" = a1$Leading.proteins %>% paste %>% trimws,
      "score" = a1$Score %>% as.numeric,
      "strand"= tibble_matched_3FT_entry$matched_junction_strand,
      "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
      "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
      "itemRgb" = "255,187,0",
      "blockCount" = vec_blockCount %>% paste(collapse = ","),
      "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
      "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
      "qName" = a1$Sequence %>% paste %>% trimws)
    
    # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
    return(list("tibble_block_info" = tibble_block_info,
              "vector_genomic_positions" = all_genome_relative_positions_of_tryptic_peptide))
    
  }
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM", "tibble_junction_peptides_only", "first", "last")) )

# prune non-matches
list_bedfile_junctions_only_pruned <- list_bedfile_junctions_only %>% purrr::discard(.p = ~.x %>% is.null == TRUE)

# match exons #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_bedfile_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_exon_peptides_only[4, ]
  ###########
  
  # cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_PSIsigma$virtual_peptide_sequence, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma[row_index_of_matched_3FT_table %>% na.omit, ]
  
  if (tibble_matched_3FT_entry %>% nrow == 0) {
    return(NULL)
  } else {
    
    # get the ORF status. this will dictate how we determine the translation-relative coords.
    ORF_status <- tibble_matched_3FT_entry$ORF_type
    
    # for dORF, the position of the first AA is going to be the exon end (EE) position - the valid ORF length + 1
    ORF_AA_length <- nchar(tibble_matched_3FT_entry$virtual_peptide_sequence)
    
    # get translated transcript-relative AA coords
    if (ORF_status == "uORF") {
      translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$list_translation_frame_relative_effective_ES %>% trimws %>% as.numeric) - 1
      translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$list_translation_frame_relative_effective_ES %>% trimws %>% as.numeric) - 1
    } else if (ORF_status == "dORF") {
      # must get the position of the first AA of the dORF first.
      translation_frame_relative_dORF_start <- (tibble_matched_3FT_entry$list_translation_frame_relative_effective_EE %>% trimws %>% as.numeric) - ORF_AA_length + 1
      
      translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
      translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
    }
    
    # get transcript relative nt coords
    ## NOTE: this is strand-dependent.
    parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + tibble_matched_3FT_entry$list_transcript_relative_first_nt_of_start_codon - 1
    parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + tibble_matched_3FT_entry$list_transcript_relative_first_nt_of_start_codon - 1
    
    # get genome-relative positions for every nt encoding the tryptic peptide
    ## have to take the strand into account.
    ### extract the genome-relative forward coords of every nt in the parent transcript
    ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
    vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$list_all_stranded_genome_relative_coords_of_parent_transcript %>% strsplit(split = ",") %>% unlist %>% as.numeric
    ### use the transcript-relative nt coords to match
    all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
    # NOTE: the following here does not need to be done because these coords are already stranded! but i will leave it here anyways for future reference/debug.
    ### then sort in increasing order for the next step
    # if (tibble_matched_3FT_entry$strand %>% trimws %>% paste == "+") {
    #   
    #   all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    #   
    # } else if (tibble_matched_3FT_entry$strand %>% trimws %>% paste == "-") {
    #   
    #   all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    #   
    # }
    
    # convert the individual nt positions to a set of ranges
    ## achieve this by comparing n to n + 1
    ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
    tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                                "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
      add_column("difference" = .$n.plus.1 - .$n)
    
    ## if there are no gaps, then just take the genomic range as the start:end
    if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
      
      vec_blockCount <- 1
      vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
      vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
      
    } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
      
      vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
      vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                           tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
      vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                         last(all_genome_relative_positions_of_tryptic_peptide))
      vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
      
    }
    
    # the block details are still vector at this point. 
    # must paste collapse in order to use in the BED file.
    tibble_block_info <- tibble(
      "chrom" = tibble_matched_3FT_entry$chr,
      "start" = first(all_genome_relative_positions_of_tryptic_peptide),
      "end" = last(all_genome_relative_positions_of_tryptic_peptide),
      "name" = a1$Leading.proteins %>% paste %>% trimws,
      "score" = a1$Score %>% as.numeric,
      "strand"= tibble_matched_3FT_entry$list_matched_strand,
      "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
      "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
      "itemRgb" = "255,187,0",
      "blockCount" = vec_blockCount %>% paste(collapse = ","),
      "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
      "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
      "qName" = a1$Sequence %>% paste %>% trimws)
    
    # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
    return(list("tibble_block_info" = tibble_block_info,
              "vector_genomic_positions" = all_genome_relative_positions_of_tryptic_peptide))   
    
  }
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma", "first", "last")))

# prune non-matches
list_bedfile_exons_only_pruned <- list_bedfile_exons_only %>% purrr::discard(.p = ~.x %>% is.null == TRUE)

# rbind and tibblise
tibble_phosphosite_bedfile <- splice(list_bedfile_junctions_only %>% purrr::map(~.x$tibble_block_info), list_bedfile_exons_only %>% purrr::map(~.x$tibble_block_info)) %>% rbindlist %>% as_tibble %>% dplyr::select(-qName)

# track line
# cat(paste("track name=\"", output_file_name_JUM, "\" description=\"", output_file_name_JUM, "\" graphType=junctions\n", sep = ""), file = paste(R_processing_results_dir, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""))
# 
# append = TRUE
write.table(x = tibble_phosphosite_bedfile, file = paste(R_processing_results_dir, "phosphosite_coverage_JUM_PSISigma_cons_diff_strawberry_maxquant.bed", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# GO TO BEDTOOLS NOW ###
# cd /media/Ubuntu/sharedfolder/bedtools2/bin/
# ./bedToBam -i /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bed -bed12 -g hg38.chrom.sizes_ensembl > /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results_dir/proteomic_alignment_junc.exons_peptides.bam

# rtracklayer::export(object = tibble_bedfile, con = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), format = "bedPE")
# 
# # add the QNAME for real this time
# tibble_bedfile2 <- read.delim(file = paste(R_processing_results_dir, "bedfile_", a2, "_", b2, ".bed", sep = ""), sep = "\t", col.names = colnames(tibble_bedfile)[-length(colnames(tibble_bedfile))], row.names = NULL, header = FALSE, check.names = FALSE) %>% as_tibble

```

#### export a tibble of all genome-relative coords for evaluation of phosphosites in differential regions

```{r}

# to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
# extract the MQ outputted start/end positions: 
# 1. They are the valid-ORF-relative coords, 
# 2. then parent translated transcript-relative coords then,
# 3. use the translation frame and 3x length to get the nucleotide positions.
# 4. convert individual nt positions to genomic ranges

# match junctions #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_genome.relative.positions_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_junction_peptides_only %>% array_tree %>% .[[103]]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_JUM$virtual_peptide_sequence, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM[row_index_of_matched_3FT_table %>% na.omit, ]
  
  if (tibble_matched_3FT_entry %>% nrow == 0) {
    return(NULL)
  } else {
    
    # get the ORF status. this will dictate how we determine the translation-relative coords.
    ORF_status <- tibble_matched_3FT_entry$ORF
    
    # for dORF, the position of the first AA is going to be the end of the window - the valid ORF length.
    ORF_AA_length <- nchar(tibble_matched_3FT_entry$virtual_peptide_sequence)
    
    # get translated transcript-relative AA coords
    if (ORF_status == "uORF") {
      translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$window_start_AA_position %>% trimws %>% as.numeric) - 1
      translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$window_start_AA_position %>% trimws %>% as.numeric) - 1
    } else if (ORF_status == "dORF") {
      # must get the position of the first AA of the dORF first.
      translation_frame_relative_dORF_start <- (tibble_matched_3FT_entry$window_end_AA_position %>% trimws %>% as.numeric) - ORF_AA_length + 1
      
      translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
      translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
    }
    
    # get transcript relative nt coords
    ## NOTE: this is strand-dependent.
    parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
    parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
    
    # get genome-relative positions for every nt encoding the tryptic peptide
    ## have to take the strand into account.
    ### extract the genome-relative forward coords of every nt in the parent transcript
    ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
    vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
    ### use the transcript-relative nt coords to match
    ### then sort in increasing order for the next step
    if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {
      
      all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
      
    } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {
      
      all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
      
    }
    
    # the block details are still vector at this point. 
    # must paste collapse in order to use in the BED file.
    tibble_position_info <- tibble(
      "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
      "genome_relative_positions_phosphosite" = paste(all_genome_relative_positions_of_tryptic_peptide, collapse = ","),
      "final_identifier" = a1$Leading.proteins %>% paste %>% trimws,
      "strand"= tibble_matched_3FT_entry$matched_junction_strand,
      "protein_sequence_tryptic_peptide" = a1$Sequence %>% paste %>% trimws)
    
    # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
    return(tibble_position_info)      
    
  }
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM", "tibble_junction_peptides_only", "first", "last")) )

# match exons #####
## retrieve the row index of the detailed 3FT table
## match FASTA header and sequence
## take the first match is fine.
list_genome.relative.positions_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- tibble_exon_peptides_only %>% array_tree %>% .[[4]]
  ###########
  
  cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
  
  row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma$fasta_header, pattern = a1$Leading.proteins %>% paste %>% trimws) %>% which,
                                              str_detect(string = tibble_detailed_3FT_summary_PSIsigma$virtual_peptide_sequence, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
  
  tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma[row_index_of_matched_3FT_table %>% na.omit, ]
  
  if (tibble_matched_3FT_entry %>% nrow == 0) {
    return(NULL)
  } else {
    
    # get the ORF status. this will dictate how we determine the translation-relative coords.
    ORF_status <- tibble_matched_3FT_entry$ORF_type
    
    # for dORF, the position of the first AA is going to be the exon end (EE) position - the valid ORF length + 1
    ORF_AA_length <- nchar(tibble_matched_3FT_entry$virtual_peptide_sequence)
    
    # get translated transcript-relative AA coords
    if (ORF_status == "uORF") {
      translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$list_translation_frame_relative_effective_ES %>% trimws %>% as.numeric) - 1
      translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$list_translation_frame_relative_effective_ES %>% trimws %>% as.numeric) - 1
    } else if (ORF_status == "dORF") {
      # must get the position of the first AA of the dORF first.
      translation_frame_relative_dORF_start <- (tibble_matched_3FT_entry$list_translation_frame_relative_effective_EE %>% trimws %>% as.numeric) - ORF_AA_length + 1
      
      translated_transcript_relative_AA_start <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
      translated_transcript_relative_AA_end <- (a1$Positions.within.proteins %>% trimws %>% as.numeric) + translation_frame_relative_dORF_start - 1
    }
    
    # get parent transcript-relative nt coords
    parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + tibble_matched_3FT_entry$list_transcript_relative_first_nt_of_start_codon - 1
    parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric) + tibble_matched_3FT_entry$list_transcript_relative_first_nt_of_start_codon - 1
    
    # get genome-relative positions for every nt encoding the tryptic peptide
    ## NOTE: coords of parent transcript were already sorted by stranded order. Makes life much simpler
    vec_stranded_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$list_all_stranded_genome_relative_coords_of_parent_transcript %>% strsplit(split = ",") %>% unlist %>% as.numeric
    ### use the transcript-relative nt coords to match
    all_genome_relative_positions_of_tryptic_peptide <- vec_stranded_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
    
    # the block details are still vector at this point. 
    # must paste collapse in order to use in the BED file.
    tibble_position_info <- tibble(
      "chrom" = tibble_matched_3FT_entry$chr,
      "genome_relative_positions_phosphosite" = paste(all_genome_relative_positions_of_tryptic_peptide, collapse = ","),
      "final_identifier" = a1$Leading.proteins %>% paste %>% trimws,
      "strand"= tibble_matched_3FT_entry$list_matched_strand,
      "protein_sequence_tryptic_peptide" = a1$Sequence %>% paste %>% trimws)
    
    # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
    return(tibble_position_info)      
    
  }
  
}, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma", "first", "last")))

# rbind and tibblise
tibble_genome.relative.positions_phosphosites <- splice(list_genome.relative.positions_junctions_only, list_genome.relative.positions_exons_only) %>% rbindlist %>% as_tibble

# write table.
write.table(x = tibble_genome.relative.positions_phosphosites, file = paste(R_processing_results_dir, "genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

#### Get statistics on the number new/novel phosphosites

THE PROBLEM: we need some way to detect phosphosites in JUM differential regions

STRATEGY: 
1. Get ALL the genome-relative positions of BOTH juncs/exons (here) and swissprot (MQtobed) phosphosites. 
2. Intersect with the differential junction and exon positions to find all phosphosites in splice regions
3. Cast dbPTM sites onto genome
4. Find which are not in dbPTM - novel phosphosites

##### IMPORT NECESSARY FILES

```{r}

# get ENSP to uniprotkb_entry mapping
load(file = paste(shared_dir, "tibble_ENSP_to_uniprotkb.tibble", sep = ""))
# get all the genome-relative positions of CDS nucleotides for every ENSP id
load(file = paste(shared_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import reference-matched JUM and PSI-Sigma differential positions (from junc/exon ontology)
# JUM ###
tibble_JUM_junction_ontology_supp_info <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::mutate("chr" = gsub(x = AS_event_ID, pattern = "^([^_]+).*", replacement = "\\1"))
# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_supp_info <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::mutate("chr" = gsub(x = event_region_coords, pattern = "^([^\\:]+).*", replacement = "\\1"))

# MQtobed - phosphosites 
tibble_MQtobed_2020_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms/2020_phosphoproteome_swissprot_phosphosite_coverage_supp_info.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

##### Cast dbPTM sites onto the genome

```{r}

# convert uniprotkb_entry into ENSP
tibble_dbPTM_allhuman_annotations_with_ENSP <- dplyr::left_join(tibble_dbPTM_allhuman_annotations, tibble_ENSP_to_uniprotkb, by = "uniprotkb_entry") %>% 
  dplyr::filter(is.na(ensembl_peptide_id) != TRUE) %>% type_convert

# cast onto genome.
tibble_dbPTM_allhuman_annotations <- tibble_dbPTM_allhuman_annotations_with_ENSP %>% 
  add_column("CDS_relative_coords_start" = ((3*.$modified_residue_position) - 2), "CDS_relative_coords_end" = (3*.$modified_residue_position)) %>% 
  dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
  dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
  # some ENSP ids from interpro are not in ensembl.
  dplyr::filter(is.na(chr) != TRUE) 

# split by chr to parallel loop more efficiently
list_dbPTM_allhuman_annotations <- tibble_dbPTM_allhuman_annotations %>%
  dplyr::group_split(PTM_type, chr, CDS_relative_coords_start %% 13) 

plan(list(tweak(multiprocess, workers = 30),
          tweak(multiprocess, workers = 10)))

# plan(multiprocess)
# options(mc.cores = 144)

# retrieve genome-relative coords
list_dbPTM_allhuman_annotations_cast_onto_genome_by_chr <- furrr::future_map(
  .x = list_dbPTM_allhuman_annotations, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_dbPTM_allhuman_annotations[[50]]
    ###########
    
    a1 %>%
      dplyr::mutate("vec_all_genome_relative_coords_of_item" = purrr::map2(
        .x = a1$vec_all_CDS_relative_positions, 
        .y = a1$vec_all_parent_ENSP_CDS_positions_sorted, 
        .f = ~.y %>% unlist %>% .[.x])) %>% 
      dplyr::mutate("nucleotide_width" = purrr::map(.x = .$vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist) %>%
      return

  }, .progress = TRUE )

tibble_dbPTM_allhuman_annotations_cast_onto_genome <- list_dbPTM_allhuman_annotations_cast_onto_genome_by_chr %>% rbindlist %>% as_tibble

# drop the columns of all ENSP positions. we dont need them anymore.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted, -`CDS_relative_coords_start%%13`)

# save(tibble_dbPTM_allhuman_annotations_cast_onto_genome,
     # file = paste(R_processing_results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.tibble", sep = ""))

load(file = paste(R_processing_results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.tibble", sep = ""))

# create a list of vectors describing all unique genomic positions
list_dbPTM_allhuman_phosphosites_genome_relative_positions <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>%
  dplyr::filter(PTM_type == "Phosphorylation") %>%
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist) %>%
  purrr::map(~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unique %>% sort)

```

##### Intersect the phosphosites with differential positions

```{r}

# get list of purely differential positions from BOTH tools (by chromosome)
list_all_genome_relative_differentially_spliced_regions <- dplyr::bind_rows(
  tibble_JUM_junction_ontology_supp_info[, c("chr", "vector_genomic_coords_of_all_differential_exon_positions")],
  tibble_PSIsigma_exon_ontology_supp_info[, c("chr", "vector_genomic_coords_of_all_differential_exon_positions")]) %>%
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist) %>% 
  purrr::map(~.x$vector_genomic_coords_of_all_differential_exon_positions %>% strsplit(split = ",") %>% unlist %>% type.convert %>% unique %>% sort)

# list-ify the junc/exons and swissprot phosphosite tables by chr
## junc.exons
list_junc.exons_phosphosite_positions_by_chr <- tibble_genome.relative.positions_phosphosites %>%
  dplyr::group_split(chrom) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chrom %>% unique) %>% unlist)
## swissprot
list_swissprot_phosphosite_positions_by_chr <- tibble_MQtobed_2020_phosphosites %>%
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 30),
          tweak(multiprocess, workers = 2)))

# intersect for each element of the junc/exons or swissprot phosphosites tibbles
# add logical info. as a new column
## NOTE: logical = TRUE, if there is overlap i.e. phosphosite lies in differential region.
### junc.exons
list_tibble_junc.exons_phosphosites_intersect_diffspliced_regions <- furrr::future_map2(
  .x = list_junc.exons_phosphosite_positions_by_chr,
  .y = list_all_genome_relative_differentially_spliced_regions[names(list_junc.exons_phosphosite_positions_by_chr)],
  .f = function(a1, a2) {
    
    furrr::future_map(.x = a1 %>% array_tree,
                      .f = function(b1) {
                        
                        vector_genome_relative_coords_of_phosphosite <- b1$genome_relative_positions_phosphosite %>% strsplit(split = ",") %>% unlist %>% type.convert
                        
                        logical_intersects_or_not <- intersect(a2, vector_genome_relative_coords_of_phosphosite) %>% length > 0
                        
                        return(b1 %>% as_tibble %>% add_column("intersects_differential_region" = logical_intersects_or_not))
                        
                      } ) %>%
      rbindlist %>% as_tibble %>%
      return
      
  }, .progress = TRUE )
              
### swissprot                                                                          
list_tibble_swissprot_phosphosites_intersect_diffspliced_regions <- furrr::future_map2(
  .x = list_swissprot_phosphosite_positions_by_chr,
  .y = list_all_genome_relative_differentially_spliced_regions[names(list_swissprot_phosphosite_positions_by_chr)],
  .f = function(a1, a2) {
    
    furrr::future_map(.x = a1 %>% array_tree,
                      .f = function(b1) {
                        
                        vector_genome_relative_coords_of_phosphosite <- b1$all_genomic_positions_of_feature %>% strsplit(split = ",") %>% unlist %>% type.convert
                        
                        logical_intersects_or_not <- intersect(a2, vector_genome_relative_coords_of_phosphosite) %>% length > 0
                        
                        return(b1 %>% as_tibble %>% add_column("intersects_differential_region" = logical_intersects_or_not))
                        
                      } ) %>%
      rbindlist %>% as_tibble %>%
      return
    
  }, .progress = TRUE )

```

##### Intersect with dbPTM

```{r}

### junc.exons
list_tibble_junc.exons_phosphosites_intersect_diffspliced_regions_and_dbPTM <- furrr::future_map2(
  .x = list_tibble_junc.exons_phosphosites_intersect_diffspliced_regions,
  .y = list_dbPTM_allhuman_phosphosites_genome_relative_positions[names(list_tibble_junc.exons_phosphosites_intersect_diffspliced_regions)],
  .f = function(a1, a2) {
    
    furrr::future_map(.x = a1 %>% array_tree,
                      .f = function(b1) {
                        
                        vector_genome_relative_coords_of_phosphosite <- b1$genome_relative_positions_phosphosite %>% strsplit(split = ",") %>% unlist %>% type.convert
                        
                        logical_intersects_or_not <- intersect(a2, vector_genome_relative_coords_of_phosphosite) %>% length > 0
                        
                        return(b1 %>% as_tibble %>% add_column("intersects_dbPTM_phosphosite" = logical_intersects_or_not))
                        
                      } ) %>%
      rbindlist %>% as_tibble %>%
      return
      
  }, .progress = TRUE )

### swissprot                                                                          
list_tibble_swissprot_phosphosites_intersect_diffspliced_regions_and_dbPTM <- furrr::future_map2(
  .x = list_tibble_swissprot_phosphosites_intersect_diffspliced_regions,
  .y = list_dbPTM_allhuman_phosphosites_genome_relative_positions[names(list_tibble_swissprot_phosphosites_intersect_diffspliced_regions)],
  .f = function(a1, a2) {
    
    furrr::future_map(.x = a1 %>% array_tree,
                      .f = function(b1) {
                        
                        vector_genome_relative_coords_of_phosphosite <- b1$all_genomic_positions_of_feature %>% strsplit(split = ",") %>% unlist %>% type.convert
                        
                        logical_intersects_or_not <- intersect(a2, vector_genome_relative_coords_of_phosphosite) %>% length > 0
                        
                        return(b1 %>% as_tibble %>% add_column("intersects_dbPTM_phosphosite" = logical_intersects_or_not))
                        
                      } ) %>%
      rbindlist %>% as_tibble %>%
      return
    
  }, .progress = TRUE )

# rbind and tibblise
tibble_junc.exons_phosphosites_intersect_diffspliced_regions_and_dbPTM <- list_tibble_junc.exons_phosphosites_intersect_diffspliced_regions_and_dbPTM %>% rbindlist %>% as_tibble

tibble_swissprot_phosphosites_intersect_diffspliced_regions_and_dbPTM <- list_tibble_swissprot_phosphosites_intersect_diffspliced_regions_and_dbPTM %>% rbindlist %>% as_tibble

```

##### Finally we can print the statistics on the number of known/novel

```{r}

# combine swissprot and junc.exons tibble and take unique phosphosites only
tibble_combined_swissprot_junc.exons_phosphosites_intersection_unique <- dplyr::bind_rows(
  tibble_junc.exons_phosphosites_intersect_diffspliced_regions_and_dbPTM[, c("chrom", "genome_relative_positions_phosphosite", "intersects_differential_region", "intersects_dbPTM_phosphosite")] %>% dplyr::rename("chr" = "chrom", "all_genomic_positions_of_feature" = "genome_relative_positions_phosphosite"),
  tibble_swissprot_phosphosites_intersect_diffspliced_regions_and_dbPTM[, c("chr", "all_genomic_positions_of_feature", "intersects_differential_region", "intersects_dbPTM_phosphosite")]
) %>%
  dplyr::distinct(chr, all_genomic_positions_of_feature, .keep_all = TRUE)

# count numbers
cat("number of phosphosites in differentially spliced regions: ", (tibble_combined_swissprot_junc.exons_phosphosites_intersection_unique$intersects_differential_region == TRUE) %>% which %>% length)

cat("number of novel phosphosites overall: ", (tibble_combined_swissprot_junc.exons_phosphosites_intersection_unique$intersects_dbPTM_phosphosite == TRUE) %>% which %>% length)

cat("number of NOVEL phosphosites in differentially spliced regions: ", (tibble_combined_swissprot_junc.exons_phosphosites_intersection_unique$intersects_differential_region == TRUE &
                                                                           tibble_combined_swissprot_junc.exons_phosphosites_intersection_unique$intersects_dbPTM_phosphosite == TRUE) %>% which %>% length)

```

