---
title: "A workspace to design the functions to summarise exon or junction"
author: "Angel Liang"
date: "11/01/2020"
output: html_document
---

# Set the running environment

## Packages

```{r}

library(tidyverse)
library(purrr)
library(data.table)
library(dplyr)
library(rtracklayer)
library(biomaRt)

```

## Global directories

```{r}

reconstructed_gtf_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/analysis_strawberry/results_assemblyonly/"

output_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_database_generation/"

```

## Global functions

```{r}

ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 99)

```


# Pooling AS junction co-ordinates from JUM

accepts:
1. table of differential junctions (result from JUM), must contain AS_event_ID and splicemode columns
2. all the detailed tables used in analysis, as is (untouched)
3. UNION_junc_coor file from JUM, which contains all the junction ID to genome co-ordinate mapping.

## Directories

```{r}

JUM_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/"

differential_junction_table_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/figures/som_consensus_matrix_combinedexpr_572_isoforms_OBseries_any_qvalue0.01_dPSI_greaterthan_0.2_sweep_from_3x4_to_7x11_plausibleASlength.txt"

UNION_junc_coor_path <- "Y:/PGNEXUS_OBseries/analysis_JUM/run_1_PGNEXUS_OBseries_pvalue1/results/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

```

## Import the detailed tables into the environment

```{r message=FALSE, warning=FALSE}

list_of_timepoint_comparisons_final <- read.delim(paste(JUM_results_dir, "list_of_timepoint_comparisons_final.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree %>% flatten

list_of_AS_events <- c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention", "MXE_events") %>% array_tree %>% flatten

# read tables into environment

list_of_detailed_tables <- purrr::map(.x = list_of_timepoint_comparisons_final, .f = ~purrr::map2(.x = .x, .y = list_of_AS_events, .f = ~read_delim(file = paste(JUM_results_dir, "final_JUM_output_", .x, "/", list.files(path = paste(JUM_results_dir, "final_JUM_output_", .x, "/", sep = ""), pattern = paste("(.)", .y, "(.*)detailed.txt", sep = "")), sep = ""), delim = "\t") %>% add_column(., "splicemode" = .y)) %>% set_names(list_of_AS_events)) %>% set_names(list_of_timepoint_comparisons_final)

# bind rows for each comparison

list_of_detailed_tables_2 <- list_of_detailed_tables %>% purrr::map(.x = ., .f = ~rbindlist(.x))

# rename the colnames to be not comparison-specific - we will add a comparison column later on

list_of_detailed_tables_3 <- purrr::map2(.x = list_of_detailed_tables_2, .y = list_of_timepoint_comparisons_final, .f = ~setNames(., c("Gene", "AS_event_ID", "AS_structure_ID", "sub_junction_ID", "sub-junction_dispersion_estimate", "LRT_statistic-full_vs_reduced", "LRT_p_value-full_vs_reduced", "BH_adjusted_p-values", "logCPM_1", "logCPM_2", "fitting_parameter_log2fold_change_2_from_1", "sub_junction_chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand", "raw_count.1", "raw_count.2", "raw_count.3", "raw_count.4", "raw_count.5", "raw_count.6", "percentage_usage.1", "percentage_usage.2", "percentage_usage.3", "percentage_usage.4", "percentage_usage.5", "percentage_usage.6", "deltaPSI", "splicemode")) %>% add_column(., "comparison" = .y)) 

wide_table_of_all_detailed_tables <- list_of_detailed_tables_3 %>% rbindlist %>% as_tibble
# 
# wide_table_of_all_detailed_tables_maxCPM <- wide_table_of_all_detailed_tables %>% dplyr::group_by(Gene) %>% dplyr::summarise(., maxCPM = max(logCPM_1 %>% na.omit, logCPM_2 %>% na.omit))
# 
# wide_table_of_all_detailed_tables_maxtranscriptlength <- getBM(filters = "external_gene_name", values = wide_table_of_all_detailed_tables_maxCPM$Gene, attributes = c("external_gene_name", "transcript_length"), mart = ensembl_mart) %>% group_by(external_gene_name) %>% na.omit %>% filter(transcript_length == max(transcript_length	)) %>% 
#   setNames(c("Gene", "maxtranscriptlength"))
# 
# wide_table_of_all_detailed_tables_maxCPM_maxtranscriptlength <- dplyr::full_join(wide_table_of_all_detailed_tables_maxCPM, 
#                                                                            wide_table_of_all_detailed_tables_maxtranscriptlength, 
#                                                                            by = "Gene")

```

### Import table of differential junctions

```{r}

differential_junction_table <- read_delim(paste(differential_junction_table_path), delim = "\t")

```

### Filter the detailed tables and extract junction IDs

```{r}

wide_table_of_all_detailed_tables_diffonly <- dplyr::semi_join(wide_table_of_all_detailed_tables, differential_junction_table, by = c("AS_event_ID", "splicemode"))

AS_junction.IDs <- tibble("junction_ID" = wide_table_of_all_detailed_tables_diffonly$AS_structure_ID %>% gsub(x = ., pattern = "(5|3)_(.*)", replacement = "\\2"))

AS_junction_IDs_split <- AS_junction.IDs$junction_ID %>% gsub(x = ., pattern = "Junction_", replacement = "") %>% strsplit(., split = "_")

AS_junction_IDs_split_2 <- tibble("junction_ID" = paste("Junction_", AS_junction_IDs_split %>% unlist, sep = "")) %>% unique

print(paste("there are", nrow(AS_junction_IDs_split_2), "unique junctions which have been plausibly differentially spliced"))

```

### import the UNION junc coordinate table and filter it for differential junctions we have just found

```{r}

UNION_junc_coor_table <- read_delim(paste(UNION_junc_coor_path), delim = "\t", col_names = c("chr", "start", "end", "strand", "junction_ID"))

UNION_junc_coor_table_2 <- UNION_junc_coor_table

UNION_junc_coor_table_2[, "strand"] <- gsub(x = UNION_junc_coor_table_2[, "strand"] %>% as.data.frame %>% unlist, pattern = "0", replacement = ".")

write.table(UNION_junc_coor_table_2, file = paste(output_dir, "UNION_junc_coor_differential.txt", sep = ""), col.names = TRUE, row.names = FALSE, quote = FALSE)

```

# Combining replicates of reconstructed GTF files - NO. WE SHOULD USE CUFFMERGE

Take the union of all the unique GTF entries across all replicates of a timepoint

## Directories

```{r eval=FALSE, include=FALSE}

vector_timepointnames_path <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/timepointname_list.txt"

```

## Read all the GTF files into a list

each level 1 element belongs to one timepoint.

```{r eval=FALSE, include=FALSE}

vector_timepointnames <- read.delim(vector_timepointnames_path, sep = "\t", header = FALSE, stringsAsFactors = FALSE)

list_timepointnames <- vector_timepointnames %>% array_tree %>% flatten

list_reconstructed_gtf_paths <- purrr::map(.x = list_timepointnames, .f = ~paste(reconstructed_gtf_dir, 
                                                                                 list.files(path = reconstructed_gtf_dir) %>% .[grep(x = ., pattern = .x)], sep = "") %>% 
                                             array_tree %>% flatten)

list_reconstructed_gtf_tibbles <- purrr::map_depth(.x = list_reconstructed_gtf_paths, .depth = 2, .f = ~rtracklayer::import(paste(.x)) %>% as_tibble)



vector_timepointnames <- list.files(path = reconstructed_gtf_dir) %>% gsub(x = ., pattern = "(.*)_(r[1-3])(.*)", replacement = "\\1") %>% unique

gtf_table <- rtracklayer::import(paste(reconstructed_gtf_dir)) %>% as_tibble

```


# 3-frame translation of junction-flanking nucleotides

Translate as much as we can within a specified window. 

1. for JUM, do not translate if there are strictly 

```{r}

```

