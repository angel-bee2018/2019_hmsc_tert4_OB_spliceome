---
title: "Processing MaxQuant output for proteomic validation of PGNEXUS OB RNA-Seq data"
author: "Angel Liang"
date: "22/02/2020"
output: html_document
---


# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
# library(gtools)
# library(extrafont)
# loadfonts(device="win")
windowsFonts("Helvetica" = windowsFont("Helvetica"))
# library(Laurae)

library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
future::plan(multiprocess)
library(future.apply)
memory.limit(100000)

library(RColorBrewer)
library(ggplot2)
library(Amelia)

library(kohonen)
library(genefilter)

# library(gplots)
# library(lattice)
library(svglite)
# library(scales)

# # library(biomaRt)
library(systemPipeR)
# library(GOstats)
# library(PFAM.db)
# library(bc3net)
# 
library(ggdendro)
library(data.table)
library(seqinr)
library(gtools)
# library(Rfast)
library(rtracklayer)

# shared_dir <- "/media/Ubuntu/sharedfolder/"
shared_dir <- "Z:/"

R_processing_results_dir <- paste("Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/R_processing_results/", sep = "")

if(! dir.exists(R_processing_results_dir) ) {
     dir.create(R_processing_results_dir, recursive = TRUE)}

junc.exons_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_junc.exons_katana_differential/txt/"

con_sp.hsa.canonical.isoforms_junc.exons_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms_junc.exons_katana_differential/txt/"

# maxquant_junctions.3FT_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_maxquant/run_1_PGNEXUS_OBseries_allsamples_angel.junctions.3FT/txt/"

R_processing_results <- paste("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/", sep="")

if(! dir.exists(R_processing_results) ) {
     dir.create(R_processing_results, recursive = TRUE)}

`3FT_results_dir` <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/three_frame_translation_results/"

```

# define functions

## FUNCTION TO PLOT PCA FOR TIMEPOINT AND REPLICATE

```{r}

plot_PCA_for_timepoint_and_replicate <- function(matrixtable, timepoint_order = NULL, replicate_order = NULL, PCA_depths_y = NULL, PCA_depths_x = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL) {
  
  # DEBUG ###
  # save_dir <- R_processing_results_dir
  # save_name <- "raw_MQ_intensities"
  # 
  # graph_title <- paste(.y[[1]], "\n", .y[[2]], sep = "")
  # 
  # timepoint_order <- c("ud_1_24", "ud_30_6", "30m", "1h", "6h", "1d")
  # replicate_order <- vector_replicate_names
  # 
  # PCA_depths_y <- c(2, 3, 4)
  # PCA_depths_x <- c(1, 2, 3)
  ###########
  
  PCA_result <- prcomp(matrixtable)
  
  ## measure PC variance #
  PCA_stdev <- tibble("PC" = 1:(PCA_result[["sdev"]] %>% length), "stdev" = PCA_result[["sdev"]])
  
  PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
  PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)
  
  ggplot(PCA_variance) + 
    geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
    scale_fill_gradientn(colours = heat.colors(n = (PCA_result[["sdev"]] %>% length))) +
    ggtitle(paste("PCA variance distribution\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("PC") +
    ylab("Variance explained (%)") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

  ## measure PC loadings #
  ## column names of the matrix need to be split by a "|", like this: timepoint|replicatenumber
  PCA_loadings <- PCA_result[["rotation"]] %>% as_tibble(rownames = "sample")
  PCA_loadings <- add_column(PCA_loadings, "timepoint" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1") %>% factor(x = ., levels = timepoint_order))
  PCA_loadings <- add_column(PCA_loadings, "replicatenumber" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2") %>% factor(x = ., levels = replicate_order))
  
  # plot PCA for multiple depths all in one go.
  purrr::map2(.y = PCA_depths_y, .x = PCA_depths_x, .f = function(.y, .x) {
    
    pc_y <- .y
    pc_x <- .x
    
    ggplot(PCA_loadings) + 
    geom_point(aes(y = !!(paste("PC", pc_y, sep = "") %>% as.name), x = !!(paste("PC", pc_x, sep = "") %>% as.name), shape = replicatenumber, color = timepoint, size = 2)) +
    scale_fill_gradientn(name = "Timepoint", colours = rainbow(n = (PCA_loadings %>% nrow))) +
    scale_shape_discrete(name = "Replicate") +
    ggtitle(paste("PCA loadings\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab(paste("PC", pc_x, " (", PCA_variance[pc_x, "variance_explained"] %>% signif(3), "%)", sep = "")) +
    ylab(paste("PC", pc_y, " (", PCA_variance[pc_y, "variance_explained"] %>% signif(3), "%)", sep = "")) +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 25, units = "cm")
    
    } )
  
}

```

## multiple test correction

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

```

## FUNCTION TO CHANGE THE NAME OF ONE COLUMN WITH EXACT MATCH

```{r}

rename_column_exact <- function(input_tibble, target_column, output_colname) {
  
  output_tibble <- input_tibble
  
  colnames(output_tibble)[which(colnames(output_tibble) == target_column)] <- output_colname
  
  return(output_tibble)
  
}

```

## function to split a whole table by a delimiter in a column

```{r}

split_delimited_column_in_table <- function(input_table, target_colname, split, columns_to_deduplicate = NULL) {
  
  # DEBUG ###
  # input_table <- tibble_phosphosites_with_protein_group_ids
  # target_colname <- "Protein.group.IDs"
  # split = "\\;"
  # columns_to_deduplicate <- c("id", "1h_vs_ud|IB")
  ###########
  
  # list-ify the target column
  list_target_column_strsplit_per_element <- input_table[, target_colname] %>% unlist %>% strsplit(., split = split)
  
  # map length
  vector_split_lengths <- list_target_column_strsplit_per_element %>% purrr::map(~length(.x)) %>% unlist(use.names = FALSE)
  
  # repeat table according to the split lengths
  row_indices_of_table_repeated_by_split <- rep(x = 1:nrow(input_table), times = vector_split_lengths)
  
  input_table_repeated_by_split <- input_table[row_indices_of_table_repeated_by_split, ]
  
  # replace target column with split values
  input_table_repeated_by_split[, target_colname] <- list_target_column_strsplit_per_element %>% unlist(use.names = FALSE)
  
  split_table <- input_table_repeated_by_split
  
  # if specified, append an index to a particular column
  if (is.null(columns_to_deduplicate) == FALSE) {
    
    # get the duplicated row indices where split lengths > 1
    indices_of_duplicates <- which(vector_split_lengths > 1)
    
    # get the repetition number where split lengths > 1
    repetition_numbers_of_duplicates <- vector_split_lengths[which(vector_split_lengths > 1)]
    
    # list-ify the columns to be appended
    list_deduplicated_columns <- input_table[, columns_to_deduplicate] %>% array_tree(margin = 2) %>% purrr::map(~array_tree(.x))
    
    # map over each column, split the target element and add _[0-9]+
    list_deduplicated_columns_split <- purrr::map(.x = list_deduplicated_columns, .f = function(a1) {
      
      # map a subset each of the L2 (elements of a column)
      a1[indices_of_duplicates] <- purrr::map2(.x = a1[indices_of_duplicates], .y = repetition_numbers_of_duplicates, 
                  .f = ~rep(.x, times = .y) %>% unlist %>% paste(., 1:.y, sep = "_"))
      
      return(a1 %>% unlist)
      
    } )
    
    # tibblise
    tibble_deduplicated_columns_split <- list_deduplicated_columns_split %>% as_tibble
    
    # add back every row onto the split table
    for (dedupe_colname in columns_to_deduplicate) {
      
      split_table[, dedupe_colname] <- tibble_deduplicated_columns_split[, dedupe_colname]
      
    }
    
  }
  
  return(split_table %>% type_convert)
  
}

```

## FUNCTION TO TAKE THE AVERAGE OF ROWS OF A DATAFRAME ACCORDING TO A FACTOR WITH INFORMATION ABOUT THE COLUMN DESIGN

```{r}

average_replicates_by_column <- function(table, design_factor, min_replicates) {

  # DEBUG ###
  # table <- raw_tibble %>% dplyr::select(-id)
  # design_factor <- factor(x = gsub(x = colnames(raw_tibble %>% dplyr::select(-id)), pattern = "^([^\\|]+).*", replacement = "\\1", perl = TRUE), levels = c("30m_vs_ud", "1h_vs_ud", "6h_vs_ud", "1d_vs_ud"))
  # min_replicates <- 1
  ###########
  
  # subset and take average
  # establish looping behaviour thru the levels
  purrr::map(.x = levels(design_factor), .f = function(.x) {
    
    # DEBUG ###
    # .x <- levels(design_factor) %>% .[[2]]
    ###########
    
    table_subset <- table[, which(design_factor == .x)]
    
    # add mean and replicate numbers columns
    table_column_averages <- table_subset %>% add_column("mean" = rowMeans(., na.rm = TRUE), 
                                                         "replicates" = pmap(.l = list("x" = .[, 1] %>% unlist, "y" = .[, 2] %>% unlist, "z" = .[, 3] %>% unlist), .f = function(x, y, z) {length(c(x, y, z) %>% na.omit)}) %>% unlist)
    
    # delete the mean if the number of replicates is less than 2
    table_column_averages[which(table_column_averages$replicates < min_replicates), "mean"] <- NA
    
    # only keep the mean column
    tibble_mean <- table_column_averages[, "mean"]
    
    # rename column names
    colnames(tibble_mean) <- paste(colnames(tibble_mean), "|", .x, sep = "")
    
    return(tibble_mean)
    
  } ) %>%
    # join all mean columns and we're done
    purrr::reduce(dplyr::bind_cols) %>%
    
    return
    
}

```

# read the tables into environment

```{r}

list_maxquant_run_dirs <- list("junc.exons" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_junc.exons/txt/",
                               "sp.hsa.canonical.isoforms_junc.exons" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_sp.hsa.canonical.isoforms_junc.exons/txt/"
                               # ,
                               # "con_sp.hsa.canonical.isoforms_junc.exons" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms_junc.exons/txt/",
                               # "con_sp.hsa.canonical.isoforms_trembl" = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/2020_phosphoproteome_OBseries_con_sp.hsa.canonical.isoforms_trembl/txt/"
                               )
                               
list_output.table_categories <- list("evidence" = "evidence.txt", 
                                     "modification_specific_peptides" = "modificationSpecificPeptides.txt", 
                                     "msms" = "msms.txt", 
                                     "peptides" = "peptides.txt", 
                                     "protein_groups" = "proteinGroups.txt",
                                     "phosphosites" = "Phospho (STY)Sites.txt")

# create combinations of files and runs
list_for_maxquant_table_import <- purrr::map(.x = list_maxquant_run_dirs, .f = ~purrr::cross2(.x, list_output.table_categories))
# also create corresponding combinations of names to annotate with
list_of_nested_table_names <- purrr::map(.x = names(list_maxquant_run_dirs), .f = ~purrr::cross2(.x, names(list_output.table_categories)) %>% set_names(names(list_output.table_categories))) %>% set_names(names(list_maxquant_run_dirs))

# read the tables into the environment
list_imported_maxquant_tibbles <- purrr::map(.x = list_for_maxquant_table_import, .f = ~future_map(.x = .x, .f = ~read.delim(paste(.x[[1]], .x[[2]], sep = ""), stringsAsFactors = FALSE, row.names = NULL, sep = "\t") %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble"))))
# , .options = future_options(globals = c("as_tibble"))

# rename the lists at L2
list_imported_maxquant_tibbles <- list_imported_maxquant_tibbles %>% purrr::map(.f = ~set_names(.x, names(list_output.table_categories)))

```

# global processing of tables

## shuffle tables

```{r}

# remove all peptides which have no MS/MS count from the evidence tables
list_imported_maxquant_tibbles_processed_temp <- list_imported_maxquant_tibbles %>% purrr::map(
  .f = ~purrr::modify_at(.x = .x, .at = "evidence", 
                         .f = ~dplyr::filter(.x, MS.MS.count != 0) %>% dplyr::arrange(., PEP)))

# remove all the columns with unnecessary ratio info
list_imported_maxquant_tibbles_processed <- list_imported_maxquant_tibbles_processed_temp %>% 
  
  purrr::map(~modify_at(.x = .x, .at = c("evidence", "peptides", "protein_groups", "phosphosites"), .f = function(.x) {
  
  # .x <- list_imported_maxquant_tibbles_processed_temp[[1]][[1]]
  
  # remove H/M
  filtered_table <- .x[, -grep(x = colnames(.x), pattern = "H.M")]
  
  filtered_table2 <- filtered_table[, -setdiff(grep(x = colnames(filtered_table), pattern = "Ratio"), grep(x = colnames(filtered_table), pattern = "KR_|IB_|IB2_"))]
  
  # filtered_table3 <- filtered_table2 %>% dplyr::select(-grep(x = colnames(filtered_table2), pattern = "Ratio.(H.L|M.L).(KR_|IB_|IB2_)"))
  
  return(filtered_table2)
  
} ) ) %>% 
  
  purrr::map(~modify_at(.x = .x, .at = "phosphosites", .f = function(.x) {
  
  # remove occupancy column
  filtered_table4 <- .x[, -grep(x = colnames(.x), pattern = "Occupancy")] %>% 
    # filter for class I (> 0.75) sites only
    dplyr::filter(Localization.prob >= 0.75)
  
  return(filtered_table4)
  
} ) )

```

# Data triaging

## plot the PEP and score distributions of CON, SP and 3FT identified peptides

### rearrange the peptides.txt tables for ggplot

```{r}

list_imported_maxquant_tibbles_peptides_only <- purrr::map(.x = list_imported_maxquant_tibbles, .f = ~.x$`peptides`)

# function to create peptide class column
peptide_class_column <- function(peptides_tibble) {
  
  col <- rep(NA, times = nrow(peptides_tibble))
  
  # record the columns of contaminants, reverse sequences, swissprot matches, junction and exon matches.
  cons <- grep(x = peptides_tibble$Leading.razor.protein, pattern = "(^CON_|;CON_)", ignore.case = FALSE)
  revs <- which(peptides_tibble$Reverse == "+")
  sps <- grep(x = peptides_tibble$Leading.razor.protein, pattern = "(^[A-Z][0-9].*|;[A-Z][0-9].*)", ignore.case = FALSE)
  junctions <- grep(x = peptides_tibble$Leading.razor.protein, pattern = "junction_.*", ignore.case = FALSE)
  exons <- grep(x = peptides_tibble$Leading.razor.protein, pattern = "exon_.*", ignore.case = FALSE)
  
  col[cons] <- "contaminants"
  col[sps] <- "swissprot_hits"
  col[junctions] <- "junction_3FT_hits"
  col[exons] <- "exon_3FT_hits"
  col[revs] <- "reversed_sequences"
  
  return(col)
  
}

list_peptides_tibbles <- purrr::map2(.x = list_imported_maxquant_tibbles_peptides_only, 
                                 .y = names(list_imported_maxquant_tibbles_peptides_only), 
                                 .f = ~add_column(.x, "dbrun" = .y, "peptide_class" = peptide_class_column(.x)))

# melt into long tables for ggplot faceting by peptide class and database run
long_tibble_evidence_tibbles_facet.peptideclass.dbrun <- list_peptides_tibbles %>% rbindlist(fill = TRUE) %>% as_tibble

```

### ggplot of number of hits in each category

```{r}

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = peptide_class, fill = PEP <= 0.01)) +
  geom_bar() +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Bar plot of number of hits in each peptide category", sep = "")) +
  xlab("Peptide category") +
  scale_x_discrete(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence")) + 
  ylab(expression(Number~of~total~hits)) +
  scale_fill_manual(limits = c("TRUE", "FALSE"), labels = c("PEP < 0.01", "PEP > 0.01"), values = c("blue2", "grey75"), name = "Hit significance") +
  theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_number.of.hits_per_peptide.class", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_number.of.hits_per_peptide.class", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = peptide_class, fill = PEP <= 0.01)) +
  geom_bar(aes(y = log10(..count..))) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Bar plot of number of hits in each peptide category", sep = "")) +
  xlab("Peptide category") +
  scale_x_discrete(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence")) + 
  ylab(expression(Number~of~total~hits~(log[10]))) +
  # scale_y_continuous(trans = "log10") +
  scale_fill_manual(limits = c("TRUE", "FALSE"), labels = c("PEP < 0.01", "PEP > 0.01"), values = c("blue2", "grey75"), name = "Hit significance") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_number.of.hits_per_peptide.class_log10", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_number.of.hits_per_peptide.class_log10", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### ggplot of PEP distributions below 0.05

```{r}

# line - absolute counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, color = peptide_class)) +
  geom_density(aes(y = ..count..)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.02~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.015), breaks = c(-0.005, seq(0, 0.015, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.absolute", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.absolute", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# line - normalised counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, color = peptide_class)) +
  geom_density(aes(y = ..density..)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.02~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.015), breaks = c(-0.005, seq(0, 0.015, 0.005))) +
  ylab("Frequency density (smoothed)") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.normalised", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_line.normalised", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# bar
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = PEP, fill = peptide_class)) +
  geom_histogram(binwidth = 0.0005, aes(y = ..count..)) +
  facet_wrap(~dbrun + peptide_class, scales = "free") +
  ggtitle(expression(Comparison~of~peptide~p-value~(PEP)~distributions~(PEP <= 0.02~only))) +
  xlab(expression(PEP)) +
  # xlim(c(0, 1)) +
  scale_x_continuous(limits = c(-0.001, 0.015), breaks = c(-0.001, seq(0, 0.015, 0.005))) +
  ylab("Frequency (smoothed)") +
  scale_fill_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") + 
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.PEP.less.than.0.05_distribution_per_peptide.class_bar", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### ggplot of score distributions

```{r}

# absolute counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = Score + 1, colour = peptide_class)) +
  geom_density(aes(y = ..count.. + 1)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Comparison of peptide score distributions", sep = "")) +
  xlab(expression(Score[MaxQuant] + 1)) +
  scale_x_continuous(trans = "log10", breaks = c(1, seq(50, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score %>% na.omit), 50))) +
  ylab("Frequency (absolute)") +
  # scale_y_continuous(trans = "log10") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.score_distribution_per_peptide.class_absolute.counts", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.score_distribution_per_peptide.class_absolute.counts", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# normalised counts
ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun, aes(x = Score + 1, colour = peptide_class)) +
  geom_density(aes(y = ..density.. + 1)) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(paste("Comparison of peptide score distributions", sep = "")) +
  xlab(expression(Score[MaxQuant] + 1)) +
  scale_x_continuous(trans = "log10", breaks = c(1, seq(50, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score %>% na.omit), 50))) +
  ylab("Frequency (normalised)") +
  # scale_y_continuous(trans = "log10") +
  scale_color_manual(limits = c("swissprot_hits", "exon_3FT_hits", "junction_3FT_hits", "contaminants", "reversed_sequences"), labels = c("Swissprot hits", "Exons from 3FT", "Junctions from 3FT", "Contaminant", "Reversed sequence"), values = c("red", "salmon", "purple4", "grey75", "lawngreen"), name = "Peptide Hit Type") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.score_distribution_per_peptide.class_normalised.counts", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_peptide.score_distribution_per_peptide.class_normalised.counts", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

### plot of score vs. PEP

```{r}

ggplot(long_tibble_evidence_tibbles_facet.peptideclass.dbrun %>% dplyr::distinct(., PEP, Score, .keep_all = TRUE) %>% dplyr::filter(., PEP <= 0.15), aes(x = log10(PEP + 1), y = Score + 1, colour = peptide_class)) +
  geom_point() +
  geom_smooth(formula = y ~ x) +
  # show where PEP = 0.01 is
  geom_vline(xintercept = 0.00432137378, colour = "red", linetype = 2) +
  facet_wrap(~dbrun, scales = "free") +
  ggtitle(expression(Correlation~plot~of~peptide~score~vs.~PEP~(PEP <= 0.05~only))) +
  xlab(expression(log[10](PEP[MaxQuant] + 1))) +
  ylab(expression(Score[MaxQuant])) +
  scale_y_continuous(trans = "log10", breaks = c(1, seq(30, max(long_tibble_evidence_tibbles_facet.peptideclass.dbrun$Score %>% na.omit + 1), 30))) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results, "qualityplot_correlation_score_vs_PEP", ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(R_processing_results, "qualityplot_correlation_score_vs_PEP", ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

```

## evaluate the local FDR of 3FT peptides only

```{r}

# get the evidence.txt only
list_imported_maxquant_tibbles_processed_evidence_only <- purrr::map(.x = list_imported_maxquant_tibbles_processed, .f = ~.x$`evidence`)

# calculate the peptide FDR based on the evidence.txt information
list_local_FDR <- purrr::map(.x = list_imported_maxquant_tibbles_processed_peptides_only, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_imported_maxquant_tibbles_processed[vector_evidence.txt_list.indices][[1]]
  ###########
  
  number_of_reverse_hits_exons <- grep(x = .x$Leading.razor.protein, pattern = "(REV__exon)") %>% length
  number_of_reverse_hits_junctions <- grep(x = .x$Leading.razor.protein, pattern = "(REV__junction)") %>% length
  
  number_of_total_hits_exons <- grep(x = .x$Leading.razor.protein, pattern = "(exon_)") %>% length
  number_of_total_hits_junctions <- grep(x = .x$Leading.razor.protein, pattern = "(junction_)") %>% length
  
  FDR_exons <- number_of_reverse_hits_exons/number_of_total_hits_exons
  FDR_junctions <- number_of_reverse_hits_junctions/number_of_total_hits_junctions
  
  return(list(
    "Local FDR info (exons)" = list(
      
      "FDR_exons" = FDR_exons,
      "number_of_reverse_hits_exons" = number_of_reverse_hits_exons,
      "number_of_total_hits_exons" = number_of_total_hits_exons
      
    ),
    "Local FDR info (junctions)" = list(
      
      "FDR_junctions" = FDR_junctions,
      "number_of_reverse_hits_junctions" = number_of_reverse_hits_junctions,
      "number_of_total_hits_junctions" = number_of_total_hits_junctions
      
    )
    
  ))
  
} )

str(list_local_FDR)

```

# Evaluation of junction-spanning and visualisation of spliced peptides

## Retrieve the parent peptide start and end positions of the matched peptides

```{r}

# import the 3FT info table
tibble_junctions_3FT_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB_fastqc/proteome_validation/results_database_generation/angel_3FT_junctions/angel_junctions_3FT_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.2_3FT.summary.info.txt", sep = "\t", stringsAsFactors =  FALSE, row.names = NULL) %>% as_tibble

```

```{r}

# subset the identified peptides from msms.txt
# PEP < 0.01, score is not 0
tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt <- list_imported_maxquant_tibbles[[2]][grep(pattern = "Junction", x = list_imported_maxquant_tibbles[[2]]$Proteins), ] %>% .[.$PEP <= 0.01 & .$Score != 0, ]

# create a strsplit list based on the "Proteins" column
list_proteins_column_split <- strsplit(tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt$Proteins, split = ";")
# create a list of the number of times to repeat each row after the split is applied
list_row_repetitions <- list_proteins_column_split %>% purrr::map(~length(.x))
# turn the list into a vector of row indices to apply the "subsetting" operation on
vector_row_repetitions_for_subsetting <- purrr::map2(.x = 1:nrow(tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt), .y = list_row_repetitions, .f = ~rep(.x, times = .y %>% paste)) %>% unlist
# create the split table - it only has the replicated rows so far
tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split <- tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt[vector_row_repetitions_for_subsetting, ]
# fill in the Proteins column with the split. this is the final split.
tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split[, "Proteins"] <- list_proteins_column_split %>% unlist
# now clean up other proteins which were grouped together with the junctions
# we use grep to get the row indices which contain Junction "protein"
# this is final.
tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split <- tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split[grep(x = tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split$Proteins, pattern = "Junction"), ]

```

```{r}

# we should now get the unique peptide sequence/junction ID combination. we take the highest score if peptide matches are redundant.
tibble_PGNEXUS_MSMS_junction_peptides_unique <- tibble_subset_PGNEXUS_MSMS_peptides_from_proteingroups.txt_split[, c("Sequence", "Proteins", "Score")] %>% dplyr::arrange(., Score) %>% dplyr::distinct(., Sequence, Proteins, .keep_all = TRUE) %>% setNames(c("PGNEXUS_MSMS_sequence", "junction_ID", "MaxQuant_Score"))
# we can now match up each peptide to its corresponding junction and use str_locate_all to retrieve the positions within the peptide
# dplyr::left_join() automatically joins each MSMS identified peptide with every valid translation frame of its junction
tibble_PGNEXUS_MSMS_junction_peptides_with_3FT_info <- dplyr::left_join(tibble_PGNEXUS_MSMS_junction_peptides_unique, tibble_junctions_3FT_info, by = "junction_ID")
# loop thru each MSMS identified sequence, match it up with the virtual peptide sequence in the database and add MSMS.sequence.start and MSMS.sequence.end If there is no match, we introduce NA.
tibble_PGNEXUS_MSMS_junction_peptides_with_start_end <- cbind(tibble_PGNEXUS_MSMS_junction_peptides_with_3FT_info, purrr::map2(.x = tibble_PGNEXUS_MSMS_junction_peptides_with_3FT_info$PGNEXUS_MSMS_sequence, .y = tibble_PGNEXUS_MSMS_junction_peptides_with_3FT_info$virtual_peptide_sequence, .f = ~stringr::str_locate_all(string = .y %>% paste, pattern = .x %>% paste)[[1]] %>% as_tibble %>% .[1, ]) %>% rbindlist %>% setNames(c("MSMS.sequence_database.virtual.peptide_start", "MSMS.sequence_database.virtual.peptide_end")))
# remove na
tibble_PGNEXUS_MSMS_junction_peptides_with_start_end <- tibble_PGNEXUS_MSMS_junction_peptides_with_start_end[-which(is.na(tibble_PGNEXUS_MSMS_junction_peptides_with_start_end$MSMS.sequence_database.virtual.peptide_start)), ]
# O.K it didn't turn out to be useful. but keep the matches with the final trimmed virtual peptides because we might need them later. consider this a roundabout way to do filtering of the database info tibble.

# function to turn + into F, - into R.
turnplusintoF_turnminusintoR <- function(strand){
  if (strand == "+") {
    "F"
  } else if (strand == "-") {
      "R"
  }
  
}

# what we need to do is to re-translate the entire window based on the translation frame, strand and forward nucleotide sequences already there.
# add column of peptide sequences of the whole window
tibble_PGNEXUS_MSMS_junction_peptides_with_start_end <- tibble_PGNEXUS_MSMS_junction_peptides_with_start_end %>% add_column("full_window_peptide_sequence" = purrr::map(.x = tibble_PGNEXUS_MSMS_junction_peptides_with_start_end[, c("forward_nucleotides_from_coords", "strand", "translation_frame")] %>% array_tree, .f = ~seqinr::translate(seq = .x[["forward_nucleotides_from_coords"]] %>% unlist %>% strsplit(., split = ",") %>% unlist, frame = .x[["translation_frame"]] %>% unlist %>% paste %>% as.numeric, sens = turnplusintoF_turnminusintoR(.x[["strand"]] %>% unlist %>% paste)) %>% paste(collapse = "")) %>% unlist)
# redo the matching of the MSMS identified peptides this time to the full peptide sequence of the window for real
## loop thru each MSMS identified sequence, match it up with the virtual peptide sequence in the database and add MSMS.sequence.start and MSMS.sequence.end If there is no match, we introduce NA.
tibble_PGNEXUS_MSMS_junction_peptides_with_start_end <- cbind(tibble_PGNEXUS_MSMS_junction_peptides_with_start_end, purrr::map2(.x = tibble_PGNEXUS_MSMS_junction_peptides_with_start_end$PGNEXUS_MSMS_sequence, .y = tibble_PGNEXUS_MSMS_junction_peptides_with_start_end$full_window_peptide_sequence, .f = ~stringr::str_locate_all(string = .y %>% paste, pattern = .x %>% paste)[[1]] %>% as_tibble %>% .[1, ]) %>% rbindlist %>% setNames(c("MSMS.sequence_full.window.peptide_start", "MSMS.sequence_full.window.peptide_end")))

# append information on whether the MS/MS identified peptide crosses the splice junction or not.
tibble_PGNEXUS_MSMS_junction_peptides_with_SJ_crossing_info <- tibble_PGNEXUS_MSMS_junction_peptides_with_start_end %>% add_column("MSMS_peptide_crosses_SJ" = purrr::map2(.x = tibble_PGNEXUS_MSMS_junction_peptides_with_start_end$MSMS.sequence_full.window.peptide_start, .y = tibble_PGNEXUS_MSMS_junction_peptides_with_start_end$MSMS.sequence_full.window.peptide_end, .f = ~((.x <= 16) & (.y >= 17))) %>% unlist) %>% as_tibble

# count of shame
cat("We have identified", which(tibble_PGNEXUS_MSMS_junction_peptides_with_SJ_crossing_info$MSMS_peptide_crosses_SJ == TRUE) %>% length, "peptides which span a splice junction.\n")

# write the processed table.
write.table(tibble_PGNEXUS_MSMS_junction_peptides_with_SJ_crossing_info, file = paste(R_processing_results, "PGNEXUS_MSMS_identified_JUM_q0.01_dpsi0.2_junc.peptides_with_SJ.info.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

```

## Preprocessing for visualisation in IGV

Step 1: Import the details of 3FT - junctions and exons
Step 2: Calculate the genome-relative positions of the identified tryptic peptides
Step 3: Write a BLOCKED bed file (BED12 format)
Step 4 (outside R): BEDtoBAM

### Import the details of 3FT - junctions and exons

```{r}

tibble_detailed_3FT_summary_JUM_diff <- read.delim(file = paste(`3FT_results_dir`, "threeframetranslate_junctions_qvalue0.01_dpsi0.15_diff_3FT.summary.info.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

tibble_detailed_3FT_summary_PSIsigma_diff <- read.delim(file = paste(`3FT_results_dir`, "threeframetranslate_exons_pvalue0.01_dpsi10_diff_3FT.summary.info.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

```

### calculate genome-relative ranges of all the nucleotides encoding the identified tryptic peptides
#### return a bedfile-like format

```{r}

# NOTE: this return nothing
purrr::map2(
  .x = list_imported_maxquant_tibbles_processed["junc.exons"], 
  .y =  names(list_imported_maxquant_tibbles_processed["junc.exons"]), 
  .f = function(.x, .y) {
    
    # DEBUG ###
    .x <- list_imported_maxquant_tibbles_processed[["junc.exons"]]
    .y <- names(list_imported_maxquant_tibbles_processed["junc.exons"])
    ###########
    
    a1 <- .x
    a2 <- .y
    
    cat("now processing", a2, "at level 1\n")
    
    L2_list <- purrr::map2(
      .x = a1[c("peptides")], 
      names(a1[c("peptides")]), 
      .f = function(.x, .y) {
        
        # DEBUG ###
        b1 <- list_imported_maxquant_tibbles_processed[["junc.exons"]][["peptides"]] %>% dplyr::filter(PEP <= 0.01 & Score >= 30) %>% .[-grep(x = .$Leading.razor.protein, pattern = "REV"), ]
        b2 <- names(list_imported_maxquant_tibbles_processed[["junc.exons"]]["peptides"])
        ###########
        
        b1 <- .x %>% dplyr::filter(PEP <= 0.01 & Score >= 30) %>% .[-grep(x = .$Leading.razor.protein, pattern = "REV"), ]
        b2 <- .y
        
        cat("now processing", b2, "at level 2\n") 
        
        # split table by exons or junctions
        tibble_junction_peptides_only <- b1[grep(x = b1$Leading.razor.protein, pattern = "junction_"), ]
        tibble_exon_peptides_only <- b1[grep(x = b1$Leading.razor.protein, pattern = "exon_"), ]
        
        # to get the genome-relative coords of tryptic peptides, loop thru every tryptic peptide + fasta identifier combination
        # extract the MQ outputted start/end positions: 
        # 1. They are the valid-ORF-relative coords, 
        # 2. then parent translated transcript-relative coords then,
        # 3. use the translation frame and 3x length to get the nucleotide positions.
        # 4. convert individual nt positions to genomic ranges
        
        # match junctions #####
        ## retrieve the row index of the detailed 3FT table
        ## match FASTA header and sequence
        ## take the first match is fine.
        list_bedfile_junctions_only <- future_imap(.x = tibble_junction_peptides_only %>% array_tree, .f = function(a1, a2) {
          
          # DEBUG ###
          # a1 <- tibble_junction_peptides_only[5, ]
          ###########
          
          cat("\nnow processing:", a2, "/", length(tibble_junction_peptides_only %>% array_tree))
          
          row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_JUM_diff$fasta_header, pattern = a1$Leading.razor.protein %>% paste %>% trimws) %>% which,
                                                      str_detect(string = tibble_detailed_3FT_summary_JUM_diff$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
          
          tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_JUM_diff[row_index_of_matched_3FT_table, ]
          
          # get translated transcript-relative AA coords
          translated_transcript_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
          translated_transcript_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
          
          # get transcript relative nt coords
          ## NOTE: this is strand-dependent.
          parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
          parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
          
          # get genome-relative positions for every nt encoding the tryptic peptide
          ## have to take the strand into account.
          ### extract the genome-relative forward coords of every nt in the parent transcript
          ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
          vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
          ### use the transcript-relative nt coords to match
          ### then sort in increasing order for the next step
          if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "+") {
            
            all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
            
          } else if (tibble_matched_3FT_entry$matched_junction_strand %>% trimws %>% paste == "-") {
            
            all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
            
          }
          
          # convert the individual nt positions to a set of ranges
          ## achieve this by comparing n to n + 1
          ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
          tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                                      "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
            add_column("difference" = .$n.plus.1 - .$n)
          
          ## if there are no gaps, then just take the genomic range as the start:end
          if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
            
            vec_blockCount <- 1
            vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
            vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
            
          } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
            
            vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
            vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                                 tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
            vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                               last(all_genome_relative_positions_of_tryptic_peptide))
            vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
            
          }
          
          # the block details are still vector at this point. 
          # must paste collapse in order to use in the BED file.
          tibble_block_info <- tibble(
            "chrom" = tibble_matched_3FT_entry$matched_junction_chr,
            "start" = first(all_genome_relative_positions_of_tryptic_peptide),
            "end" = last(all_genome_relative_positions_of_tryptic_peptide),
            "name" = a1$Leading.razor.protein %>% paste %>% trimws,
            "score" = a1$Score %>% as.numeric,
            "strand"= tibble_matched_3FT_entry$matched_junction_strand,
            "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
            "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
            "itemRgb" = "153,0,255",
            "blockCount" = vec_blockCount %>% paste(collapse = ","),
            "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
            "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
            "qName" = a1$Sequence %>% paste %>% trimws)
          
          # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
          return(tibble_block_info)      
          
        }, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_detailed_3FT_summary_JUM_diff", "tibble_junction_peptides_only", "first", "last")))
          
        # match exons #####
        ## retrieve the row index of the detailed 3FT table
        ## match FASTA header and sequence
        ## take the first match is fine.
        list_bedfile_exons_only <- future_imap(.x = tibble_exon_peptides_only %>% array_tree, .f = function(a1, a2) {
          
          # DEBUG ###
          # a1 <- tibble_exon_peptides_only[5, ]
          ###########
          
          cat("\nnow processing:", a2, "/", length(tibble_exon_peptides_only %>% array_tree))
          
          row_index_of_matched_3FT_table <- intersect(str_detect(string = tibble_detailed_3FT_summary_PSIsigma_diff$fasta_header, pattern = a1$Leading.razor.protein %>% paste %>% trimws) %>% which,
                                                      str_detect(string = tibble_detailed_3FT_summary_PSIsigma_diff$ORF_valid, pattern = a1$Sequence %>% paste %>% trimws) %>% which) %>% .[1]
          
          tibble_matched_3FT_entry <- tibble_detailed_3FT_summary_PSIsigma_diff[row_index_of_matched_3FT_table, ]
          
          # get translated transcript-relative AA coords
          translated_transcript_relative_AA_start <- (a1$Start.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
          translated_transcript_relative_AA_end <- (a1$End.position %>% trimws %>% as.numeric) + (tibble_matched_3FT_entry$valid_ORF_3FT_peptide_protein_relative_start %>% trimws %>% as.numeric) - 1
          
          # get transcript relative nt coords
          ## NOTE: this is strand-dependent.
          parent_transcript_relative_nt_start <- 3*(translated_transcript_relative_AA_start - 1) + 1 + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
          parent_transcript_relative_nt_end <- 3*translated_transcript_relative_AA_end + (tibble_matched_3FT_entry$translation_frame %>% trimws %>% as.numeric)
          
          # get genome-relative positions for every nt encoding the tryptic peptide
          ## have to take the strand into account.
          ### extract the genome-relative forward coords of every nt in the parent transcript
          ### we assume it's already been sorted. if it wasn't sorted in increasing order, the 3FT would have ben completely wrong.
          vec_forward_genome_coords_of_parent_transcript <- tibble_matched_3FT_entry$all_parent_transcript_coords %>% strsplit(split = ",") %>% unlist %>% as.numeric
          ### use the transcript-relative nt coords to match
          ### then sort in increasing order for the next step
          if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "+") {
            
            all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
            
          } else if (tibble_matched_3FT_entry$matched_exon_strand %>% trimws %>% paste == "-") {
            
            all_genome_relative_positions_of_tryptic_peptide <- vec_forward_genome_coords_of_parent_transcript %>% rev %>% .[parent_transcript_relative_nt_start:parent_transcript_relative_nt_end] %>% as.numeric %>% sort
            
          }
          
          # convert the individual nt positions to a set of ranges
          ## achieve this by comparing n to n + 1
          ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
          tibble_n_n.plus.1 <- tibble("n" = all_genome_relative_positions_of_tryptic_peptide %>% head(n = length(all_genome_relative_positions_of_tryptic_peptide) - 1),
                                      "n.plus.1" = all_genome_relative_positions_of_tryptic_peptide[-1]) %>% 
            add_column("difference" = .$n.plus.1 - .$n)
          
          ## if there are no gaps, then just take the genomic range as the start:end
          if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
            
            vec_blockCount <- 1
            vec_blockSizes <- length(all_genome_relative_positions_of_tryptic_peptide)
            vec_blockStarts <- first(all_genome_relative_positions_of_tryptic_peptide)
            
          } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
            
            vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
            vec_blockStarts <- c(first(all_genome_relative_positions_of_tryptic_peptide), 
                                 tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
            vec_blockEnds <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                               last(all_genome_relative_positions_of_tryptic_peptide))
            vec_blockSizes <- vec_blockEnds - vec_blockStarts + 1
            
          }
          
          # the block details are still vector at this point. 
          # must paste collapse in order to use in the BED file.
          tibble_block_info <- tibble(
            "chrom" = tibble_matched_3FT_entry$matched_exon_chr,
            "start" = first(all_genome_relative_positions_of_tryptic_peptide),
            "end" = last(all_genome_relative_positions_of_tryptic_peptide),
            "name" = a1$Leading.razor.protein %>% paste %>% trimws,
            "score" = a1$Score %>% as.numeric,
            "strand"= tibble_matched_3FT_entry$matched_exon_strand,
            "thickStart" = first(all_genome_relative_positions_of_tryptic_peptide),
            "thickEnd" = last(all_genome_relative_positions_of_tryptic_peptide),
            "itemRgb" = "153,0,0",
            "blockCount" = vec_blockCount %>% paste(collapse = ","),
            "blockSizes" = vec_blockSizes %>% paste(collapse = ","),
            "blockStarts" = (vec_blockStarts - first(all_genome_relative_positions_of_tryptic_peptide)) %>% paste(collapse = ","),
            "qName" = a1$Sequence %>% paste %>% trimws)
          
          # this represents the block info for ONE tryptic peptide identified by MQ. still have to loop thru the rest.
          return(tibble_block_info)      
          
        }, .progress = TRUE, .options = future_options(globals = c("tibble", "str_detect", "tibble_exon_peptides_only", "tibble_detailed_3FT_summary_PSIsigma_diff", "first", "last")))
        
        # rbind and tibblise
        tibble_bedfile <- splice(list_bedfile_junctions_only, list_bedfile_exons_only) %>% rbindlist %>% as_tibble %>% dplyr::select(-qName)
        
        # track line
        # cat(paste("track name=\"", output_file_name_JUM, "\" description=\"", output_file_name_JUM, "\" graphType=junctions\n", sep = ""), file = paste(R_processing_results, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""))
        # 
        # append = TRUE
        write.table(x = tibble_bedfile, file = paste(R_processing_results, "proteomic_alignment_", a2, "_", b2, ".bed", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
        
        # GO TO BEDTOOLS NOW ###
        # cd /media/Ubuntu/sharedfolder/bedtools2/bin/
        # ./bedToBam -i /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/proteomic_alignment_junc.exons_peptides.bed -bed12 -g hg38.chrom.sizes_ensembl > /media/Ubuntu/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/proteomic_alignment_junc.exons_peptides.bam
        
        # rtracklayer::export(object = tibble_bedfile, con = paste(R_processing_results, "bedfile_", a2, "_", b2, ".bed", sep = ""), format = "bedPE")
        # 
        # # add the QNAME for real this time
        # tibble_bedfile2 <- read.delim(file = paste(R_processing_results, "bedfile_", a2, "_", b2, ".bed", sep = ""), sep = "\t", col.names = colnames(tibble_bedfile)[-length(colnames(tibble_bedfile))], row.names = NULL, header = FALSE, check.names = FALSE) %>% as_tibble
        
      } )
    
  } )

```

# Gene set enrichment

### import the FASTA supplementary info

```{r}

tibble_fasta_supp_info_exons <- read.delim(file = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_exons/exon_table_OB_diff_dpsi10_anypvalue0.01_3272_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

tibble_fasta_supp_info_junctions <- read.delim(file = "Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/angel_3FT_junctions/junction_table_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble

# bind rows
tibble_fasta_supp_info <- dplyr::bind_rows(tibble_fasta_supp_info_exons, tibble_fasta_supp_info_junctions)

```

### GO enrichment for all junc.exons identified

```{r}

list_GOhyper_enrichment <- purrr::map2(.x = list_imported_maxquant_tibbles_processed["junc.exons"], 
                                       .y =  names(list_imported_maxquant_tibbles_processed["junc.exons"]), 
                                       .f = function(.x, .y) {
                                         
                                         # DEBUG ###
                                         # .x <- list_imported_maxquant_tibbles_processed %>% .[["junc.exons"]]
                                         # .y <- names(list_imported_maxquant_tibbles_processed["junc.exons"])
                                         ###########
                                         
                                         a1 <- .x
                                         a2 <- .y
                                         
                                         cat("now processing", a2, "at level 1\n")
                                         
                                         L2_list <- purrr::map2(.x = a1[c("peptides", "phosphosites", "protein_groups")], 
                                                                names(a1[c("peptides", "phosphosites", "protein_groups")]), 
                                                                .f = function(.x, .y) {
                                                                  
                                                                  # DEBUG ###
                                                                  b1 <- list_imported_maxquant_tibbles_processed[["junc.exons"]][["peptides"]] %>% dplyr::filter(PEP <= 0.01 & Score >= 30) %>% .[-grep(x = .$Leading.razor.protein, pattern = "REV"), ]
                                                                  b2 <- names(list_imported_maxquant_tibbles_processed[["junc.exons"]]["peptides"])
                                                                  ###########
                                                                  
                                                                  b1 <- .x %>% dplyr::filter(PEP <= 0.01 & Score >= 30) %>% .[-grep(x = .$Leading.razor.protein, pattern = "REV"), ]
                                                                  b2 <- .y
                                                                  
                                                                  cat("now processing", b2, "at level 2\n") 
                                                                  
                                                                  # extract all the identifiers of the detected junctions/exons
                                                                  tibble_identifier_detected_junc.exons <- b1[, "Leading.razor.protein"] %>% setNames("identifier")
                                                                  
                                                                  # match to the supplementary FASTA info and extract the gene id
                                                                  vec_gene_ids <- dplyr::semi_join(tibble_fasta_supp_info, tibble_identifier_detected_junc.exons, by = "identifier") %>% .$matched_gene_names %>% na.omit %>% unique %>% mixedsort
                                                                  
                                                                  # CONDUCT ENRICHMENT
                                                                  tibble_GOhyper_result_MF <- GOHyperGAll(catdb = catdb, gocat = "MF", sample = vec_gene_ids, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% as_tibble
                                                                  tibble_GOhyper_result_BP <- GOHyperGAll(catdb = catdb, gocat = "BP", sample = vec_gene_ids, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% as_tibble
                                                                  tibble_GOhyper_result_CC <- GOHyperGAll(catdb = catdb, gocat = "CC", sample = vec_gene_ids, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% as_tibble
                                                                  
                                                                  return(list("GOhyper_result_MF" = tibble_GOhyper_result_MF,
                                                                              "GOhyper_result_BP" = tibble_GOhyper_result_BP,
                                                                              "GOhyper_result_CC" = tibble_GOhyper_result_CC,
                                                                              "queried_gene_names" = vec_differential_gene_names))
                                                                  
                                                                } )
                                         
                                       } )

```