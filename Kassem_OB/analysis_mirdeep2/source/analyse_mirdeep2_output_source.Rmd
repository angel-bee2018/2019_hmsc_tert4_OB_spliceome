---
title: "analyse_mirdeep2_output_aarhus_smallseq"
author: "Angel Liang"
date: "05/10/2020"
output: html_document
---

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
library(extrafont)
# loadfonts(device = "win")
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(edgeR)
library(RUVSeq)
library(Amelia)

library(genefilter)

library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
future::plan(multiprocess)
library(future.apply)
memory.limit(100000)

library(ggplot2)
library(kohonen)
library(genefilter)
library(gplots)
library(lattice)
library(svglite)
library(scales)
library(stringr)

library(biomaRt)
ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 98)

library(systemPipeR)
library(GOstats)
library(PFAM.db)
library(bc3net)
library(data.table)

shared_dir <- "/mnt/Tertiary/sharedfolder/"

timeseries_info_table_path <- "/mnt/Helium_8TB_1/aarhus_smallseq_timeseries_mirna_BM_MSC_to_OB_GSE107279/data/SRR_to_timeseries_info.txt"

tibble_timeseries_info <- read.delim(file = timeseries_info_table_path, sep = "\t", header = FALSE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

vector_timepoints_replicates <- tibble_timeseries_info$V3

vector_timepoints <- c("MSC", "6h", "12h", "1d", "3d", "7d", "10d", "13d")

vector_replicates <- c("r1", "r2", "r3")

mirdeep2_results_dir <- "/mnt/Helium_8TB_1/aarhus_smallseq_timeseries_mirna_BM_MSC_to_OB_GSE107279/mirdeep2_results/"

R_processing_results_dir <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_mirdeep2/R_processing_results/"

if(! dir.exists(R_processing_results_dir) ) {
     dir.create(R_processing_results_dir, recursive = TRUE)}

qualitycheck_results_dir <- paste(R_processing_results_dir, "qualitycheck/", sep = "")

if(! dir.exists(qualitycheck_results_dir) ) {
     dir.create(qualitycheck_results_dir, recursive = TRUE)}
 
```

## define functions

### FUNCTION TO PLOT PCA FOR TIMEPOINT AND REPLICATE

```{r}

plot_PCA_for_timepoint_and_replicate <- function(matrixtable, timepoint_order = NULL, replicate_order = NULL, PCA_depths_y = NULL, PCA_depths_x = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL, width = 10, height = 10) {
  
  # DEBUG ###
  # save_dir <- R_processing_results_dir
  # save_name <- "raw_MQ_intensities"
  # 
  # graph_title <- paste(.y[[1]], "\n", .y[[2]], sep = "")
  # 
  # timepoint_order <- c("ud_1_24", "ud_30_6", "30m", "1h", "6h", "1d")
  # replicate_order <- vector_replicate_names
  # 
  # PCA_depths_y <- c(2, 3, 4)
  # PCA_depths_x <- c(1, 2, 3)
  ###########
  
  PCA_result <- prcomp(matrixtable)
  
  ## measure PC variance #
  PCA_stdev <- tibble("PC" = 1:(PCA_result[["sdev"]] %>% length), "stdev" = PCA_result[["sdev"]])
  
  PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
  PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)
  
  ggplot(PCA_variance) + 
    geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
    scale_fill_gradientn(colours = heat.colors(n = (PCA_result[["sdev"]] %>% length))) +
    ggtitle(paste("PCA variance distribution\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("PC") +
    ylab("Variance explained (%)") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")
  
  ## measure PC loadings #
  ## column names of the matrix need to be split by a "|", like this: timepoint|replicatenumber
  PCA_loadings <- PCA_result[["rotation"]] %>% as_tibble(rownames = "sample")
  PCA_loadings <- add_column(PCA_loadings, "timepoint" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1") %>% factor(x = ., levels = timepoint_order))
  PCA_loadings <- add_column(PCA_loadings, "replicatenumber" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2") %>% factor(x = ., levels = replicate_order))
  
  # plot PCA for multiple depths all in one go.
  purrr::map2(.x = PCA_depths_x, .y = PCA_depths_y, .f = function(.x, .y) {
    
    pc_y <- .y
    pc_x <- .x
    
    ggplot(PCA_loadings) + 
      geom_point(aes(x = !!(paste("PC", pc_x, sep = "") %>% as.name), y = !!(paste("PC", pc_y, sep = "") %>% as.name), shape = replicatenumber, color = timepoint, size = 2)) +
      # scale_fill_gradientn(name = "Timepoint", colours = rainbow(n = (PCA_loadings %>% nrow))) +
      scale_color_brewer(name = "Timepoint", palette = "Spectral", breaks = timepoint_order, limits = timepoint_order) +
      scale_shape_discrete(name = "Replicate") +
      ggtitle(paste("PCA loadings\n", graph_title, sep = "")) +
      guides(size = FALSE) + 
      xlab(paste("PC", pc_x, " (", PCA_variance[pc_x, "variance_explained"] %>% signif(3), "%)", sep = "")) +
      ylab(paste("PC", pc_y, " (", PCA_variance[pc_y, "variance_explained"] %>% signif(3), "%)", sep = "")) +
      theme_bw() +
      theme(text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".pdf", sep = ""), device = "pdf", dpi = 600, width = width, height = height, units = "cm") +
      ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".svg", sep = ""), device = "svg", dpi = 600, width = width, height = height, units = "cm")
    
  } )
  
}

```

### function to filter out genes(rows) which dont have at least x read counts for every replicate of any one time point

```{r}

# input_matrix: must input a matrix - columns are replicates and must be grouped by replicate. assumed equal number of replicates. otherwise, we have to use a design matrix approach for more complicated setups
# replicateamount: number of replicates per timepoint
# threshold: the minimum number of counts that ALL timepoints of the same replicates must have in order to pass cutoff.
# no_annotation_cols: the number of annotation columns on the left of the table

filteratleast_x_reads_in_anytimepoint <- function(input_matrix, replicateamount, threshold, no_annotation_cols) {

### FILTERING FOR JUNCTIONS WITH AT LEAST 5 REOBS IN ALL 3 REPLICATES OF EACH TIMEPOINT

# generate column partitioning indices (subset every 3 columns for each timepoint made up of 3 replicates)
a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - replicateamount + 1, by = replicateamount)
b <- seq(from = replicateamount + no_annotation_cols, to = input_matrix %>% ncol, by = replicateamount)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- apply(input_matrix, MARGIN = 1, FUN = function(X) {purrr::map(c, ~all(X[.x] %>% as.numeric >= threshold))})

# logical table to show the junction coordinates which have at least one timepoint which has a sufficient number of mapped read counts.
e <- purrr::map(d, ~any(.x == TRUE))

# filter for juunctions backed by sufficient read counts only
output_matrix <- input_matrix[which(e == TRUE), ]

return(output_matrix)

}

## END filteratleast_x_reads_in_anytimepoint

```

### function to take the averages of triplicates

```{r}

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

### function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall and bc3net

```{r}

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch != 0, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  # benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes != 0, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr


```

# read all the mirdeep2 result tables and process them

```{r}

list_mirdeep2_result_tibbles <- furrr::future_map(
  .x = vector_timepoints_replicates,
  .f = function(a1) {
    
    read.delim(file = paste(mirdeep2_results_dir, a1, "/miRNAs_expressed_all_samples_05_10_2020_t_03_49_02.csv", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE) %>% 
      as_tibble
    
  } ) %>% set_names(vector_timepoints_replicates)

# rename columns to be comparison-specific
list_mirdeep2_result_tibbles_processed <- furrr::future_map2(
  .x = list_mirdeep2_result_tibbles,
  .y = names(list_mirdeep2_result_tibbles),
  .f = function(a1, a2) {
    
    output_tibble <- a1
    
    colnames(output_tibble) <- c("mirna", paste("read_count_", a2, sep = ""), "precursor", paste("total_read_count_", a2, sep = ""), paste("raw_counts_", a2, sep = ""), paste("TPM_", a2, sep = ""))
    
    return(output_tibble)
    
  } )

# table join for the raw counts only
## NOTE: there are no na's.
wide_tibble_raw_counts_table <- list_mirdeep2_result_tibbles_processed %>% 
  purrr::map(~.x %>% dplyr::select(mirna, precursor, contains("raw_counts")) %>% unique) %>%
  purrr::reduce(dplyr::left_join, by = c("mirna", "precursor"))

wide_tibble_raw_counts_table <- wide_tibble_raw_counts_table[, c("mirna", "precursor", purrr::cross2(.x = vector_replicates, .y = paste("raw_counts_BM_MSC_to_OB_", vector_timepoints, sep = "")) %>% purrr::map(~paste(.x[[2]], .x[[1]], sep = "_")) %>% unlist)]

wide_tibble_raw_counts_table <- wide_tibble_raw_counts_table %>% tibble::add_column(
  "mirbase_id" = wide_tibble_raw_counts_table$mirna %>% gsub(pattern = "^([^p]+)(\\-.*p_M.*|_M.*)", replacement = "\\1"),
  "mirbase_accession" = wide_tibble_raw_counts_table$precursor %>% gsub(pattern = ".*(MI[^_]+).*", replacement = "\\1"),
  "mirbase_mature_id" = wide_tibble_raw_counts_table$mirna %>% gsub(pattern = ".*_(.*)$", replacement = "\\1"),
  "mirbase_mature_accession" = wide_tibble_raw_counts_table$mirna %>% gsub(pattern = ".*(MIMAT[^_]+).*", replacement = "\\1"), .after = "precursor"
)


# make a tibble matrix for PCA, normalisation, DE etc...
wide_matrix_tibble_raw_counts_table <- wide_tibble_raw_counts_table 

colnames(wide_matrix_tibble_raw_counts_table) <- gsub(x = colnames(wide_matrix_tibble_raw_counts_table), pattern = "raw_counts_BM_MSC_to_OB_([^_]+)_(.*)", replacement = "\\1|\\2")

wide_matrix_tibble_raw_counts_table <- wide_matrix_tibble_raw_counts_table %>% 
  tibble::add_column("id" = 1:nrow(wide_matrix_tibble_raw_counts_table), .before = 1)

```

# edgeR/RUVseq workflow

## Plot PCA of raw counts

```{r}

plot_PCA_for_timepoint_and_replicate(matrixtable = wide_matrix_tibble_raw_counts_table %>% dplyr::select(-id, -mirna, -precursor, -mirbase_id, -mirbase_accession, -mirbase_mature_id, -mirbase_mature_accession), 
                                     timepoint_order = vector_timepoints, 
                                     replicate_order = vector_replicates,
                                     PCA_depths_x = c(1, 2, 3),
                                     PCA_depths_y = c(2, 3, 4),
                                     save_dir = qualitycheck_results_dir,
                                     save_name = "raw_mirdeep2_counts",
                                     graph_title = "PCA plot of raw mirdeep2 counts",
                                     width = 12,
                                     height = 10)

```

## Create design matrix

```{r}

factor_timepoints <- factor(gsub(x = wide_matrix_tibble_raw_counts_table %>% dplyr::select(-id, -mirna, -precursor, -mirbase_id, -mirbase_accession, -mirbase_mature_id, -mirbase_mature_accession) %>% colnames, pattern = "^(.*)\\|(.*)", replacement = "\\1"), levels = vector_timepoints)
factor_replicates <- factor(gsub(x = wide_matrix_tibble_raw_counts_table %>% dplyr::select(-id, -mirna, -precursor, -mirbase_id, -mirbase_accession, -mirbase_mature_id, -mirbase_mature_accession) %>% colnames, pattern = "^(.*)\\|(.*)", replacement = "\\2"), levels = vector_replicates)

design_matrix <- model.matrix(~ 0 + factor_timepoints + factor_replicates)

```

## RUV: removal of unwanted variation

### define packages, paths and functions

NOTE: a handful of housekeeping micro RNAs are known, but they are not enough to constitute negative controls.

```{r}

# filter for at least read count of 2 in all 3 replicates of any one time point

wide_matrix_tibble_raw_counts_table_highpass <- wide_matrix_tibble_raw_counts_table %>% filteratleast_x_reads_in_anytimepoint(., replicateamount = 3, threshold = 2, no_annotation_cols = 7)

pdf(paste(qualitycheck_results_dir, "RLE_boxplot_raw_mirdeep2_counts.pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(wide_matrix_tibble_raw_counts_table_highpass[, 8:ncol(wide_matrix_tibble_raw_counts_table_highpass)] %>% as.matrix, outline = FALSE, ylim = c(-2, 2), col = factor_timepoints, las = 2, main = "RLE plot of raw mirdeep2 counts")

dev.off()

# RUV
  
# upper quantile normalisation

wide_matrix_tibble_raw_counts_table_highpass_upperQN <- betweenLaneNormalization(wide_matrix_tibble_raw_counts_table_highpass[, 8:ncol(wide_matrix_tibble_raw_counts_table_highpass)] %>% as.matrix, which = "upper")

replicate_rownumbers <- tribble(~rep1, ~rep2, ~rep3,
            1,     2,     3,
            4,     5,     6,
            7,     8,     9,
            10,    11,    12,
            13,    14,    15,
            16,    17,    18,
            19,    20,    21,
            22,    23,    24) %>% as.matrix

## FINDING THE EMPIRICAL CONTROL GENES
## determining the genes with the highest pvalue for RUVg normalisation
## basically running edgeR GLM with the unnormalised (but count filtered) data

dge_raw <- DGEList(counts = wide_matrix_tibble_raw_counts_table_highpass[, 8:ncol(wide_matrix_tibble_raw_counts_table_highpass)], genes = wide_matrix_tibble_raw_counts_table_highpass$id, group = factor_timepoints)
dge_raw <- calcNormFactors(dge_raw, method = "upperquartile")
dge_raw <- estimateGLMCommonDisp(dge_raw, design_matrix)
dge_raw <- estimateGLMTagwiseDisp(dge_raw, design_matrix)

fit_QL_raw <- glmQLFit(dge_raw, design_matrix)

#####

assigntwovaluestocolumn <- function(position1, value1, position2, value2, lengthofcolumn) {
    
    column <- rep(0, times = lengthofcolumn)
    column[[position1]] <- value1
    column[[position2]] <- value2
    
    return(column)
    
}

#####

contrasts_alltimepoints <- makeContrasts(delete = (factor_timepoints %>% unique %>% .[1]) - (factor_timepoints %>% unique %>% .[2]), levels = design_matrix)

allcomparisons_coordinates <- combn(1:(factor_timepoints %>% unique %>% length), 2) %>% t %>% array_tree %>% purrr::map(.x = ., .f = ~assigntwovaluestocolumn(position1 = .x[[1]], value1 = -1, position2 = .x[[2]], value2 = 1, lengthofcolumn = factor_timepoints %>% unique %>% length)) %>% bind_cols %>% as.matrix %>% rbind(., 0) %>% rbind(., 0)

contrasts_alltimepoints <- cbind(contrasts_alltimepoints, allcomparisons_coordinates)

contrasts_alltimepoints <- contrasts_alltimepoints[, -1]

contrastnames <- combn(1:(factor_timepoints %>% unique %>% length), 2) %>% t %>% array_tree %>% purrr::map(.x = ., .f = ~paste(levels(factor_timepoints)[.x[[2]]], "_minus_", levels(factor_timepoints)[.x[[1]]], sep = ""))

colnames(contrasts_alltimepoints) <- contrastnames

lrt_raw <- glmQLFTest(fit_QL_raw, contrast = contrasts_alltimepoints)

empiricalcontrolgenes <- topTags(lrt_raw, n = wide_matrix_tibble_raw_counts_table_highpass$id %>% length)$table %>% .[.$FDR > 0.9, "genes"]

empiricalcontrolgenes_row_positions <- lapply(empiricalcontrolgenes, FUN = function(x){which(x ==  wide_matrix_tibble_raw_counts_table_highpass$id)}) %>% unlist

###########

# set k values to sweep thru

vector_k.values_to_sweep_thru <- c(2, 3, 4, 1)

for (k.value in vector_k.values_to_sweep_thru) {
  
  # RUVg ###

nsYg <- RUVg(wide_matrix_tibble_raw_counts_table_highpass_upperQN %>% as.matrix, cIdx = empiricalcontrolgenes_row_positions, k = k.value)
 
tibble_normalised_counts_RUVg <- bind_cols(wide_matrix_tibble_raw_counts_table_highpass[, 1:7], nsYg$normalizedCounts %>% as_tibble)
  
  pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVg_normalised_counts_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(tibble_normalised_counts_RUVg[, 8:ncol(tibble_normalised_counts_RUVg)] %>% as.matrix, outline = FALSE, ylim = c(-1.5, 1.5), col = factor_timepoints, las = 2, main = paste("RLE plot of RUVg normalised counts, k =", k.value), )
  
  dev.off()
  
## PCA
plot_PCA_for_timepoint_and_replicate(matrixtable = tibble_normalised_counts_RUVg %>% dplyr::select(-id, -mirna, -precursor, -mirbase_id, -mirbase_accession, -mirbase_mature_id, -mirbase_mature_accession), 
                                     timepoint_order = vector_timepoints, 
                                     replicate_order = vector_replicates,
                                     PCA_depths_x = c(1, 2, 3),
                                     PCA_depths_y = c(2, 3, 4),
                                     save_dir = qualitycheck_results_dir,
                                     save_name = paste("RUVg_normalised_counts_k", k.value, sep = ""),
                                     graph_title = paste("RUVg normalised counts, k =", k.value),
                                     width = 12,
                                     height = 10)
  
# RUVs ###

nsYs <- RUVs(wide_matrix_tibble_raw_counts_table_highpass_upperQN %>% as.matrix, scIdx = replicate_rownumbers, k = k.value)
 
tibble_normalised_counts_RUVs <- bind_cols(wide_matrix_tibble_raw_counts_table_highpass[, 1:7], nsYs$normalizedCounts %>% as_tibble)
  
  pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVs_normalised_counts_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(tibble_normalised_counts_RUVs[, 8:ncol(tibble_normalised_counts_RUVs)] %>% as.matrix, outline = FALSE, ylim = c(-1.5, 1.5), col = factor_timepoints, las = 2, main = paste("RLE plot of RUVs normalised counts, k =", k.value), )
  
  dev.off() 
  
## PCA
plot_PCA_for_timepoint_and_replicate(matrixtable = tibble_normalised_counts_RUVs %>% dplyr::select(-id, -mirna, -precursor, -mirbase_id, -mirbase_accession, -mirbase_mature_id, -mirbase_mature_accession), 
                                     timepoint_order = vector_timepoints, 
                                     replicate_order = vector_replicates,
                                     PCA_depths_x = c(1, 2, 3),
                                     PCA_depths_y = c(2, 3, 4),
                                     save_dir = qualitycheck_results_dir,
                                     save_name = paste("RUVs_normalised_counts_k", k.value, sep = ""),
                                     graph_title = paste("RUVs normalised counts, k =", k.value),
                                     width = 12,
                                     height = 10)
  
# RUVr: normalisation based on residuals ###
  # gotta test with or without upper quantile normalisation first
  # meaning dge_raw or dge_upperonly
  
###
dge_upperonly <- DGEList(counts = wide_matrix_tibble_raw_counts_table_highpass_upperQN, genes = wide_matrix_tibble_raw_counts_table_highpass$id, group = factor_timepoints)
dge_upperonly <- calcNormFactors(dge_upperonly, method = "upperquartile")
dge_upperonly <- estimateGLMCommonDisp(dge_upperonly, design_matrix)
dge_upperonly <- estimateGLMTagwiseDisp(dge_upperonly, design_matrix) 
###

### * * * ###
fit_raw <- glmFit(dge_raw, design_matrix)
residuals_raw <- residuals(fit_raw, type = "deviance")
###       ###
fit_upperonly <- glmFit(dge_upperonly, design_matrix)
residuals_upperonly <- residuals(fit_upperonly, type = "deviance")
### * * * ###

# nsYr_raw <- RUVr(wide_matrix_tibble_raw_counts_table_highpass_upperQN %>% as.matrix, cIdx = 1:length(wide_matrix_tibble_raw_counts_table_highpass$id), k = 1, residuals = residuals_raw)

nsYr_upperonly <- RUVr(wide_matrix_tibble_raw_counts_table_highpass_upperQN %>% as.matrix, cIdx = 1:length(wide_matrix_tibble_raw_counts_table_highpass$id), k = k.value, residuals = residuals_upperonly)

tibble_normalised_counts_RUVr <- bind_cols(wide_matrix_tibble_raw_counts_table_highpass[, 1:7], nsYr_upperonly$normalizedCounts %>% as_tibble)
  
  pdf(paste(qualitycheck_results_dir, "RLE_boxplot_RUVr_normalised_counts_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(tibble_normalised_counts_RUVr[, 8:ncol(tibble_normalised_counts_RUVr)] %>% as.matrix, outline = FALSE, ylim = c(-1.5, 1.5), col = factor_timepoints, las = 2, main = paste("RLE plot of RUVr normalised counts, k =", k.value), )
  
  dev.off()
  
## PCA
plot_PCA_for_timepoint_and_replicate(matrixtable = tibble_normalised_counts_RUVr %>% dplyr::select(-id, -mirna, -precursor, -mirbase_id, -mirbase_accession, -mirbase_mature_id, -mirbase_mature_accession), 
                                     timepoint_order = vector_timepoints, 
                                     replicate_order = vector_replicates,
                                     PCA_depths_x = c(1, 2, 3),
                                     PCA_depths_y = c(2, 3, 4),
                                     save_dir = qualitycheck_results_dir,
                                     save_name = paste("RUVr_normalised_counts_k", k.value, sep = ""),
                                     graph_title = paste("RUVr normalised counts, k =", k.value),
                                     width = 12,
                                     height = 10)
  
}

```

## Differential Expression Analysis

Note: we have decided on k=1 since the raw PCA plots were already pretty good to begin with and there's no benefit at all of using a higher k.

### setup the GLM and exacttests

```{r}

dge_genecounts_clean <- DGEList(counts = tibble_normalised_counts_RUVr[, 8:ncol(tibble_normalised_counts_RUVr)], genes = tibble_normalised_counts_RUVr$id, group = factor_timepoints)
dge_genecounts_normfactors <- calcNormFactors(dge_genecounts_clean, method = "upperquartile")

# estimate dispersion
dge_genecounts_disp <- estimateDisp(dge_genecounts_normfactors, design_matrix)

pdf(paste(qualitycheck_results_dir, "quality.plot_BCV_post.normalisation.pdf", sep = "")) 

plotBCV(dge_genecounts_disp)

dev.off()

```

### either: pairwise exacttest for significant genes

```{r}

# generate a final wide table of all the pairwise comparison data

timepoint_comparisons <- combn(factor_timepoints %>% unique, 2) %>% t

timepoint_comparison_1 <- timepoint_comparisons[, 1] %>% array_tree
timepoint_comparison_2 <- timepoint_comparisons[, 2] %>% array_tree

# join together all the topTags into one wide table

list_edgeR_pairwise_topTags <- purrr::map2(.x = timepoint_comparison_1, .y = timepoint_comparison_2, .f = ~topTags(exactTest(dge_genecounts_disp, pair = c(.x, .y)), n = length(tibble_normalised_counts_RUVr$id))) %>% set_names(paste(timepoint_comparison_1 %>% unlist %>% as.character, "_vs_", timepoint_comparison_2 %>% unlist %>% as.character, sep = ""))

column_anysig_DEgenes <- purrr::map(.x = list_edgeR_pairwise_topTags, .f = ~.x$table %>% .[.$FDR <= 0.01 & abs(.$logFC) > 1, "genes"]) %>% purrr::reduce(union) %>% as_tibble %>% setNames("id")

```

### or: GLM test for significant genes

```{r}

dge_genecounts_GLM <- estimateGLMCommonDisp(dge_genecounts_normfactors, design_matrix)
dge_genecounts_GLM <- estimateGLMTagwiseDisp(dge_genecounts_GLM, design_matrix)

# calculate QL fit
dge_genecounts_QLFit <- glmQLFit(dge_genecounts_GLM, design_matrix)

pdf(paste(qualitycheck_results_dir, "quality.plot_QL.fit_post.normalisation.pdf", sep = "")) 
plotQLDisp(dge_genecounts_QLFit)
dev.off()

pdf(paste(qualitycheck_results_dir, "quality.plot_logfc.vs.logCPM_post.normalisation.pdf", sep = "")) 
plotMD(dge_genecounts_QLFit)
dev.off()

dge_genecounts_LRT <- glmQLFTest(dge_genecounts_QLFit, contrast = contrasts_alltimepoints)

tibble_GLM <- topTags(dge_genecounts_LRT, n = tibble_normalised_counts_RUVr$id %>% length)$table %>% as_tibble 

logFC_colnums <- grep(x = colnames(tibble_GLM), pattern = "logFC")
FDR_colnum <- grep(x = colnames(tibble_GLM), pattern = "FDR")

tibble_GLM_DEGrownums <- which(apply(tibble_GLM, 1, FUN = function(X) {(any(abs(as.numeric(X[logFC_colnums])) >= 1)) & (X[FDR_colnum] %>% as.numeric < 0.01)}))

column_GLMsig_DEgenes <- tibble_GLM[tibble_GLM_DEGrownums, "genes"] %>% setNames("id")

```

### plot graph of the cumulative changes

#### use the pairwise tests to accomplish this.

```{r}

# generate a single tibble summarising all the pairwise tests
tibble_all_pairwise_results <- purrr::map2(.x = list_edgeR_pairwise_topTags, .y = paste(timepoint_comparisons[, 1], timepoint_comparisons[, 2], sep = "_vs_"), .f = ~.x$table %>% add_column(comparison = .y)) %>% rbindlist %>% as_tibble
# filter by significant gene ids
tibble_all_pairwise_results_significant_only <- dplyr::semi_join(tibble_all_pairwise_results, 
                                                                 column_anysig_DEgenes %>% dplyr::rename("genes" = "id"),
                                                                 by = "genes")

tibble_cumulative_diff_changes <- tibble("timepoint" = vector_timepoints, 
                                         "cumulative_diff_changes" = 
                                           c(0, 
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(!str_detect(comparison, "13d") & !str_detect(comparison, "10d") & !str_detect(comparison, "7d") & !str_detect(comparison, "3d") & !str_detect(comparison, "24h") & !str_detect(comparison, "12h") & FDR <= 0.01 & abs(logFC) >= 1) %>% nrow,
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(!str_detect(comparison, "13d") & !str_detect(comparison, "10d") & !str_detect(comparison, "7d") & !str_detect(comparison, "3d") & !str_detect(comparison, "24h") & FDR <= 0.01 & abs(logFC) >= 1) %>% nrow,
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(!str_detect(comparison, "13d") & !str_detect(comparison, "10d") & !str_detect(comparison, "7d") & !str_detect(comparison, "3d") & FDR <= 0.01 & abs(logFC) >= 1) %>% nrow,
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(!str_detect(comparison, "13d") & !str_detect(comparison, "10d") & !str_detect(comparison, "7d") & FDR <= 0.01 & abs(logFC) >= 1) %>% nrow,
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(!str_detect(comparison, "13d") & !str_detect(comparison, "10d") & FDR <= 0.01 & abs(logFC) >= 1) %>% nrow,
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(!str_detect(comparison, "13d") & FDR <= 0.01 & abs(logFC) >= 1) %>% nrow,
                                             tibble_all_pairwise_results_significant_only %>% dplyr::filter(FDR <= 0.01 & abs(logFC) >= 1) %>% nrow)) %>% 
                                           add_column("cumulative_diff_changes_pct" = .$cumulative_diff_changes * 100 / (.$cumulative_diff_changes %>% max))

```

#### create tibble of cumulative differential changes, excluding each timepoint successively and filtering by logFC - DEPRECATED!!!

```{r}

# tibble_GLM_OBseries_filtered <- tibble_GLM %>% dplyr::filter(FDR <= 0.01)
# 
# tibble_cumulative_diff_changes <- tibble("timepoint" = vec_timepoint_order_OBseries_short_edited, 
#                                          "cumulative_diff_changes" = 
#                                            c(0, 
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("13d") & !contains("10d") & !contains("7d") & !contains("3d") & !contains("24h") & !contains("12h")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("13d") & !contains("10d") & !contains("7d") & !contains("3d") & !contains("24h")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("13d") & !contains("10d") & !contains("7d") & !contains("3d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("13d") & !contains("10d") & !contains("7d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("13d") & !contains("10d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("13d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
#                                              tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length)) %>% 
#   add_column("cumulative_diff_changes_pct" = .$cumulative_diff_changes * 100 / (.$cumulative_diff_changes %>% max))

```

#### GGPLOT

```{r}

ggplot(tibble_cumulative_diff_changes, aes(y = cumulative_diff_changes_pct, x = timepoint)) +
  # geom_point() +
  geom_path(aes(group = "OBseries"), colour = "steelblue1") +
  ggtitle("Cumulative changes in the hMSC-TERT4 miRNA expression\nOsteogenesis\nRSEM/EdgeR") +
  xlab("Timepoint") +
  ylab("Cumulative differential changes") +
  scale_x_discrete(limits = vector_timepoints, labels = vector_timepoints) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 12, units = "cm") +
  ggsave(filename = paste(R_processing_results_dir, "plot_of_cumulative_changes.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 12, units = "cm")

```

## CREATION OF THE LOGCPM TABLE

normalise ALL gene counts based on library and export

```{r}

logCPM_allgenes <- bind_cols(tibble_normalised_counts_RUVr %>% dplyr::select(id, mirna, precursor, mirbase_id, mirbase_accession, mirbase_mature_id, mirbase_mature_accession), cpm(dge_genecounts_normfactors, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2) %>% as_tibble)

colnames(logCPM_allgenes) <- gsub(x = colnames(logCPM_allgenes), pattern = "expected_count", replacement = "logCPM")

write.table(x = logCPM_allgenes, file = paste(R_processing_results_dir, "table_edgeR_allgenes_logCPM.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

FILTERING CPM TABLE FOR DEG, FDR AND LOG FOLD CHANGE AND EXPORT

```{r}

cat("\nnumber of DE genes different: ", dplyr::anti_join(column_anysig_DEgenes, column_GLMsig_DEgenes) %>% nrow)
cat("\nnumber of DE genes in common: ", dplyr::semi_join(column_anysig_DEgenes, column_GLMsig_DEgenes) %>% nrow)

# purrr::map2(.x = timepoint_comparison_1_OBseries, .y = timepoint_comparison_2_OBseries, .f = ~plotSmear(exactTest(dge_genecounts_normfactors, pair = c(.x, .y)), de.tags = rownames(DEGresult$table)[which(DEGresult$table$FDR < 0.05 & abs(DEGresult$table$logFC) > 1.5)]))

# filter the logCPM table by anysig DEGs

logCPM_anysig_DEGs <- dplyr::semi_join(logCPM_allgenes, column_anysig_DEgenes, by = "id")

write.table(x = logCPM_anysig_DEGs, file = paste(R_processing_results_dir, "table_edgeR_anysig_DEGs_logCPM.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter the logCPM table by GLM significant DEGs

tibble_logCPM_GLM_DEGs <- dplyr::semi_join(logCPM_allgenes, column_GLMsig_DEgenes, by = "id")

# retrieve ENSG to external gene name mappings

# tibble_ENSG_to_gene_symbol <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart) %>% as_tibble

# tibble_mirbase_id_to_ENSG <- getBM(filters = "mirbase_id", values = df_logCPM_GLM_DEGs$mirna %>% gsub(pattern = "^([^p]+)(\\-.*p_M.*|_M.*)", replacement = "\\1"), attributes = c("ensembl_gene_id", "mirbase_id"), mart = ensembl_mart)

# dplyr right join the gene symbols 
# tibble_logCPM_GLM_DEGs <- dplyr::right_join(df_ENSG_to_gene.symbol, df_logCPM_GLM_DEGs, by = "ensembl_gene_id") %>% as_tibble

write.table(x = tibble_logCPM_GLM_DEGs, file = paste(R_processing_results_dir, "table_edgeR_GLM_DEGs_logCPM.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# DRAWING SOMS TO ANALYSE TIME SERIES DATA

## average the values at each timepoint 

```{r}

# list-ify per timepoint
list_of_tibbles_logCPM_GLM_DEGs_per_timepoint <- purrr::map(.x = vector_timepoints, 
              .f = ~tibble_logCPM_GLM_DEGs %>% 
                dplyr::select(contains(.x))) %>% set_names(vector_timepoints)

tibble_logCPM_GLM_DEGs_averaged <- purrr::map2(.x = list_of_tibbles_logCPM_GLM_DEGs_per_timepoint,
                                               .y = names(list_of_tibbles_logCPM_GLM_DEGs_per_timepoint),
                                               .f = ~2^.x %>% rowMeans %>% as.data.frame %>% setNames(.y) %>% log2) %>%
  purrr::reduce(bind_cols) %>%
  dplyr::bind_cols(tibble_logCPM_GLM_DEGs[, 1:7], .)

```

## construction of a 5x5 SOM

```{r}

som_seed_number <- 7

SOM_xdim <- 3
SOM_ydim <- 3

number_of_som_clusters <- SOM_xdim * SOM_ydim

# OB series #####

som_5_by_5_table  <- tibble_logCPM_GLM_DEGs_averaged[, vector_timepoints]

som_5_by_5_table <- som_5_by_5_table %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5 <- som(som_5_by_5_table, grid = somgrid(xdim = SOM_xdim, ydim = SOM_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_tibble_of_final_SOM_summary_5_by_5 <- cbind(tibble_logCPM_GLM_DEGs_averaged[, 1:7], som_5_by_5_table, cluster = somdata_5_by_5[["unit.classif"]]) %>% as_tibble

```

### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table
long_tibble_of_final_SOM_summary_5_by_5 <- reshape2::melt(wide_tibble_of_final_SOM_summary_5_by_5, id.vars = c("id", "mirna", "precursor", "mirbase_id", "mirbase_accession", "mirbase_mature_id", "mirbase_mature_accession", "cluster"), variable.name = "timepoint", value.name = "scaled_expr") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_tibble_of_final_SOM_summary_5_by_5[, "cluster_minus_1"] <- long_tibble_of_final_SOM_summary_5_by_5$cluster - 1

long_tibble_of_final_SOM_summary_5_by_5[, "remainder_facet.x"] <- long_tibble_of_final_SOM_summary_5_by_5$cluster_minus_1 %% 3

long_tibble_of_final_SOM_summary_5_by_5[, "quotient_facet.y"] <- long_tibble_of_final_SOM_summary_5_by_5$cluster_minus_1 %/% 3

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_average.line <- long_tibble_of_final_SOM_summary_5_by_5 %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_expr" = mean(scaled_expr))

```

### THE GGPLOT

all the genes

```{r}

# OB series
ggplot() +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5, aes(x = timepoint, y = scaled_expr, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_average.line, aes(x = timepoint, y = avg_expr, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste("3 x 3 SOM\n", wide_tibble_of_final_SOM_summary_5_by_5 %>% nrow, " miRNAs\n", "RSEM/edgeR", sep = "")) +
  scale_x_discrete(limits = vector_timepoints, labels = vector_timepoints) +
  xlab("Time-point") +
  ylab("Scaled expr Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(R_processing_results_dir, SOM_xdim, "x", SOM_ydim, "_SOM_", wide_tibble_of_final_SOM_summary_5_by_5 %>% nrow, "_miRNAs_expr_OB_diff_qvalue0.01_fc2.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
 ggsave(filename = paste(R_processing_results_dir, SOM_xdim, "x", SOM_ydim, "_SOM_", wide_tibble_of_final_SOM_summary_5_by_5 %>% nrow, "_miRNAs_expr_OB_diff_qvalue0.01_fc2.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

write.table(x = wide_tibble_of_final_SOM_summary_5_by_5, file = paste(R_processing_results_dir, SOM_xdim, "x", SOM_ydim, "_SOM_", wide_tibble_of_final_SOM_summary_5_by_5 %>% nrow, "_miRNAs_expr_OB_diff_qvalue0.01_fc2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

```{r}

tibble_differential_region_JUM_with_iclip_ago2 <- read.delim(paste(multiome_results_dir, "tibble_differential_region_JUM_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble %>% dplyr::mutate("mirbase_mature_id" = gsub(x = miR_seed, pattern = "^([^_]+).*", replacement = "\\1"))

tibble_differential_region_PSIsigma_with_iclip_ago2 <- read.delim(paste(multiome_results_dir, "tibble_differential_region_PSIsigma_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::mutate("mirbase_mature_id" = gsub(x = miR_seed, pattern = "^([^_]+).*", replacement = "\\1"))

```

