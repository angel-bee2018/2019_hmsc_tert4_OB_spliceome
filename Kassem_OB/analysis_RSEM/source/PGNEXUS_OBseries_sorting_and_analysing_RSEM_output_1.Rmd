---
title: "PGNEXUS_OBseries Sorting and analysing RSEM output"
author: "Angel Liang"
date: "11/01/2020"
output: html_document
---

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
library(extrafont)
loadfonts(device = "win")
windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(edgeR)

library(genefilter)

library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
future::plan(multiprocess)
library(future.apply)
memory.limit(100000)

library(ggplot2)
library(kohonen)
library(genefilter)
library(gplots)
library(lattice)
library(svglite)
library(scales)
library(stringr)

library(biomaRt)
ensembl_mart = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", version = 98)

library(systemPipeR)
library(GOstats)
library(PFAM.db)
library(bc3net)
library(data.table)

OBseries_sampleandaccessionlists_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/"

OBseries_rsem_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_1_original/RSEM_quant_results/"

OBseries_R_processing_results_dir <- "Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_1_original/R_processing_results/"

if(! dir.exists(OBseries_R_processing_results_dir) ) {
     dir.create(OBseries_R_processing_results_dir, recursive = TRUE)}

```

# read all the RSEM output tables into environment

```{r}

list_of_replicatenames_OBseries <- read.delim(paste(OBseries_sampleandaccessionlists_dir, "annotated_fastqnames_replicatenumber.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% array_tree

vector_OBseries_timepoints <- read.delim(paste(OBseries_sampleandaccessionlists_dir, "timepointname_list.txt", sep = ""), stringsAsFactors = FALSE, sep = "\t", header = FALSE, row.names = NULL) %>% unlist

# set the timepoint order
vec_timepoint_order_OBseries <- c("BM_MSC_to_OB_ud", "BM_MSC_to_OB_6h", "BM_MSC_to_OB_12h", "BM_MSC_to_OB_24h", "BM_MSC_to_OB_3d", "BM_MSC_to_OB_6d", "BM_MSC_to_OB_9d", "BM_MSC_to_OB_12d")

# edit to change the stupid 24h to 1d
vec_timepoint_order_OBseries_edited <- gsub(x = vec_timepoint_order_OBseries, pattern = "24h", replacement = "1d")

list_genecounts_OBseries <- purrr::map(.x = list_of_replicatenames_OBseries, .f = ~read.delim(file = paste(OBseries_rsem_results_dir, .x, ".genes.results", sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")))

list_isoformcounts_OBseries <- purrr::map(.x = list_of_replicatenames_OBseries, .f = ~read.delim(file = paste(OBseries_rsem_results_dir, .x, ".isoforms.results", sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")))

```

## create lists of each timpoint expression table which will be the mainstay of the rest of the analysis

```{r message=FALSE}

list_genecounts_OBseries_renamed <- purrr::map2(.x = list_genecounts_OBseries, 
                                                .y = list_of_replicatenames_OBseries, 
                                                .f = ~setNames(.x, c("ensembl_gene_id", 
                                                                     "ensembl_transcript_id", 
                                                                     paste("length", .y, sep = "_"), 
                                                                     paste("effective_length", .y, sep = "_"), 
                                                                     paste("expected_count", .y, sep = "_"), 
                                                                     paste("TPM", .y, sep = "_"), 
                                                                     paste("FPKM", .y, sep = "_"))) %>% type_convert %>% as_tibble)

list_isoformcounts_OBseries_renamed <- purrr::map2(.x = list_isoformcounts_OBseries, 
                                                   .y = list_of_replicatenames_OBseries, 
                                                   .f = ~setNames(.x, c("ensembl_transcript_id", 
                                                                        "ensembl_gene_id", 
                                                                        paste("length", .y, sep = "_"), 
                                                                        paste("effective_length", .y, sep = "_"), 
                                                                        paste("expected_count", .y, sep = "_"), 
                                                                        paste("TPM", .y, sep = "_"), 
                                                                        paste("FPKM", .y, sep = "_"),
                                                                        paste("PSI", .y, sep = "_"))) %>% type_convert %>% as_tibble)


```

# Gene and isoform expression analysis

## create wide TPM table

```{r}

wide_table_of_genecounts_OBseries_expectedcount <- purrr::map(.x = list_genecounts_OBseries_renamed, .f = ~.x[, c(1, 5)]) %>% 
                                                        purrr::reduce(dplyr::full_join)

print(head(wide_table_of_genecounts_OBseries_expectedcount))


wide_table_of_isoformcounts_OBseries_expectedcount <- purrr::map(.x = list_isoformcounts_OBseries_renamed, .f = ~.x[, c(1, 2, 5)]) %>% 
                                                        purrr::reduce(dplyr::full_join)

print(head(wide_table_of_isoformcounts_OBseries_expectedcount))

wide_table_of_isoformcounts_OBseries_PSI <- purrr::map(.x = list_isoformcounts_OBseries_renamed, .f = ~.x[, c(1, 2, 6)]) %>% 
                                                        purrr::reduce(dplyr::full_join)

print(head(wide_table_of_isoformcounts_OBseries_PSI))

```

## edgeR/RUVSeq workflow

### create design matrix for use in this workflow

```{r}

timepoints_OB <- factor(gsub(x = list_of_replicatenames_OBseries %>% unlist, pattern = "(BM_MSC_to_OB_)(.*)_(r[1-3])", replacement = "\\1\\2"), levels = gsub(x = list_of_replicatenames_OBseries %>% unlist, pattern = "(BM_MSC_to_OB_)(.*)_(r[1-3])", replacement = "\\1\\2") %>% unique)
replicates_OB <- factor(gsub(x = list_of_replicatenames_OBseries %>% unlist, pattern = "(BM_MSC_to_OB_)(.*)_(r[1-3])", replacement = "\\3"))

design_matrix <- model.matrix(~ 0 + timepoints_OB + replicates_OB)

```

### data triaging and quality control

#### set environment

set quality check directory and packages

```{r}

library(RUVSeq)

library(Amelia)

OBseries_qualitycheck_results_dir <-  paste(OBseries_R_processing_results_dir, "qualitycheck/", sep = "")

if(! dir.exists(OBseries_qualitycheck_results_dir) ) {
     dir.create(OBseries_qualitycheck_results_dir, recursive = TRUE)}

```

##### set functions

```{r}

# function to transform a numerical array/matrix/tibble into an RLE plot, assuming genes are given on the y-axis and samples/replicates/timepoints are given on the x axis.

transformRLE <- function(input_array) {
  
  input_array <- log10(input_array)
  
  vec_gene_medians <- apply(X = input_array, MARGIN = 1, FUN = function(X) {median(X)})
  
  RLE_array <- apply(X = input_array, MARGIN = 2, FUN = function(X) {X - vec_gene_medians})
  
  return(RLE_array)
  
}

# transformRLE except if the values were already log transformed beforehand

transformRLEfromlogvalues <- function(input_array) {
  
  vec_gene_medians <- apply(X = input_array, MARGIN = 1, FUN = function(X) {median(X)})
  
  RLE_array <- apply(X = input_array, MARGIN = 2, FUN = function(X) {X - vec_gene_medians})
  
  return(RLE_array)
  
}

# function to filter out genes(rows) which dont have at least x read counts for every replicate of any one time point

# input_matrix: must input a matrix - columns are replicates and must be grouped by replicate. assumed equal number of replicates. otherwise, we have to use a design matrix approach for more complicated setups
# replicateamount: number of replicates per timepoint
# threshold: the minimum number of counts that ALL timepoints of the same replicates must have in order to pass cutoff.
# no_annotation_cols: the number of annotation columns on the left of the table

filteratleast_x_reads_in_anytimepoint <- function(input_matrix, replicateamount, threshold, no_annotation_cols) {

### FILTERING FOR JUNCTIONS WITH AT LEAST 5 REOBS IN ALL 3 REPLICATES OF EACH TIMEPOINT

# generate column partitioning indices (subset every 3 columns for each timepoint made up of 3 replicates)
a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - replicateamount + 1, by = replicateamount)
b <- seq(from = replicateamount + no_annotation_cols, to = input_matrix %>% ncol, by = replicateamount)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- apply(input_matrix, MARGIN = 1, FUN = function(X) {purrr::map(c, ~all(X[.x] %>% as.numeric >= threshold))})

# logical table to show the junction coordinates which have at least one timepoint which has a sufficient number of mapped read counts.
e <- purrr::map(d, ~any(.x == TRUE))

# filter for juunctions backed by sufficient read counts only
output_matrix <- input_matrix[which(e == TRUE), ]

return(output_matrix)

}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch != 0, ]
  
  benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
  
  # benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes != 0, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr


```

#### RUV: removal of unwanted variation

##### define packages, paths and functions

the OB series 6dr2 and 9dr3 samples may have been swapped.

we shall use RUVg (with housekeeping genes only, making no assumptions about the grouping of replicates by timepoint) to see if normalisation in this way improves PCA clustering.

RUVseq workflow 

http://bioconductor.org/packages/release/bioc/vignettes/RUVSeq/inst/doc/RUVSeq.pdf

Housekeeping genes:
  * ACTB ENSG00000075624
  * GAPDH ENSG00000111640
  * B2M ENSG00000166710
  * ef1a1 ENSG00000156508
  * HSPCB ENSG00000096384
  * rpl7 ENSG00000147604
  * rpl13a ENSG00000142541
  * PPIA ENSG00000196262
  * ubiquitin C ENSG00000150991

```{r message=FALSE, warning=FALSE}

library(RUVSeq)

# filter for at least read count of 2 in all 3 replicates of any one time point

OBseries_gene_expectedcount_raw_highpass <- wide_table_of_genecounts_OBseries_expectedcount %>% filteratleast_x_reads_in_anytimepoint(., replicateamount = 3, threshold = 2, no_annotation_cols = 1)

  pdf(paste(OBseries_qualitycheck_results_dir, "RLE_boxplot_raw_gene_expectedcount_originalconfig.pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))

  plotRLE(OBseries_gene_expectedcount_raw_highpass[, 2:ncol(OBseries_gene_expectedcount_raw_highpass)] %>% as.matrix, outline = FALSE, ylim = c(-2, 2), col = timepoints_OB, las = 2, main = "RLE plot of raw expected count")
  
  dev.off()

# RUV
  
# upper quantile normalisation

OBseries_gene_expectedcount_raw_highpass_upperQN <- betweenLaneNormalization(OBseries_gene_expectedcount_raw_highpass[, 2:ncol(OBseries_gene_expectedcount_raw_highpass)] %>% as.matrix, which = "upper")

replicate_rownumbers <- tribble(~rep1, ~rep2, ~rep3,
            1,     2,     3,
            4,     5,     6,
            7,     8,     9,
            10,    11,    12,
            13,    14,    15,
            16,    17,    18,
            19,    20,    21,
            22,    23,    24) %>% as.matrix

housekeeping_gene_colnumbers <- c(which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000075624"),
                                  which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000111640"),
                                  which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000166710"),
                                  which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000156508"),
                                  which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000096384"),
                                  which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000147604"),
                                  which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000142541"))
                                  # which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000196262"),
                                  # which(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id == "ENSG00000150991"))


## FINDING THE EMPIRICAL CONTROL GENES
## determining the genes with the highest pvalue for RUVg normalisation
## basically running edgeR GLM with the unnormalised (but count filtered) data

dge_raw <- DGEList(counts = OBseries_gene_expectedcount_raw_highpass[, 2:ncol(OBseries_gene_expectedcount_raw_highpass)], genes = OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id, group = timepoints_OB)
dge_raw <- calcNormFactors(dge_raw, method = "upperquartile")
dge_raw <- estimateGLMCommonDisp(dge_raw, design_matrix)
dge_raw <- estimateGLMTagwiseDisp(dge_raw, design_matrix)

fit_QL_raw <- glmQLFit(dge_raw, design_matrix)

#####

assigntwovaluestocolumn <- function(position1, value1, position2, value2, lengthofcolumn) {
    
    column <- rep(0, times = lengthofcolumn)
    column[[position1]] <- value1
    column[[position2]] <- value2
    
    return(column)
    
}

#####

contrasts_alltimepoints <- makeContrasts(delete = (timepoints_OB %>% unique %>% .[1]) - (timepoints_OB %>% unique %>% .[2]), levels = design_matrix)

allcomparisons_coordinates <- combn(1:(timepoints_OB %>% unique %>% length), 2) %>% t %>% array_tree %>% purrr::map(.x = ., .f = ~assigntwovaluestocolumn(position1 = .x[[1]], value1 = -1, position2 = .x[[2]], value2 = 1, lengthofcolumn = timepoints_OB %>% unique %>% length)) %>% bind_cols %>% as.matrix %>% rbind(., 0) %>% rbind(., 0)

contrasts_alltimepoints <- cbind(contrasts_alltimepoints, allcomparisons_coordinates)

contrasts_alltimepoints <- contrasts_alltimepoints[, -1]

contrastnames <- combn(1:(timepoints_OB %>% unique %>% length), 2) %>% t %>% array_tree %>% purrr::map(.x = ., .f = ~paste(levels(timepoints_OB)[.x[[2]]], "_minus_", levels(timepoints_OB)[.x[[1]]], sep = ""))

colnames(contrasts_alltimepoints) <- contrastnames

lrt_raw <- glmQLFTest(fit_QL_raw, contrast = contrasts_alltimepoints)

empiricalcontrolgenes <- topTags(lrt_raw, n = OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id %>% length)$table %>% .[.$FDR > 0.9, "genes"]

empiricalcontrolgenes_row_positions <- lapply(empiricalcontrolgenes, FUN = function(x){which(x ==  OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id)}) %>% unlist

###########

# set k

k.value <- 3

# RUVg

nsYg <- RUVg(OBseries_gene_expectedcount_raw_highpass_upperQN %>% as.matrix, cIdx = empiricalcontrolgenes_row_positions, k = k.value)
 
OBseries_gene_expectedcount_RUVg <- bind_cols(OBseries_gene_expectedcount_raw_highpass[, 1], nsYg$normalizedCounts %>% as_tibble)
  
  pdf(paste(OBseries_qualitycheck_results_dir, "RLE_boxplot_RUVg_gene_expectedcount_originalconfig_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(OBseries_gene_expectedcount_RUVg[, 2:ncol(OBseries_gene_expectedcount_RUVg)] %>% as.matrix, outline = FALSE, ylim = c(-1.5, 1.5), col = timepoints_OB, las = 2, main = paste("RLE plot of RUVg expected count, k =", k.value), )
  
  dev.off()
  
# RUVs

nsYs <- RUVs(OBseries_gene_expectedcount_raw_highpass_upperQN %>% as.matrix, scIdx = replicate_rownumbers, k = k.value)
 
OBseries_gene_expectedcount_RUVs <- bind_cols(OBseries_gene_expectedcount_raw_highpass[, 1], nsYs$normalizedCounts %>% as_tibble)
  
  pdf(paste(OBseries_qualitycheck_results_dir, "RLE_boxplot_RUVs_gene_expectedcount_originalconfig_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(OBseries_gene_expectedcount_RUVs[, 2:ncol(OBseries_gene_expectedcount_RUVs)] %>% as.matrix, outline = FALSE, ylim = c(-1.5, 1.5), col = timepoints_OB, las = 2, main = paste("RLE plot of RUVs expected count, k =", k.value), )
  
  dev.off() 
  
# RUVr: normalisation based on residuals
  # gotta test with or without upper quantile normalisation first
  # meaning dge_raw or dge_upperonly
  
###
dge_upperonly <- DGEList(counts = OBseries_gene_expectedcount_raw_highpass_upperQN, genes = OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id, group = timepoints_OB)
dge_upperonly <- calcNormFactors(dge_upperonly, method = "upperquartile")
dge_upperonly <- estimateGLMCommonDisp(dge_upperonly, design_matrix)
dge_upperonly <- estimateGLMTagwiseDisp(dge_upperonly, design_matrix) 
###

### * * * ###
fit_raw <- glmFit(dge_raw, design_matrix)
residuals_raw <- residuals(fit_raw, type = "deviance")
###       ###
fit_upperonly <- glmFit(dge_upperonly, design_matrix)
residuals_upperonly <- residuals(fit_upperonly, type = "deviance")
### * * * ###

# nsYr_raw <- RUVr(OBseries_gene_expectedcount_raw_highpass_upperQN %>% as.matrix, cIdx = 1:length(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id), k = 1, residuals = residuals_raw)

nsYr_upperonly <- RUVr(OBseries_gene_expectedcount_raw_highpass_upperQN %>% as.matrix, cIdx = 1:length(OBseries_gene_expectedcount_raw_highpass$ensembl_gene_id), k = k.value, residuals = residuals_upperonly)

OBseries_gene_expectedcount_RUVr <- bind_cols(OBseries_gene_expectedcount_raw_highpass[, 1], nsYr_upperonly$normalizedCounts %>% as_tibble)
  
  pdf(paste(OBseries_qualitycheck_results_dir, "RLE_boxplot_RUVr_gene_expectedcount_originalconfig_k", k.value, ".pdf", sep = "")) 
  
  par(mar = c(20, 4.1, 4.1, 2.1))
  
  plotRLE(OBseries_gene_expectedcount_RUVr[, 2:ncol(OBseries_gene_expectedcount_RUVr)] %>% as.matrix, outline = FALSE, ylim = c(-1.5, 1.5), col = timepoints_OB, las = 2, main = paste("RLE plot of RUVr expected count, k =", k.value), )
  
  dev.off()

```

#### PCA plot of expected counts 

```{r}

order_of_timepoints_OB <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")

```

##### plot PCA of raw expected counts

```{r}

# CHECK FOR MISSING VALUES IN THE COMBINED COUNT TABLE. THERE SHOULD BE NONE IF WE ARE TO DO PCA WITHOUT IMPUTATION.

missmap(OBseries_gene_expectedcount_raw_highpass[, 2:ncol(OBseries_gene_expectedcount_raw_highpass)], pdfstub = paste(qualitycheck_results_dir, "heatmap_missingness_gene_expectedcount_raw_originalconfig.pdf", sep = ""))

# PCA analysis

PCA_gene_expectedcount_raw <- prcomp(OBseries_gene_expectedcount_raw_highpass[, 2:ncol(OBseries_gene_expectedcount_raw_highpass)])

# plot standard deviations 

PCA_gene_expectedcount_raw_stdev <- tibble(PC = 1:(PCA_gene_expectedcount_raw[["sdev"]] %>% length), stdev = PCA_gene_expectedcount_raw[["sdev"]])
PCA_gene_expectedcount_raw_variance <- tibble(PC = PCA_gene_expectedcount_raw_stdev$PC, variance = PCA_gene_expectedcount_raw_stdev$stdev ^ 2)
PCA_gene_expectedcount_raw_variance <- add_column(PCA_gene_expectedcount_raw_variance, variance_explained = PCA_gene_expectedcount_raw_variance$variance/sum(PCA_gene_expectedcount_raw_variance$variance) * 100)

ggplot(PCA_gene_expectedcount_raw_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_gene_expectedcount_raw[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on raw gene expected counts", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_raw_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_raw_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_gene_expectedcount_raw_loadings <- PCA_gene_expectedcount_raw[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_gene_expectedcount_raw_loadings <- add_column(PCA_gene_expectedcount_raw_loadings, timepoint = gsub(x = PCA_gene_expectedcount_raw_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_gene_expectedcount_raw_loadings <- add_column(PCA_gene_expectedcount_raw_loadings, replicatenumber = gsub(x = PCA_gene_expectedcount_raw_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

## ggplot - purrr doesnt work

# y_PC_raw <- c(2:6) %>% array_tree
# x_PC_raw <- c(1:5) %>% array_tree
# 
# purrr::map2(.x = x_PC_raw, .y = y_PC_raw, .f = ~(ggplot(PCA_gene_expectedcount_raw_loadings) + 
#   geom_point(aes(y = PCA_gene_expectedcount_raw_loadings[, paste("PC", .y, sep = "")], x = PCA_gene_expectedcount_raw_loadings[, paste("PC", .x, sep = "")], shape = replicatenumber, color = timepoint, size = 2)) +
#   scale_color_brewer(palette = "Spectral") +
#   ggtitle(paste("PCA standard deviations based on raw gene expected counts", sep = "")) +
#   xlab(paste("PC", .x, " (", PCA_gene_expectedcount_raw_variance[paste(.x) %>% as.numeric, "variance_explained"] %>% signif(3), "%)", sep = "")) +
#   ylab(paste("PC", .y, " (", PCA_gene_expectedcount_raw_variance[paste(.y) %>% as.numeric, "variance_explained"] %>% signif(3), "%)", sep = "")) +
#   theme_bw() +
#   theme(text = element_text(family = "Helvetica")) +
#   ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC", .y, "_vs_PC", .x, "_based_on_raw_gene_expectedcount.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
#   ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC", .y, "_vs_PC", .x, "_based_on_raw_gene_expectedcount.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")))
# 

ggplot(PCA_gene_expectedcount_raw_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on raw gene expected counts", sep = "")) +
  xlab(paste("PC1 (", PCA_gene_expectedcount_raw_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_gene_expectedcount_raw_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_raw_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_raw_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_raw_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on raw gene expected counts", sep = "")) +
  xlab(paste("PC2 (", PCA_gene_expectedcount_raw_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_gene_expectedcount_raw_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_raw_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_raw_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_raw_loadings) + 
  geom_point(aes(y = PC4, x = PC3, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on raw gene expected counts", sep = "")) +
  xlab(paste("PC3 (", PCA_gene_expectedcount_raw_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC4 (", PCA_gene_expectedcount_raw_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_raw_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_raw_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_raw_loadings) + 
  geom_point(aes(y = PC5, x = PC4, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on raw gene expected counts", sep = "")) +
  xlab(paste("PC4 (", PCA_gene_expectedcount_raw_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC5 (", PCA_gene_expectedcount_raw_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_raw_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_raw_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_raw_loadings) + 
  geom_point(aes(y = PC6, x = PC5, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on raw gene expected counts", sep = "")) +
  xlab(paste("PC5 (", PCA_gene_expectedcount_raw_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC6 (", PCA_gene_expectedcount_raw_variance[6, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_raw_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_raw_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")


```

##### plot PCA of expected counts with RUVg treatment

```{r}

# repeat the PCA plots
# PCA analysis

PCA_gene_expectedcount_RUVg <- prcomp(OBseries_gene_expectedcount_RUVg[, 2:ncol(OBseries_gene_expectedcount_RUVg)])

# plot standard deviations 

PCA_gene_expectedcount_RUVg_stdev <- tibble(PC = 1:(PCA_gene_expectedcount_RUVg[["sdev"]] %>% length), stdev = PCA_gene_expectedcount_RUVg[["sdev"]])

PCA_gene_expectedcount_RUVg_variance <- tibble(PC = PCA_gene_expectedcount_RUVg_stdev$PC, variance = PCA_gene_expectedcount_RUVg_stdev$stdev ^ 2)
PCA_gene_expectedcount_RUVg_variance <- add_column(PCA_gene_expectedcount_RUVg_variance, variance_explained = PCA_gene_expectedcount_RUVg_variance$variance/sum(PCA_gene_expectedcount_RUVg_variance$variance) * 100)

ggplot(PCA_gene_expectedcount_RUVg_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_gene_expectedcount_RUVg[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on gene expected count with RUVg treament", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_RUVg_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_RUVg_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_gene_expectedcount_RUVg_loadings <- PCA_gene_expectedcount_RUVg[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_gene_expectedcount_RUVg_loadings <- add_column(PCA_gene_expectedcount_RUVg_loadings, timepoint = gsub(x = PCA_gene_expectedcount_RUVg_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_gene_expectedcount_RUVg_loadings <- add_column(PCA_gene_expectedcount_RUVg_loadings, replicatenumber = gsub(x = PCA_gene_expectedcount_RUVg_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_gene_expectedcount_RUVg_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVg treament", sep = "")) +
  xlab(paste("PC1 (", PCA_gene_expectedcount_RUVg_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_gene_expectedcount_RUVg_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_RUVg_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_RUVg_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVg_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVg treament", sep = "")) +
  xlab(paste("PC2 (", PCA_gene_expectedcount_RUVg_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_gene_expectedcount_RUVg_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_RUVg_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_RUVg_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVg_loadings) + 
  geom_point(aes(y = PC4, x = PC3, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVg treament", sep = "")) +
  xlab(paste("PC3 (", PCA_gene_expectedcount_RUVg_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC4 (", PCA_gene_expectedcount_RUVg_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_RUVg_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_RUVg_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVg_loadings) + 
  geom_point(aes(y = PC5, x = PC4, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVg treament", sep = "")) +
  xlab(paste("PC4 (", PCA_gene_expectedcount_RUVg_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC5 (", PCA_gene_expectedcount_RUVg_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_RUVg_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_RUVg_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVg_loadings) + 
  geom_point(aes(y = PC6, x = PC5, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVg treament", sep = "")) +
  xlab(paste("PC5 (", PCA_gene_expectedcount_RUVg_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC6 (", PCA_gene_expectedcount_RUVg_variance[6, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_RUVg_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_RUVg_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

```

##### plot PCA of expected counts with RUVs treatment

```{r}

# repeat the PCA plots
# PCA analysis

PCA_gene_expectedcount_RUVs <- prcomp(OBseries_gene_expectedcount_RUVs[, 2:ncol(OBseries_gene_expectedcount_RUVs)])

# plot standard deviations 

PCA_gene_expectedcount_RUVs_stdev <- tibble(PC = 1:(PCA_gene_expectedcount_RUVs[["sdev"]] %>% length), stdev = PCA_gene_expectedcount_RUVs[["sdev"]])

PCA_gene_expectedcount_RUVs_variance <- tibble(PC = PCA_gene_expectedcount_RUVs_stdev$PC, variance = PCA_gene_expectedcount_RUVs_stdev$stdev ^ 2)
PCA_gene_expectedcount_RUVs_variance <- add_column(PCA_gene_expectedcount_RUVs_variance, variance_explained = PCA_gene_expectedcount_RUVs_variance$variance/sum(PCA_gene_expectedcount_RUVs_variance$variance) * 100)

ggplot(PCA_gene_expectedcount_RUVs_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_gene_expectedcount_RUVs[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on gene expected count with RUVs treament", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_RUVs_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_RUVs_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_gene_expectedcount_RUVs_loadings <- PCA_gene_expectedcount_RUVs[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_gene_expectedcount_RUVs_loadings <- add_column(PCA_gene_expectedcount_RUVs_loadings, timepoint = gsub(x = PCA_gene_expectedcount_RUVs_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_gene_expectedcount_RUVs_loadings <- add_column(PCA_gene_expectedcount_RUVs_loadings, replicatenumber = gsub(x = PCA_gene_expectedcount_RUVs_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_gene_expectedcount_RUVs_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVs treament", sep = "")) +
  xlab(paste("PC1 (", PCA_gene_expectedcount_RUVs_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_gene_expectedcount_RUVs_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_RUVs_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_RUVs_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVs_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVs treament", sep = "")) +
  xlab(paste("PC2 (", PCA_gene_expectedcount_RUVs_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_gene_expectedcount_RUVs_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_RUVs_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_RUVs_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVs_loadings) + 
  geom_point(aes(y = PC4, x = PC3, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVs treament", sep = "")) +
  xlab(paste("PC3 (", PCA_gene_expectedcount_RUVs_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC4 (", PCA_gene_expectedcount_RUVs_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_RUVs_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_RUVs_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVs_loadings) + 
  geom_point(aes(y = PC5, x = PC4, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVs treament", sep = "")) +
  xlab(paste("PC4 (", PCA_gene_expectedcount_RUVs_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC5 (", PCA_gene_expectedcount_RUVs_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_RUVs_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_RUVs_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVs_loadings) + 
  geom_point(aes(y = PC6, x = PC5, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVs treament", sep = "")) +
  xlab(paste("PC5 (", PCA_gene_expectedcount_RUVs_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC6 (", PCA_gene_expectedcount_RUVs_variance[6, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_RUVs_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_RUVs_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

```

##### plot PCA of expected counts with RUVr treatment

```{r}

# repeat the PCA plots
# PCA analysis.

PCA_gene_expectedcount_RUVr <- prcomp(OBseries_gene_expectedcount_RUVr[, 2:ncol(OBseries_gene_expectedcount_RUVr)])

# plot standard deviations 

PCA_gene_expectedcount_RUVr_stdev <- tibble(PC = 1:(PCA_gene_expectedcount_RUVr[["sdev"]] %>% length), stdev = PCA_gene_expectedcount_RUVr[["sdev"]])

PCA_gene_expectedcount_RUVr_variance <- tibble(PC = PCA_gene_expectedcount_RUVr_stdev$PC, variance = PCA_gene_expectedcount_RUVr_stdev$stdev ^ 2)
PCA_gene_expectedcount_RUVr_variance <- add_column(PCA_gene_expectedcount_RUVr_variance, variance_explained = PCA_gene_expectedcount_RUVr_variance$variance/sum(PCA_gene_expectedcount_RUVr_variance$variance) * 100)

ggplot(PCA_gene_expectedcount_RUVr_variance) + 
  geom_col(aes(y = variance_explained, x = PC, fill = PC)) +
  scale_fill_gradientn(colours = heat.colors(n = (PCA_gene_expectedcount_RUVr[["sdev"]] %>% length))) +
  ggtitle(paste("PCA variance distribution amongst PCs based on gene expected count with RUVr treament", sep = "")) +
  xlab("PC") +
  ylab("Variance explained (%)") +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_RUVr_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "barplot_PCA_stdevs_based_on_RUVr_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")

# plot loadings

PCA_gene_expectedcount_RUVr_loadings <- PCA_gene_expectedcount_RUVr[["rotation"]] %>% as_tibble(rownames = "sample")
PCA_gene_expectedcount_RUVr_loadings <- add_column(PCA_gene_expectedcount_RUVr_loadings, timepoint = gsub(x = PCA_gene_expectedcount_RUVr_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\3\\4"))
PCA_gene_expectedcount_RUVr_loadings <- add_column(PCA_gene_expectedcount_RUVr_loadings, replicatenumber = gsub(x = PCA_gene_expectedcount_RUVr_loadings$sample, pattern = "(expected_count_BM_MSC_to_)(.*)_([0-9]{0,2})(d|h|ud)_(r[1-3])(.*)", replacement = "\\5"))

ggplot(PCA_gene_expectedcount_RUVr_loadings) + 
  geom_point(aes(y = PC2, x = PC1, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVr treament", sep = "")) +
  xlab(paste("PC1 (", PCA_gene_expectedcount_RUVr_variance[1, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC2 (", PCA_gene_expectedcount_RUVr_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_RUVr_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 20, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC2_vs_PC1_based_on_RUVr_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 20, height = 20, units = "cm")

ggplot(PCA_gene_expectedcount_RUVr_loadings) + 
  geom_point(aes(y = PC3, x = PC2, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVr treament", sep = "")) +
  xlab(paste("PC2 (", PCA_gene_expectedcount_RUVr_variance[2, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC3 (", PCA_gene_expectedcount_RUVr_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_RUVr_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC3_vs_PC2_based_on_RUVr_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVr_loadings) + 
  geom_point(aes(y = PC4, x = PC3, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVr treament", sep = "")) +
  xlab(paste("PC3 (", PCA_gene_expectedcount_RUVr_variance[3, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC4 (", PCA_gene_expectedcount_RUVr_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_RUVr_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC4_vs_PC3_based_on_RUVr_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVr_loadings) + 
  geom_point(aes(y = PC5, x = PC4, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVr treament", sep = "")) +
  xlab(paste("PC4 (", PCA_gene_expectedcount_RUVr_variance[4, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC5 (", PCA_gene_expectedcount_RUVr_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_RUVr_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC5_vs_PC4_based_on_RUVr_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

ggplot(PCA_gene_expectedcount_RUVr_loadings) + 
  geom_point(aes(y = PC6, x = PC5, shape = replicatenumber, color = timepoint, size = 2)) +
  scale_color_brewer(palette = "Spectral", breaks = order_of_timepoints_OB, limits = order_of_timepoints_OB) +
  ggtitle(paste("PCA standard deviations based on gene expected count with RUVr treament", sep = "")) +
  xlab(paste("PC5 (", PCA_gene_expectedcount_RUVr_variance[5, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  ylab(paste("PC6 (", PCA_gene_expectedcount_RUVr_variance[6, "variance_explained"] %>% signif(3), "%)", sep = "")) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_RUVr_gene_expectedcount_originalconfig.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 30, units = "cm") +
  ggsave(filename = paste(OBseries_qualitycheck_results_dir, "PCA_plot_PC6_vs_PC5_based_on_RUVr_gene_expectedcount_originalconfig.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 30, units = "cm")

```

### Differential Expression Analysis

#### setup the GLM and exacttests

```{r}

OBseries_dge_genecounts_clean <- DGEList(counts = OBseries_gene_expectedcount_RUVr[, 2:ncol(OBseries_gene_expectedcount_RUVr)], genes = OBseries_gene_expectedcount_RUVr$ensembl_gene_id, group = timepoints_OB)
OBseries_dge_genecounts_normfactors <- calcNormFactors(OBseries_dge_genecounts_clean, method = "upperquartile")

# estimate dispersion
OBseries_dge_genecounts_disp <- estimateDisp(OBseries_dge_genecounts_normfactors, design_matrix)

pdf(paste(OBseries_qualitycheck_results_dir, "quality.plot_BCV_post.normalisation.pdf", sep = "")) 

plotBCV(OBseries_dge_genecounts_disp)

dev.off()

```

#### either: pairwise exacttest for significant genes

```{r}

# generate a final wide table of all the pairwise comparison data

no_of_timepoints_OBseries = 1:length(timepoints_OB %>% unique)

timepoint_comparisons_OBseries <- combn(no_of_timepoints_OBseries, 2) %>% t

timepoint_comparison_1_OBseries <- timepoint_comparisons_OBseries[, 1] %>% array_tree
timepoint_comparison_2_OBseries <- timepoint_comparisons_OBseries[, 2] %>% array_tree

# join together all the topTags into one wide table

list_edgeR_pairwise_topTags_OBseries <- purrr::map2(.x = timepoint_comparison_1_OBseries, .y = timepoint_comparison_2_OBseries, .f = ~topTags(exactTest(OBseries_dge_genecounts_disp, pair = c(.x, .y)), n = length(OBseries_gene_expectedcount_RUVr$ensembl_gene_id)))

column_anysig_DEgenes_OBseries <- purrr::map(.x = list_edgeR_pairwise_topTags_OBseries, .f = ~.x$table %>% .[.$FDR <= 0.01 & abs(.$logFC) > 1, "genes"]) %>% purrr::reduce(union) %>% as_tibble %>% setNames("ensembl_gene_id")

```

#### or: GLM test for significant genes

```{r}

OBseries_dge_genecounts_GLM <- estimateGLMCommonDisp(OBseries_dge_genecounts_normfactors, design_matrix)
OBseries_dge_genecounts_GLM <- estimateGLMTagwiseDisp(OBseries_dge_genecounts_GLM, design_matrix)

# calculate QL fit
OBseries_dge_genecounts_QLFit <- glmQLFit(OBseries_dge_genecounts_GLM, design_matrix)

pdf(paste(OBseries_qualitycheck_results_dir, "quality.plot_QL.fit_post.normalisation.pdf", sep = "")) 
plotQLDisp(OBseries_dge_genecounts_QLFit)
dev.off()

pdf(paste(OBseries_qualitycheck_results_dir, "quality.plot_logfc.vs.logCPM_post.normalisation.pdf", sep = "")) 
plotMD(OBseries_dge_genecounts_QLFit)
dev.off()

OBseries_dge_genecounts_LRT <- glmQLFTest(OBseries_dge_genecounts_QLFit, contrast = contrasts_alltimepoints)

tibble_GLM_OBseries <- topTags(OBseries_dge_genecounts_LRT, n = OBseries_gene_expectedcount_RUVr$ensembl_gene_id %>% length)$table %>% as_tibble 

logFC_colnums <- grep(x = colnames(tibble_GLM_OBseries), pattern = "logFC")
FDR_colnum <- grep(x = colnames(tibble_GLM_OBseries), pattern = "FDR")

tibble_GLM_OBseries_DEGrownums <- which(apply(tibble_GLM_OBseries, 1, FUN = function(X) {(any(abs(as.numeric(X[logFC_colnums])) >= 1)) & (X[FDR_colnum] %>% as.numeric < 0.01)}))

column_GLMsig_DEgenes_OBseries <- tibble_GLM_OBseries[tibble_GLM_OBseries_DEGrownums, "genes"] %>% setNames("ensembl_gene_id")

```

##### plot graph of the cumulative changes

###### create tibble of cumulative differential changes, excluding each timepoint successively and filtering by logFC.

```{r}

tibble_GLM_OBseries_filtered <- tibble_GLM_OBseries %>% dplyr::filter(FDR <= 0.01)

tibble_cumulative_diff_changes <- tibble("timepoint" = vec_timepoint_order_OBseries_short_edited, 
                                         "cumulative_diff_changes" = 
                                           c(0, 
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("12d") & !contains("9d") & !contains("6d") & !contains("3d") & !contains("24h") & !contains("12h")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("12d") & !contains("9d") & !contains("6d") & !contains("3d") & !contains("24h")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("12d") & !contains("9d") & !contains("6d") & !contains("3d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("12d") & !contains("9d") & !contains("6d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("12d") & !contains("9d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC") & !contains("12d")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length,
                                             tibble_GLM_OBseries_filtered %>% dplyr::select(contains("logFC")) %>% array_tree %>% purrr::map(.f = ~any(abs(.x %>% trimws %>% as.numeric) >= 1)) %>% unlist %>% which(. == TRUE) %>% length)) %>% 
  add_column("cumulative_diff_changes_pct" = .$cumulative_diff_changes * 100 / (.$cumulative_diff_changes %>% max))

```

###### GGPLOT

```{r}

ggplot(tibble_cumulative_diff_changes, aes(y = cumulative_diff_changes_pct, x = timepoint)) +
  # geom_point() +
  geom_path(aes(group = "OBseries"), colour = "steelblue1") +
  ggtitle("Cumulative changes in the hMSC-TERT4 RNA expression\nOsteogenesis\nRSEM/EdgeR") +
  xlab("Timepoint") +
  ylab("Cumulative differential changes") +
  scale_x_discrete(limits = vec_timepoint_order_OBseries_short_edited, labels = vec_timepoint_order_OBseries_short_edited) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_R_processing_results_dir, "plot_of_cumulative_changes_OBseries.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 12, units = "cm") +
  ggsave(filename = paste(OBseries_R_processing_results_dir, "plot_of_cumulative_changes_OBseries.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 12, units = "cm")

```

#### CREATION OF THE LOGCPM TABLE

normalise ALL gene counts based on library and export

```{r}

logCPM_OBseries_allgenes <- bind_cols(OBseries_gene_expectedcount_RUVr$ensembl_gene_id %>% as_tibble %>% setNames("ensembl_gene_id"), cpm(OBseries_dge_genecounts_normfactors, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2) %>% as_tibble)

colnames(logCPM_OBseries_allgenes) <- gsub(x = colnames(logCPM_OBseries_allgenes), pattern = "expected_count", replacement = "logCPM")

write.table(x = logCPM_OBseries_allgenes, file = paste(OBseries_R_processing_results_dir, "table_edgeR_allgenes_logCPM.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

FILTERING CPM TABLE FOR DEG, FDR AND LOG FOLD CHANGE AND EXPORT

```{r}

cat("\nnumber of DE genes different: ", dplyr::anti_join(column_anysig_DEgenes_OBseries, column_GLMsig_DEgenes_OBseries) %>% nrow)
cat("\nnumber of DE genes in common: ", dplyr::semi_join(column_anysig_DEgenes_OBseries, column_GLMsig_DEgenes_OBseries) %>% nrow)

# purrr::map2(.x = timepoint_comparison_1_OBseries, .y = timepoint_comparison_2_OBseries, .f = ~plotSmear(exactTest(OBseries_dge_genecounts_normfactors, pair = c(.x, .y)), de.tags = rownames(DEGresult$table)[which(DEGresult$table$FDR < 0.05 & abs(DEGresult$table$logFC) > 1.5)]))

# filter the logCPM table by anysig DEGs

logCPM_OBseries_anysig_DEGs <- dplyr::semi_join(logCPM_OBseries_allgenes, column_anysig_DEgenes_OBseries, by = "ensembl_gene_id")

write.table(x = logCPM_OBseries_anysig_DEGs, file = paste(OBseries_R_processing_results_dir, "table_edgeR_anysig_DEGs_logCPM.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter the logCPM table by GLM significant DEGs

df_logCPM_OBseries_GLM_DEGs <- dplyr::semi_join(logCPM_OBseries_allgenes, column_GLMsig_DEgenes_OBseries, by = "ensembl_gene_id")

# retrieve ENSG to external gene name mappings
df_ENSG_to_gene.symbol <- getBM(filters = "ensembl_gene_id", values = df_logCPM_OBseries_GLM_DEGs$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart) 

# dplyr right join the gene symbols 
tibble_logCPM_OBseries_GLM_DEGs <- dplyr::right_join(df_ENSG_to_gene.symbol, df_logCPM_OBseries_GLM_DEGs, by = "ensembl_gene_id") %>% as_tibble

write.table(x = tibble_logCPM_OBseries_GLM_DEGs, file = paste(OBseries_R_processing_results_dir, "table_edgeR_GLM_DEGs_logCPM.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

#### gene ontology to confirm function - all timepoints

##### create catdb

```{r}

# # GOTERM
# 
# polyA_RNAseq_GO_background <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "go_id", "namespace_1003"), mart = ensembl_mart) %>% .[.$namespace_1003 != "",]
# 
# polyA_RNAseq_GO_background[, "namespace_1003"] <- as.character(polyA_RNAseq_GO_background[, "namespace_1003"])
# 
# write.table(x = polyA_RNAseq_GO_background, file = paste(OBseries_R_processing_results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")
# 
# ## Create catDB instance (takes a while but needs to be done only once)
# # note: you had to save the GO annotation file to disk in the previous steps above
# catdb <- makeCATdb(myfile = paste(OBseries_R_processing_results_dir, "polyA_RNAseq_GO_background_GOTERM.txt", sep = ""), lib = NULL, org = "", colno = c(2, 1, 3), idconv = NULL)

```

##### GO analysis

```{r}

list_of_OBseries_DEGs_hyperGOresult_allGO_tables <- purrr::map(.x = c("MF", "BP", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = tibble_logCPM_OBseries_GLM_DEGs$external_gene_name) %>% GOHyperGAll_benjamini_correction %>% as_tibble) %>% set_names(c("MF", "BP", "CC"))

# purrr::map(.x = list_of_OBseries_DEGs_hyperGOresult_allGO_tables, .f = ~print(head(.x, n = 20)))

```

# DRAWING SOMS TO ANALYSE TIME SERIES DATA

## average the values at each timepoint 

```{r}

# list-ify per timepoint
list_of_tibbles_logCPM_OBseries_GLM_DEGs_per_timepoint <- purrr::map(.x = vector_OBseries_timepoints, 
              .f = ~tibble_logCPM_OBseries_GLM_DEGs %>% 
                dplyr::select(contains(.x))) %>% set_names(vector_OBseries_timepoints)

tibble_logCPM_OBseries_GLM_DEGs_averaged <- purrr::map2(.x = list_of_tibbles_logCPM_OBseries_GLM_DEGs_per_timepoint,
                                               .y = names(list_of_tibbles_logCPM_OBseries_GLM_DEGs_per_timepoint),
                                               .f = ~2^.x %>% rowMeans %>% as.data.frame %>% setNames(.y) %>% log2) %>%
  purrr::reduce(bind_cols) %>%
  dplyr::bind_cols(tibble_logCPM_OBseries_GLM_DEGs[, c("ensembl_gene_id", "external_gene_name")], .)

# get rid of "BM_MSC_to_OB_" in the colnames
colnames(tibble_logCPM_OBseries_GLM_DEGs_averaged) <- gsub(x = colnames(tibble_logCPM_OBseries_GLM_DEGs_averaged),
                                                           pattern = "BM_MSC_to_OB_",
                                                           replacement = "")

# shorten the timepoint order
vec_timepoint_order_OBseries_short <- gsub(x = vec_timepoint_order_OBseries,
                                           pattern = "BM_MSC_to_OB_",
                                           replacement = "")

vec_timepoint_order_OBseries_short_edited <- gsub(x = vec_timepoint_order_OBseries_short, pattern = "24h", replacement = "1d")

# rearrange in chronological order 
tibble_logCPM_OBseries_GLM_DEGs_averaged <- tibble_logCPM_OBseries_GLM_DEGs_averaged[, c("ensembl_gene_id", "external_gene_name", vec_timepoint_order_OBseries_short)]

```

## construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# OB series #####

som_5_by_5_OBseries_table  <- tibble_logCPM_OBseries_GLM_DEGs_averaged[, vec_timepoint_order_OBseries_short]

som_5_by_5_OBseries_table <- som_5_by_5_OBseries_table %>% genescale(m = ., axis = 1, method = "Z")

set.seed(som_seed_number)

somdata_5_by_5_OBseries <- som(som_5_by_5_OBseries_table, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_tibble_of_final_SOM_summary_5_by_5_OBseries <- cbind(tibble_logCPM_OBseries_GLM_DEGs_averaged[, c("ensembl_gene_id", "external_gene_name")], som_5_by_5_OBseries_table, cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table
long_tibble_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_tibble_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("ensembl_gene_id", "external_gene_name", "cluster"), variable.name = "timepoint", value.name = "scaled_expr") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_tibble_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_tibble_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_tibble_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_tibble_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_tibble_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_tibble_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_tibble_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_expr" = mean(scaled_expr))

```

### THE GGPLOT

all the genes

```{r}

# OB series
ggplot() +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_expr, group = ensembl_gene_id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_expr, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste("5 x 5 SOM\n", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), " OBseries genes\n", "RSEM/edgeR", sep = "")) +
  scale_x_discrete(limits = vec_timepoint_order_OBseries_short, labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Scaled expr Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(OBseries_R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 20, units = "cm") +
 ggsave(filename = paste(OBseries_R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 20, units = "cm")

write.table(x = wide_tibble_of_final_SOM_summary_5_by_5_OBseries, file = paste(OBseries_R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Gene ontology of each SOM cluster

### GO enrichment

```{r}

# list-ify the scaled expression table by cluster
list_of_tibbles_final_SOM_summary_by_cluster <- wide_tibble_of_final_SOM_summary_5_by_5_OBseries %>% 
  group_split(cluster)
# name each element
names(list_of_tibbles_final_SOM_summary_by_cluster) <- list_of_tibbles_final_SOM_summary_by_cluster %>% 
  purrr::map(.f = ~.x$cluster %>% unique) %>%
  unlist

# extract geneset
list_of_genesets_by_cluster <- list_of_tibbles_final_SOM_summary_by_cluster %>%
  purrr::map(.f = ~.x$external_gene_name %>% unique)

# let's try to do all enrichment at once using purrr
list_of_genesets_x_GOterms <- list("MF" = list_of_genesets_by_cluster,
                                   "BP" = list_of_genesets_by_cluster,
                                   "CC" = list_of_genesets_by_cluster)

# note: each element will be [[1]]: gene set, [[2]]: GO term to query
list_of_hyperGO_tibbles_per_cluster <- purrr::map2(.x = list_of_genesets_x_GOterms,
                                                   .y = names(list_of_genesets_x_GOterms),
                                                   .f = function(a1, a2) {
                                                     
                                                     future_map(.x = a1, .f = ~GOHyperGAll(catdb = catdb, gocat = a2, Nannot = 2, sample = .x) %>% GOHyperGAll_benjamini_correction %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "as_tibble"))) %>% return
                                                                
                                                   } )

# add the cluster column
list_of_hyperGO_tibbles_per_cluster <- list_of_hyperGO_tibbles_per_cluster %>% purrr::map(.f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~add_column(.x, "cluster" = .y)))

# rbind and tibblise
tibble_hyperGO_per_cluster <- list_of_hyperGO_tibbles_per_cluster %>% flatten %>% rbindlist %>% as_tibble
# write table
write.table(x = tibble_hyperGO_per_cluster, file = paste(OBseries_R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2_GOterm_all.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# take the top ten goterms per cluster
tibble_hyperGO_per_cluster_topten <- tibble_hyperGO_per_cluster %>% 
  dplyr::group_by(cluster, Ont) %>%
  dplyr::arrange(Phyper) %>%
  dplyr::slice_head(n = 10)

tibble_hyperGO_per_cluster_topten[, "cluster"] <- factor(tibble_hyperGO_per_cluster_topten$cluster, levels = tibble_hyperGO_per_cluster_topten$cluster %>% unique %>% mixedsort)

# cheeky ggplot
purrr::map(.x = tibble_hyperGO_per_cluster_topten$Ont %>% unique, .f = function(a1) { 
  
  # DEBUG ###
  # .x <- tibble_hyperGO_per_cluster_topten$Ont %>% unique %>% .[1]
  ###########
  
  cat("\nplotting: ", a1)
  
  # tibble <- tibble_hyperGO_per_cluster_topten[tibble_hyperGO_per_cluster_topten$Ont == .x, ] %>% ungroup %>% dplyr::arrange(Phyper) %>% add_column("dummy" = 1:nrow(.))
  
  ggplot(tibble_hyperGO_per_cluster_topten[tibble_hyperGO_per_cluster_topten$Ont == a1, ], aes(x = reorder(Term, Phyper), y = log10(Padj))) +
    geom_col(aes(fill = SampleMatch)) +
    geom_hline(yintercept = log10(0.05), colour = "red", lty = 2) +
    scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
    facet_wrap(~cluster, scales = "free") +
    ggtitle(paste("Top 10 significantly over-represented", a1, "GO terms for each cluster")) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
    xlab("GO term") +
    ylab(expression(log["10"](P))) +
    # coord_cartesian(ylim = c(0, 20)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(OBseries_R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2_GOterm_", a1, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
    ggsave(filename = paste(OBseries_R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2_GOterm_", a1, ".svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm") 
  
  })

```

## GO term enrichment at each timepoint

### hyperGO

here, we say > 0 scaled avg. expr is 

```{r}

# list-ify the scaled expression table by cluster
list_of_tibbles_final_SOM_summary_by_timepoint <- wide_tibble_of_final_SOM_summary_5_by_5_OBseries %>% 
  reshape2::melt(id.vars = c("ensembl_gene_id", "external_gene_name", "cluster"), variable.name = "timepoint", value.name = "avg_expr") %>% 
  as_tibble %>%
  group_split(timepoint)
# name each element
names(list_of_tibbles_final_SOM_summary_by_timepoint) <- list_of_tibbles_final_SOM_summary_by_timepoint %>% 
  purrr::map(.f = ~.x$timepoint %>% unique) %>%
  unlist

# extract geneset
list_of_genesets_by_timepoint <- list("highest" = list_of_tibbles_final_SOM_summary_by_timepoint %>%
                                        purrr::map(.f = ~.x %>% dplyr::filter(avg_expr > 0) %>% .$external_gene_name %>% unique),
                                      "lowest" = list_of_tibbles_final_SOM_summary_by_timepoint %>%
                                        purrr::map(.f = ~.x %>% dplyr::filter(avg_expr < 0) %>% .$external_gene_name %>% unique))

# let's try to do all enrichment at once using purrr
list_of_genesets_x_GOterms <- list("MF" = list_of_genesets_by_timepoint,
                                   "BP" = list_of_genesets_by_timepoint,
                                   "CC" = list_of_genesets_by_timepoint)

# note: each element will be [[1]]: gene set, [[2]]: GO term to query
list_of_hyperGO_tibbles_per_timepoint <- purrr::map2(.x = list_of_genesets_x_GOterms,
                                                   .y = names(list_of_genesets_x_GOterms),
                                                   .f = function(a1, a2) {
                                                     
                                                     # DEBUG ###
                                                     # a1 <- list_of_genesets_x_GOterms[[1]]
                                                     # a2 <- names(list_of_genesets_x_GOterms) %>% .[1]
                                                     ###########
                                                     
                                                     purrr::map2(.x = a1, .y = names(a1), .f = function(b1, b2) {
                                                       
                                                       # DEBUG ###
                                                       # b1 <- list_of_genesets_x_GOterms[[1]][[1]]
                                                       # b2 <- names(list_of_genesets_x_GOterms[[1]]) %>% .[1]
                                                       ###########
                                                       
                                                       future_map2(.x = b1, names(b1), .f = function(c1, c2) {
                                                         
                                                         GOHyperGAll(catdb = catdb, gocat = a2, Nannot = 2, sample = c1) %>% 
                                                           GOHyperGAll_benjamini_correction %>% 
                                                           as_tibble %>% 
                                                           add_column("timepoint" = c2, "highest_or_lowest" = b2) %>% 
                                                           return
                                                         
                                                       }, .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "as_tibble", "a2", "b2"))) %>% return # L3: timepoints
                                                       
                                                     } ) %>% return # L2: highest/lowest
                                                                
                                                   } ) # L1: MF/BP/CC

# rbind and tibblise
tibble_hyperGO_per_timepoint <- list_of_hyperGO_tibbles_per_timepoint %>% flatten %>% flatten %>% rbindlist %>% as_tibble
# write table
write.table(x = tibble_hyperGO_per_timepoint, file = paste(OBseries_R_processing_results_dir, "timepointwise_highest.lowest_genes_OB_diff_qvalue0.01_fc2_GOterm_all.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# take the top ten goterms per cluster
tibble_hyperGO_per_timepoint_topten <- tibble_hyperGO_per_timepoint %>% 
  dplyr::filter(NodeSize <= 1000) %>%
  dplyr::group_by(timepoint, Ont, highest_or_lowest) %>%
  dplyr::arrange(Phyper) %>%
  dplyr::slice_head(n = 20)

tibble_hyperGO_per_timepoint_topten[, "timepoint"] <- factor(tibble_hyperGO_per_timepoint_topten$timepoint, levels = vec_timepoint_order_OBseries_short)

# generate Ont x highest/lowest cross for looping.
list_ont_x_highest.lowest <- purrr::cross2(.x = tibble_hyperGO_per_timepoint_topten$Ont %>% unique,
                                           .y = tibble_hyperGO_per_timepoint_topten$highest_or_lowest %>% unique)

# cheeky ggplot
purrr::map(.x = list_ont_x_highest.lowest, .f = function(a1) { 
  
  # DEBUG ###
  # .x <- tibble_hyperGO_per_timepoint_topten$Ont %>% unique %>% .[1]
  ###########
  
  cat("\nplotting: ", a1[[1]], ", ", a1[[2]])
  
  # tibble <- tibble_hyperGO_per_timepoint_topten[tibble_hyperGO_per_timepoint_topten$Ont == .x, ] %>% ungroup %>% dplyr::arrange(Phyper) %>% add_column("dummy" = 1:nrow(.))
  
  ggplot(tibble_hyperGO_per_timepoint_topten %>% dplyr::filter(Ont == a1[[1]] & highest_or_lowest == a1[[2]]), aes(x = reorder(Term, Phyper), y = log10(Padj))) +
    geom_col(aes(fill = SampleMatch)) +
    geom_hline(yintercept = log10(0.05), colour = "red", lty = 2) +
    scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
    facet_wrap(~timepoint, scales = "free") +
    ggtitle(paste("Top 20 significantly over-represented ", a1[[1]], " GO terms for each cluster\n", a1[[2]], " expression, timepoint-wise", sep = "")) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
    xlab("GO term") +
    ylab(expression(log["10"](P))) +
    # coord_cartesian(ylim = c(0, 20)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(OBseries_R_processing_results_dir, "timepointwise_", a1[[2]], "_genes_OB_diff_qvalue0.01_fc2_GOterm_", a1[[1]], ".pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
    ggsave(filename = paste(OBseries_R_processing_results_dir, "timepointwise_", a1[[2]], "_genes_OB_diff_qvalue0.01_fc2_GOterm_", a1[[1]], ".svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm") 
  
  })

```

#### hierarchical clustering of GO terms per timepoint to show different regulatory modules at work over time

```{r}

# melt the table of GOterms per timepoint into separate columns for timepoints
wide_tibble_hyperGO_per_timepoint <- reshape2::dcast(data = tibble_hyperGO_per_timepoint %>% dplyr::filter(Ont == "BP" & highest_or_lowest == "highest" & NodeSize <= 1000),
                                                     formula = Term + Ont ~ timepoint, value.var = "Padj") %>% as_tibble

wide_tibble_hyperGO_per_timepoint[is.na(wide_tibble_hyperGO_per_timepoint)] <- 1

# remove GO Terms which are not sig in at least one timepoint.
## vector of row indices where it's significant in at least one timepoint.
vec_row_indices_anysig <- wide_tibble_hyperGO_per_timepoint[, vec_timepoint_order_OBseries_short] %>% array_tree %>% purrr::map(.f = ~any(.x <= 0.05)) %>% unlist %>% which(. == TRUE)

wide_tibble_hyperGO_per_timepoint <- wide_tibble_hyperGO_per_timepoint[vec_row_indices_anysig, ]

dist_result <- dist(wide_tibble_hyperGO_per_timepoint[, vec_timepoint_order_OBseries_short], method = "euclidean")
hclust_result <- hclust(dist_result, method = "ward.D2")
dendrogram <- as.dendrogram(hclust_result)

# reorder the dendrogram so different patches are further away
# matrix_rowmeans <- rowMeans(wide_tibble_hyperGO_per_timepoint[, vec_timepoint_order_OBseries_short], na.rm = T)
matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint[, vec_timepoint_order_OBseries_short] %>% t) %>% .[["rotation"]] %>% .[, 1]
dendrogram_reordered <- reorder(dendrogram, matrix_PCA1_rowwise)

tibble_reordered <- wide_tibble_hyperGO_per_timepoint[dendrogram_reordered %>% unlist, ]

# get the order of goterms due to the clustering
vector_goterms_ordered <- tibble_reordered$Term

# melt for ggplot 
long_tibble_reordered <- reshape2::melt(tibble_reordered, variable.name = "timepoint", value.name = "Padj", id.vars = c("Term", "Ont")) %>% as_tibble

# plot the main heatmap
ggplot(long_tibble_reordered, aes(fill = -Padj)) +
  geom_tile(aes(x = timepoint, y = Term)) +
  ggtitle(paste("Heatmap of any significant BP GOterms per timepoint", sep = "")) +
  scale_x_discrete(breaks = vec_timepoint_order_OBseries_short, labels = vec_timepoint_order_OBseries_short_edited, limits = vec_timepoint_order_OBseries_short) +
  scale_y_discrete(breaks = vector_goterms_ordered[seq(from = 1, to = length(vector_goterms_ordered), by = 2)], labels = vector_goterms_ordered[seq(from = 1, to = length(vector_goterms_ordered), by = 2)], limits = vector_goterms_ordered) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black"), values = c(0, 0.33, 0.67, 1)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 20, lineheight = 0.75, colour = "black", margin = margin(r = 10)), legend.title.align = 0.5, axis.text.y = element_text(size = 0.5, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 10)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_R_processing_results_dir, "heatmap_BP_GOterms_per_timepoint_all.pdf", sep = ""), device = "pdf", dpi = 600, width = 20, height = 40, units = "cm", limitsize = FALSE)

# plot select GO terms
vector_goterms_to_plot <- c("response to unfolded protein", "mitotic cell cycle", "regulation of cell cycle G2/M phase transition", "regulation of cell cycle G1/S phase transition", "histone H3-K9 methylation", "regulation of voltage−gated calcium channel activity", "sodium ion transmembrane transport", "ossification", "response to glucocorticoid", "osteoblast differentiation", "extracellular matrix organization", "cell-matrix adhesion", "cell-cell adhesion", "actin cytoskeleton organization", "positive regulation of NIK/NF-kappaB signaling", "p38MAPK cascade", "Wnt signaling pathway", "Notch signaling pathway", "regulation of BMP signaling pathway", "negative regulation of cell death", "positive regulation of Wnt signaling pathway, planar cell polarity pathway", "integrin-mediated signaling pathway")

ggplot(long_tibble_reordered, aes(fill = -Padj)) +
  geom_tile(aes(x = timepoint, y = Term)) +
  ggtitle(paste("Heatmap of select BP GOterms per timepoint", sep = "")) +
  scale_x_discrete(breaks = vec_timepoint_order_OBseries_short, labels = vec_timepoint_order_OBseries_short_edited, limits = vec_timepoint_order_OBseries_short) +
  scale_y_discrete(breaks = vector_goterms_ordered[which(vector_goterms_ordered %in% vector_goterms_to_plot)], labels = vector_goterms_ordered[which(vector_goterms_ordered %in% vector_goterms_to_plot)], limits = vector_goterms_ordered[which(vector_goterms_ordered %in% vector_goterms_to_plot)]) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black"), values = c(0, 0.33, 0.67, 1)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(lineheight = 0.75, colour = "black"), axis.title.y = element_text(), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(OBseries_R_processing_results_dir, "heatmap_BP_GOterms_per_timepoint_select.pdf", sep = ""), device = "pdf", dpi = 600, width = 17, height = 13, units = "cm", limitsize = FALSE)

```

